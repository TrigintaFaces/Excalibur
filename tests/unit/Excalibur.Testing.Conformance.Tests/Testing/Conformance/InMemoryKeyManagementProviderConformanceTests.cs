// SPDX-FileCopyrightText: Copyright (c) 2026 The Excalibur Project
// SPDX-License-Identifier: LicenseRef-Excalibur-1.0 OR AGPL-3.0-or-later OR SSPL-1.0 OR Apache-2.0

using Excalibur.Dispatch.Compliance;

using Excalibur.Testing.Conformance;

using Microsoft.Extensions.Logging.Abstractions;

using Xunit;

namespace Excalibur.Tests.Testing.Conformance;

/// <summary>
/// Conformance tests for <see cref="InMemoryKeyManagementProvider"/> validating IKeyManagementProvider contract compliance.
/// </summary>
/// <remarks>
/// <para>
/// InMemoryKeyManagementProvider uses instance-level ConcurrentDictionary with no static state,
/// so no special isolation is required beyond using fresh store instances.
/// </para>
/// <para>
/// <strong>COMPLIANCE-CRITICAL:</strong> IKeyManagementProvider implements key lifecycle management
/// per ADR-051 (Encryption Framework) and ADR-054 (GDPR Right to Erasure via crypto-shredding).
/// </para>
/// <para>
/// Key behaviors verified:
/// <list type="bullet">
/// <item><description>RotateKeyAsync creates new key or new version (does NOT throw on duplicate)</description></item>
/// <item><description>Rotation marks previous version as DecryptOnly</description></item>
/// <item><description>GetKeyAsync returns latest version</description></item>
/// <item><description>GetKeyVersionAsync returns specific version metadata</description></item>
/// <item><description>ListKeysAsync supports status and purpose filtering</description></item>
/// <item><description>DeleteKeyAsync schedules key for destruction (crypto-shredding)</description></item>
/// <item><description>SuspendKeyAsync suspends all versions immediately</description></item>
/// <item><description>GetActiveKeyAsync returns active key with purpose filtering</description></item>
/// <item><description>Disposed provider throws ObjectDisposedException</description></item>
/// </list>
/// </para>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Naming", "CA1707:Identifiers should not contain underscores", Justification = "Test method naming convention")]
[Trait("Category", "Integration")]
[Trait("Component", "Compliance")]
[Trait("Pattern", "PROVIDER")]
public class InMemoryKeyManagementProviderConformanceTests : KeyManagementProviderConformanceTestKit
{
	/// <inheritdoc />
	protected override IKeyManagementProvider CreateProvider() =>
		new InMemoryKeyManagementProvider(
			NullLogger<InMemoryKeyManagementProvider>.Instance,
			new InMemoryKeyManagementOptions { AutoGenerateDefaultKey = false });

	#region GetKey Tests

	[Fact]
	public Task GetKeyAsync_NonExistent_ShouldReturnNull_Test() =>
		GetKeyAsync_NonExistent_ShouldReturnNull();

	[Fact]
	public Task GetKeyAsync_NullKeyId_ShouldThrowArgumentException_Test() =>
		GetKeyAsync_NullKeyId_ShouldThrowArgumentException();

	[Fact]
	public Task GetKeyAsync_ExistingKey_ShouldReturnLatestVersion_Test() =>
		GetKeyAsync_ExistingKey_ShouldReturnLatestVersion();

	#endregion GetKey Tests

	#region GetKeyVersion Tests

	[Fact]
	public Task GetKeyVersionAsync_NonExistentVersion_ShouldReturnNull_Test() =>
		GetKeyVersionAsync_NonExistentVersion_ShouldReturnNull();

	[Fact]
	public Task GetKeyVersionAsync_ExistingVersion_ShouldReturnCorrectMetadata_Test() =>
		GetKeyVersionAsync_ExistingVersion_ShouldReturnCorrectMetadata();

	#endregion GetKeyVersion Tests

	#region ListKeys Tests

	[Fact]
	public Task ListKeysAsync_NoKeys_ShouldReturnEmptyList_Test() =>
		ListKeysAsync_NoKeys_ShouldReturnEmptyList();

	[Fact]
	public Task ListKeysAsync_FilterByStatus_ShouldFilterCorrectly_Test() =>
		ListKeysAsync_FilterByStatus_ShouldFilterCorrectly();

	[Fact]
	public Task ListKeysAsync_FilterByPurpose_ShouldFilterCorrectly_Test() =>
		ListKeysAsync_FilterByPurpose_ShouldFilterCorrectly();

	#endregion ListKeys Tests

	#region RotateKey Tests

	[Fact]
	public Task RotateKeyAsync_NewKey_ShouldCreateVersion1_Test() =>
		RotateKeyAsync_NewKey_ShouldCreateVersion1();

	[Fact]
	public Task RotateKeyAsync_ExistingKey_ShouldCreateNewVersionAndMarkOldDecryptOnly_Test() =>
		RotateKeyAsync_ExistingKey_ShouldCreateNewVersionAndMarkOldDecryptOnly();

	[Fact]
	public Task RotateKeyAsync_NullKeyId_ShouldThrowArgumentException_Test() =>
		RotateKeyAsync_NullKeyId_ShouldThrowArgumentException();

	#endregion RotateKey Tests

	#region DeleteKey Tests

	[Fact]
	public Task DeleteKeyAsync_NonExistent_ShouldReturnFalse_Test() =>
		DeleteKeyAsync_NonExistent_ShouldReturnFalse();

	[Fact]
	public Task DeleteKeyAsync_ExistingKey_ShouldScheduleForDestruction_Test() =>
		DeleteKeyAsync_ExistingKey_ShouldScheduleForDestruction();

	#endregion DeleteKey Tests

	#region SuspendKey Tests

	[Fact]
	public Task SuspendKeyAsync_NonExistent_ShouldReturnFalse_Test() =>
		SuspendKeyAsync_NonExistent_ShouldReturnFalse();

	[Fact]
	public Task SuspendKeyAsync_ExistingKey_ShouldSuspendAllVersions_Test() =>
		SuspendKeyAsync_ExistingKey_ShouldSuspendAllVersions();

	[Fact]
	public Task SuspendKeyAsync_NullReason_ShouldThrowArgumentException_Test() =>
		SuspendKeyAsync_NullReason_ShouldThrowArgumentException();

	#endregion SuspendKey Tests

	#region GetActiveKey Tests

	[Fact]
	public Task GetActiveKeyAsync_NoActiveKey_ShouldReturnNull_Test() =>
		GetActiveKeyAsync_NoActiveKey_ShouldReturnNull();

	[Fact]
	public Task GetActiveKeyAsync_ActiveKeyExists_ShouldReturnActiveKey_Test() =>
		GetActiveKeyAsync_ActiveKeyExists_ShouldReturnActiveKey();

	[Fact]
	public Task GetActiveKeyAsync_FilterByPurpose_ShouldFilterCorrectly_Test() =>
		GetActiveKeyAsync_FilterByPurpose_ShouldFilterCorrectly();

	[Fact]
	public Task GetActiveKeyAsync_SuspendedKey_ShouldNotReturn_Test() =>
		GetActiveKeyAsync_SuspendedKey_ShouldNotReturn();

	#endregion GetActiveKey Tests

	#region Disposable Tests

	[Fact]
	public Task Disposed_Provider_ShouldThrowObjectDisposedException_Test() =>
		Disposed_Provider_ShouldThrowObjectDisposedException();

	#endregion Disposable Tests
}
