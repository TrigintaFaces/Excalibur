// SPDX-FileCopyrightText: Copyright (c) 2026 The Excalibur Project
// SPDX-License-Identifier: LicenseRef-Excalibur-1.0 OR AGPL-3.0-or-later OR SSPL-1.0 OR Apache-2.0

using Excalibur.Dispatch.Compliance;

using Excalibur.Testing.Conformance;

using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.Extensions.Options;

using Xunit;

namespace Excalibur.Tests.Testing.Conformance;

/// <summary>
/// Conformance tests for <see cref="KeyRotationService"/> validating IKeyRotationScheduler contract compliance.
/// </summary>
/// <remarks>
/// <para>
/// KeyRotationService extends BackgroundService and implements IKeyRotationScheduler.
/// Tests use the IKeyRotationScheduler interface directly without starting the background loop.
/// </para>
/// <para>
/// <strong>COMPLIANCE-CRITICAL:</strong> IKeyRotationScheduler implements automatic key rotation
/// per ADR-051 (Encryption Framework) for SOC 2 and GDPR compliance:
/// <list type="bullet">
/// <item><description>Policy-based rotation (90-day default, 30-day high-security, 365-day archival)</description></item>
/// <item><description>ForceRotateAsync requires audit reason for compliance trail</description></item>
/// <item><description>Batch processing with concurrency control</description></item>
/// <item><description>Zero-downtime rotation with key versioning</description></item>
/// </list>
/// </para>
/// <para>
/// <strong>FIRST BackgroundService CONFORMANCE KIT:</strong> This is the first conformance kit
/// that tests a BackgroundService implementation through its interface.
/// </para>
/// <para>
/// Key behaviors verified:
/// <list type="bullet">
/// <item><description>CheckAndRotateAsync returns empty result for no keys</description></item>
/// <item><description>CheckAndRotateAsync checks but doesn't rotate recent keys</description></item>
/// <item><description>CheckAndRotateAsync includes timestamps</description></item>
/// <item><description>IsRotationDueAsync throws ArgumentException for null/empty keyId</description></item>
/// <item><description>IsRotationDueAsync returns false for non-existent keys</description></item>
/// <item><description>IsRotationDueAsync returns false for recent keys</description></item>
/// <item><description>ForceRotateAsync throws ArgumentException for null/empty keyId</description></item>
/// <item><description>ForceRotateAsync throws ArgumentException for null/empty reason</description></item>
/// <item><description>ForceRotateAsync returns failed result for non-existent keys</description></item>
/// <item><description>ForceRotateAsync successfully rotates existing keys</description></item>
/// <item><description>GetNextRotationTimeAsync throws ArgumentException for null/empty keyId</description></item>
/// <item><description>GetNextRotationTimeAsync returns null for non-existent keys</description></item>
/// <item><description>GetNextRotationTimeAsync returns calculated time for existing keys</description></item>
/// </list>
/// </para>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Naming", "CA1707:Identifiers should not contain underscores", Justification = "Test method naming convention")]
[Trait("Category", "Integration")]
[Trait("Component", "Compliance")]
[Trait("Pattern", "SCHEDULER")]
public sealed class KeyRotationSchedulerConformanceTests : KeyRotationSchedulerConformanceTestKit, IDisposable
{
	private IKeyRotationScheduler? _scheduler;
	private IKeyManagementProvider? _keyProvider;

	/// <inheritdoc />
	public void Dispose()
	{
		(_scheduler as IDisposable)?.Dispose();
		(_keyProvider as IDisposable)?.Dispose();
	}

	/// <inheritdoc />
	protected override (IKeyRotationScheduler Scheduler, IKeyManagementProvider KeyProvider, KeyRotationOptions Options) CreateScheduler()
	{
		// Create key provider with auto-generate disabled for test isolation
		_keyProvider = new InMemoryKeyManagementProvider(
			NullLogger<InMemoryKeyManagementProvider>.Instance,
			new InMemoryKeyManagementOptions { AutoGenerateDefaultKey = false });

		// Create options with default policy
		var options = new KeyRotationOptions
		{
			DefaultPolicy = KeyRotationPolicy.Default,
			ContinueOnError = true
		};

		// Create scheduler (KeyRotationService extends BackgroundService + IKeyRotationScheduler)
		_scheduler = new KeyRotationService(
			_keyProvider,
			Options.Create(options),
			NullLogger<KeyRotationService>.Instance);

		return (_scheduler, _keyProvider, options);
	}

	#region CheckAndRotateAsync Tests

	[Fact]
	public Task CheckAndRotateAsync_NoKeys_ShouldReturnEmptyResult_Test() =>
		CheckAndRotateAsync_NoKeys_ShouldReturnEmptyResult();

	[Fact]
	public Task CheckAndRotateAsync_WithRecentKeys_ShouldCheckButNotRotate_Test() =>
		CheckAndRotateAsync_WithRecentKeys_ShouldCheckButNotRotate();

	[Fact]
	public Task CheckAndRotateAsync_ShouldIncludeTimestamps_Test() =>
		CheckAndRotateAsync_ShouldIncludeTimestamps();

	#endregion CheckAndRotateAsync Tests

	#region IsRotationDueAsync Tests

	[Fact]
	public Task IsRotationDueAsync_NullKeyId_ShouldThrowArgumentException_Test() =>
		IsRotationDueAsync_NullKeyId_ShouldThrowArgumentException();

	[Fact]
	public Task IsRotationDueAsync_EmptyKeyId_ShouldThrowArgumentException_Test() =>
		IsRotationDueAsync_EmptyKeyId_ShouldThrowArgumentException();

	[Fact]
	public Task IsRotationDueAsync_NonExistentKey_ShouldReturnFalse_Test() =>
		IsRotationDueAsync_NonExistentKey_ShouldReturnFalse();

	[Fact]
	public Task IsRotationDueAsync_RecentKey_ShouldReturnFalse_Test() =>
		IsRotationDueAsync_RecentKey_ShouldReturnFalse();

	#endregion IsRotationDueAsync Tests

	#region ForceRotateAsync Tests

	[Fact]
	public Task ForceRotateAsync_NullKeyId_ShouldThrowArgumentException_Test() =>
		ForceRotateAsync_NullKeyId_ShouldThrowArgumentException();

	[Fact]
	public Task ForceRotateAsync_EmptyKeyId_ShouldThrowArgumentException_Test() =>
		ForceRotateAsync_EmptyKeyId_ShouldThrowArgumentException();

	[Fact]
	public Task ForceRotateAsync_NullReason_ShouldThrowArgumentException_Test() =>
		ForceRotateAsync_NullReason_ShouldThrowArgumentException();

	[Fact]
	public Task ForceRotateAsync_EmptyReason_ShouldThrowArgumentException_Test() =>
		ForceRotateAsync_EmptyReason_ShouldThrowArgumentException();

	[Fact]
	public Task ForceRotateAsync_NonExistentKey_ShouldReturnFailedResult_Test() =>
		ForceRotateAsync_NonExistentKey_ShouldReturnFailedResult();

	[Fact]
	public Task ForceRotateAsync_ExistingKey_ShouldRotateSuccessfully_Test() =>
		ForceRotateAsync_ExistingKey_ShouldRotateSuccessfully();

	#endregion ForceRotateAsync Tests

	#region GetNextRotationTimeAsync Tests

	[Fact]
	public Task GetNextRotationTimeAsync_NullKeyId_ShouldThrowArgumentException_Test() =>
		GetNextRotationTimeAsync_NullKeyId_ShouldThrowArgumentException();

	[Fact]
	public Task GetNextRotationTimeAsync_EmptyKeyId_ShouldThrowArgumentException_Test() =>
		GetNextRotationTimeAsync_EmptyKeyId_ShouldThrowArgumentException();

	[Fact]
	public Task GetNextRotationTimeAsync_NonExistentKey_ShouldReturnNull_Test() =>
		GetNextRotationTimeAsync_NonExistentKey_ShouldReturnNull();

	[Fact]
	public Task GetNextRotationTimeAsync_ExistingKey_ShouldReturnCalculatedTime_Test() =>
		GetNextRotationTimeAsync_ExistingKey_ShouldReturnCalculatedTime();

	#endregion GetNextRotationTimeAsync Tests
}
