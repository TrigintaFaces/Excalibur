// SPDX-FileCopyrightText: Copyright (c) 2026 The Excalibur Project
// SPDX-License-Identifier: LicenseRef-Excalibur-1.0 OR AGPL-3.0-or-later OR SSPL-1.0 OR Apache-2.0

using Excalibur.Dispatch.Compliance;

using Excalibur.Testing.Conformance;

using Microsoft.Extensions.Logging.Abstractions;

using Xunit;

namespace Excalibur.Tests.Testing.Conformance;

/// <summary>
/// Conformance tests for <see cref="InMemoryMasterKeyBackupService"/> validating IMasterKeyBackupService contract compliance.
/// </summary>
/// <remarks>
/// <para>
/// InMemoryMasterKeyBackupService provides master key backup and disaster recovery using Shamir's Secret Sharing
/// for scenarios where Hardware Security Modules (HSMs) are not available.
/// </para>
/// <para>
/// <strong>SECURITY INFRASTRUCTURE:</strong> IMasterKeyBackupService implements secure master key backup and recovery
/// patterns for regulatory compliance with disaster recovery requirements.
/// </para>
/// <para>
/// Key behaviors verified:
/// <list type="bullet">
/// <item><description>ExportMasterKeyAsync null throws ArgumentException</description></item>
/// <item><description>ExportMasterKeyAsync non-existent throws MasterKeyBackupException</description></item>
/// <item><description>ExportMasterKeyAsync valid key returns backup</description></item>
/// <item><description>ImportMasterKeyAsync null throws ArgumentNullException</description></item>
/// <item><description>ImportMasterKeyAsync expired throws MasterKeyBackupException</description></item>
/// <item><description>ImportMasterKeyAsync key exists throws MasterKeyBackupException</description></item>
/// <item><description>GenerateRecoverySplitAsync creates Shamir shares</description></item>
/// <item><description>GenerateRecoverySplitAsync validates threshold constraints</description></item>
/// <item><description>ReconstructFromSharesAsync validates share count</description></item>
/// <item><description>ReconstructFromSharesAsync validates share consistency</description></item>
/// <item><description>VerifyBackupAsync checks integrity without import</description></item>
/// <item><description>GetBackupStatusAsync returns status with risk assessment</description></item>
/// </list>
/// </para>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Naming", "CA1707:Identifiers should not contain underscores", Justification = "Test method naming convention")]
[Trait("Category", "Integration")]
[Trait("Component", "Compliance")]
[Trait("Pattern", "SERVICE")]
public sealed class InMemoryMasterKeyBackupServiceConformanceTests : MasterKeyBackupServiceConformanceTestKit, IDisposable
{
	private InMemoryKeyManagementProvider? _keyManagementProvider;
	private AesGcmEncryptionProvider? _encryptionProvider;

	/// <inheritdoc />
	public void Dispose()
	{
		_encryptionProvider?.Dispose();
		_keyManagementProvider?.Dispose();
	}

	/// <inheritdoc />
	protected override IMasterKeyBackupService CreateService()
	{
		// Create key management provider with auto-generated default key
		_keyManagementProvider = new InMemoryKeyManagementProvider(
			NullLogger<InMemoryKeyManagementProvider>.Instance,
			new InMemoryKeyManagementOptions { AutoGenerateDefaultKey = true });

		// Create AES-GCM encryption provider
		_encryptionProvider = new AesGcmEncryptionProvider(
			_keyManagementProvider,
			NullLogger<AesGcmEncryptionProvider>.Instance);

		// Create the backup service
		return new InMemoryMasterKeyBackupService(
			_keyManagementProvider,
			_encryptionProvider,
			NullLogger<InMemoryMasterKeyBackupService>.Instance);
	}

	/// <inheritdoc />
	protected override async Task RegisterTestKeyAsync(
		IMasterKeyBackupService service,
		string keyId,
		byte[] keyMaterial,
		CancellationToken cancellationToken)
	{
		// InMemoryMasterKeyBackupService has a RegisterKeyMaterial method for testing
		if (service is InMemoryMasterKeyBackupService inMemoryService)
		{
			inMemoryService.RegisterKeyMaterial(keyId, keyMaterial);

			// Also register the key in the key management provider
			if (_keyManagementProvider != null)
			{
				_ = await _keyManagementProvider.RotateKeyAsync(
					keyId,
					EncryptionAlgorithm.Aes256Gcm,
					purpose: null,
					expiresAt: null,
					cancellationToken).ConfigureAwait(false);
			}
		}
	}

	#region ExportMasterKeyAsync Tests

	[Fact]
	public Task ExportMasterKeyAsync_NullKeyId_ShouldThrowArgumentException_Test() =>
		ExportMasterKeyAsync_NullKeyId_ShouldThrowArgumentException();

	[Fact]
	public Task ExportMasterKeyAsync_NonExistentKey_ShouldThrowMasterKeyBackupException_Test() =>
		ExportMasterKeyAsync_NonExistentKey_ShouldThrowMasterKeyBackupException();

	[Fact]
	public Task ExportMasterKeyAsync_ValidKey_ShouldReturnBackup_Test() =>
		ExportMasterKeyAsync_ValidKey_ShouldReturnBackup();

	#endregion ExportMasterKeyAsync Tests

	#region ImportMasterKeyAsync Tests

	[Fact]
	public Task ImportMasterKeyAsync_NullBackup_ShouldThrowArgumentNullException_Test() =>
		ImportMasterKeyAsync_NullBackup_ShouldThrowArgumentNullException();

	[Fact]
	public Task ImportMasterKeyAsync_ExpiredBackup_ShouldThrowMasterKeyBackupException_Test() =>
		ImportMasterKeyAsync_ExpiredBackup_ShouldThrowMasterKeyBackupException();

	[Fact]
	public Task ImportMasterKeyAsync_ValidBackup_ShouldSucceed_Test() =>
		ImportMasterKeyAsync_ValidBackup_ShouldSucceed();

	[Fact]
	public Task ImportMasterKeyAsync_KeyExists_ShouldThrowMasterKeyBackupException_Test() =>
		ImportMasterKeyAsync_KeyExists_ShouldThrowMasterKeyBackupException();

	#endregion ImportMasterKeyAsync Tests

	#region GenerateRecoverySplitAsync Tests

	[Fact]
	public Task GenerateRecoverySplitAsync_NullKeyId_ShouldThrowArgumentException_Test() =>
		GenerateRecoverySplitAsync_NullKeyId_ShouldThrowArgumentException();

	[Fact]
	public Task GenerateRecoverySplitAsync_ThresholdLessThan2_ShouldThrowArgumentOutOfRangeException_Test() =>
		GenerateRecoverySplitAsync_ThresholdLessThan2_ShouldThrowArgumentOutOfRangeException();

	[Fact]
	public Task GenerateRecoverySplitAsync_TotalSharesLessThan2_ShouldThrowArgumentOutOfRangeException_Test() =>
		GenerateRecoverySplitAsync_TotalSharesLessThan2_ShouldThrowArgumentOutOfRangeException();

	[Fact]
	public Task GenerateRecoverySplitAsync_ThresholdExceedsTotalShares_ShouldThrowArgumentOutOfRangeException_Test() =>
		GenerateRecoverySplitAsync_ThresholdExceedsTotalShares_ShouldThrowArgumentOutOfRangeException();

	[Fact]
	public Task GenerateRecoverySplitAsync_ValidParams_ShouldGenerateCorrectCount_Test() =>
		GenerateRecoverySplitAsync_ValidParams_ShouldGenerateCorrectCount();

	#endregion GenerateRecoverySplitAsync Tests

	#region ReconstructFromSharesAsync Tests

	[Fact]
	public Task ReconstructFromSharesAsync_NullShares_ShouldThrowArgumentNullException_Test() =>
		ReconstructFromSharesAsync_NullShares_ShouldThrowArgumentNullException();

	[Fact]
	public Task ReconstructFromSharesAsync_EmptyShares_ShouldThrowArgumentException_Test() =>
		ReconstructFromSharesAsync_EmptyShares_ShouldThrowArgumentException();

	[Fact]
	public Task ReconstructFromSharesAsync_InsufficientShares_ShouldThrowMasterKeyBackupException_Test() =>
		ReconstructFromSharesAsync_InsufficientShares_ShouldThrowMasterKeyBackupException();

	[Fact]
	public Task ReconstructFromSharesAsync_ValidShares_ShouldReconstruct_Test() =>
		ReconstructFromSharesAsync_ValidShares_ShouldReconstruct();

	[Fact]
	public Task ReconstructFromSharesAsync_MismatchedShares_ShouldThrowMasterKeyBackupException_Test() =>
		ReconstructFromSharesAsync_MismatchedShares_ShouldThrowMasterKeyBackupException();

	#endregion ReconstructFromSharesAsync Tests

	#region VerifyBackupAsync Tests

	[Fact]
	public Task VerifyBackupAsync_NullBackup_ShouldThrowArgumentNullException_Test() =>
		VerifyBackupAsync_NullBackup_ShouldThrowArgumentNullException();

	[Fact]
	public Task VerifyBackupAsync_ExpiredBackup_ShouldReturnInvalid_Test() =>
		VerifyBackupAsync_ExpiredBackup_ShouldReturnInvalid();

	[Fact]
	public Task VerifyBackupAsync_ValidBackup_ShouldReturnValid_Test() =>
		VerifyBackupAsync_ValidBackup_ShouldReturnValid();

	#endregion VerifyBackupAsync Tests

	#region GetBackupStatusAsync Tests

	[Fact]
	public Task GetBackupStatusAsync_NullKeyId_ShouldThrowArgumentException_Test() =>
		GetBackupStatusAsync_NullKeyId_ShouldThrowArgumentException();

	[Fact]
	public Task GetBackupStatusAsync_NonExistentKey_ShouldReturnNull_Test() =>
		GetBackupStatusAsync_NonExistentKey_ShouldReturnNull();

	[Fact]
	public Task GetBackupStatusAsync_ExistingBackup_ShouldReturnStatus_Test() =>
		GetBackupStatusAsync_ExistingBackup_ShouldReturnStatus();

	#endregion GetBackupStatusAsync Tests
}
