using Microsoft.Extensions.Logging.Abstractions;

namespace Excalibur.Dispatch.Compliance.Tests.Encryption;

[Trait("Category", "Unit")]
[Trait("Component", "Compliance")]
public sealed class InMemoryKeyManagementProviderShould : IDisposable
{
	private readonly InMemoryKeyManagementProvider _sut;

	public InMemoryKeyManagementProviderShould()
	{
		_sut = new InMemoryKeyManagementProvider(
			NullLogger<InMemoryKeyManagementProvider>.Instance);
	}

	[Fact]
	public async Task Auto_generate_default_key_on_first_access()
	{
		// Act
		var key = await _sut.GetActiveKeyAsync(null, CancellationToken.None).ConfigureAwait(false);

		// Assert
		key.ShouldNotBeNull();
		key.KeyId.ShouldBe("default");
		key.Status.ShouldBe(KeyStatus.Active);
		key.Algorithm.ShouldBe(EncryptionAlgorithm.Aes256Gcm);
		key.Version.ShouldBe(1);
	}

	[Fact]
	public async Task Not_auto_generate_default_key_when_disabled()
	{
		// Arrange
		using var sut = new InMemoryKeyManagementProvider(
			NullLogger<InMemoryKeyManagementProvider>.Instance,
			new InMemoryKeyManagementOptions { AutoGenerateDefaultKey = false });

		// Act
		var key = await sut.GetActiveKeyAsync(null, CancellationToken.None).ConfigureAwait(false);

		// Assert
		key.ShouldBeNull();
	}

	[Fact]
	public async Task Get_key_by_id()
	{
		// Arrange - trigger default key generation
		_ = await _sut.GetActiveKeyAsync(null, CancellationToken.None).ConfigureAwait(false);

		// Act
		var key = await _sut.GetKeyAsync("default", CancellationToken.None).ConfigureAwait(false);

		// Assert
		key.ShouldNotBeNull();
		key.KeyId.ShouldBe("default");
		key.Status.ShouldBe(KeyStatus.Active);
	}

	[Fact]
	public async Task Return_null_for_nonexistent_key()
	{
		// Act
		var key = await _sut.GetKeyAsync("nonexistent", CancellationToken.None).ConfigureAwait(false);

		// Assert
		key.ShouldBeNull();
	}

	[Fact]
	public async Task Get_specific_key_version()
	{
		// Arrange - create key
		await _sut.RotateKeyAsync("test-key", EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None)
			.ConfigureAwait(false);

		// Act
		var key = await _sut.GetKeyVersionAsync("test-key", 1, CancellationToken.None).ConfigureAwait(false);

		// Assert
		key.ShouldNotBeNull();
		key.Version.ShouldBe(1);
	}

	[Fact]
	public async Task Return_null_for_nonexistent_key_version()
	{
		// Arrange - create key
		await _sut.RotateKeyAsync("test-key", EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None)
			.ConfigureAwait(false);

		// Act
		var key = await _sut.GetKeyVersionAsync("test-key", 999, CancellationToken.None).ConfigureAwait(false);

		// Assert
		key.ShouldBeNull();
	}

	[Fact]
	public async Task Return_null_for_nonexistent_key_id_when_getting_version()
	{
		// Act
		var key = await _sut.GetKeyVersionAsync("nonexistent", 1, CancellationToken.None).ConfigureAwait(false);

		// Assert
		key.ShouldBeNull();
	}

	[Fact]
	public async Task Rotate_existing_key_creating_new_version()
	{
		// Arrange
		await _sut.RotateKeyAsync("test-key", EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None)
			.ConfigureAwait(false);

		// Act
		var result = await _sut.RotateKeyAsync("test-key", EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None)
			.ConfigureAwait(false);

		// Assert
		result.Success.ShouldBeTrue();
		result.NewKey.ShouldNotBeNull();
		result.NewKey!.Version.ShouldBe(2);
		result.NewKey.Status.ShouldBe(KeyStatus.Active);
		result.PreviousKey.ShouldNotBeNull();
		// PreviousKey snapshot is captured before the status mutation to DecryptOnly
		result.PreviousKey!.Status.ShouldBe(KeyStatus.Active);
	}

	[Fact]
	public async Task Create_new_key_on_rotate_when_key_does_not_exist()
	{
		// Act
		var result = await _sut.RotateKeyAsync("new-key", EncryptionAlgorithm.Aes256Gcm, "encryption", null, CancellationToken.None)
			.ConfigureAwait(false);

		// Assert
		result.Success.ShouldBeTrue();
		result.NewKey.ShouldNotBeNull();
		result.NewKey!.KeyId.ShouldBe("new-key");
		result.NewKey.Version.ShouldBe(1);
		result.NewKey.Purpose.ShouldBe("encryption");
		result.PreviousKey.ShouldBeNull();
	}

	[Fact]
	public async Task Delete_key_marking_versions_as_pending_destruction()
	{
		// Arrange
		await _sut.RotateKeyAsync("test-key", EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None)
			.ConfigureAwait(false);

		// Act
		var deleted = await _sut.DeleteKeyAsync("test-key", 30, CancellationToken.None).ConfigureAwait(false);

		// Assert
		deleted.ShouldBeTrue();
		var key = await _sut.GetKeyAsync("test-key", CancellationToken.None).ConfigureAwait(false);
		key.ShouldNotBeNull();
		key.Status.ShouldBe(KeyStatus.PendingDestruction);
	}

	[Fact]
	public async Task Return_false_when_deleting_nonexistent_key()
	{
		// Act
		var deleted = await _sut.DeleteKeyAsync("nonexistent", 30, CancellationToken.None).ConfigureAwait(false);

		// Assert
		deleted.ShouldBeFalse();
	}

	[Fact]
	public async Task Suspend_key_with_reason()
	{
		// Arrange
		await _sut.RotateKeyAsync("test-key", EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None)
			.ConfigureAwait(false);

		// Act
		var suspended = await _sut.SuspendKeyAsync("test-key", "Security incident", CancellationToken.None)
			.ConfigureAwait(false);

		// Assert
		suspended.ShouldBeTrue();
		var key = await _sut.GetKeyAsync("test-key", CancellationToken.None).ConfigureAwait(false);
		key.ShouldNotBeNull();
		key.Status.ShouldBe(KeyStatus.Suspended);
	}

	[Fact]
	public async Task Return_false_when_suspending_nonexistent_key()
	{
		// Act
		var suspended = await _sut.SuspendKeyAsync("nonexistent", "reason", CancellationToken.None)
			.ConfigureAwait(false);

		// Assert
		suspended.ShouldBeFalse();
	}

	[Fact]
	public async Task Not_suspend_destroyed_versions()
	{
		// Arrange
		await _sut.RotateKeyAsync("test-key", EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None)
			.ConfigureAwait(false);
		_sut.DestroyKeyImmediately("test-key");

		// Cannot suspend a destroyed key since it's been removed
		var result = await _sut.SuspendKeyAsync("test-key", "reason", CancellationToken.None)
			.ConfigureAwait(false);
		result.ShouldBeFalse();
	}

	[Fact]
	public async Task List_keys_with_no_filter()
	{
		// Arrange
		await _sut.RotateKeyAsync("key-1", EncryptionAlgorithm.Aes256Gcm, "purpose-a", null, CancellationToken.None)
			.ConfigureAwait(false);
		await _sut.RotateKeyAsync("key-2", EncryptionAlgorithm.Aes256Gcm, "purpose-b", null, CancellationToken.None)
			.ConfigureAwait(false);

		// Act
		var keys = await _sut.ListKeysAsync(null, null, CancellationToken.None).ConfigureAwait(false);

		// Assert
		keys.Count.ShouldBe(2);
	}

	[Fact]
	public async Task List_keys_filtered_by_purpose()
	{
		// Arrange
		await _sut.RotateKeyAsync("key-1", EncryptionAlgorithm.Aes256Gcm, "encryption", null, CancellationToken.None)
			.ConfigureAwait(false);
		await _sut.RotateKeyAsync("key-2", EncryptionAlgorithm.Aes256Gcm, "signing", null, CancellationToken.None)
			.ConfigureAwait(false);

		// Act
		var keys = await _sut.ListKeysAsync(null, "encryption", CancellationToken.None).ConfigureAwait(false);

		// Assert
		keys.Count.ShouldBe(1);
		keys[0].Purpose.ShouldBe("encryption");
	}

	[Fact]
	public async Task List_keys_filtered_by_status()
	{
		// Arrange
		await _sut.RotateKeyAsync("key-1", EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None)
			.ConfigureAwait(false);
		await _sut.RotateKeyAsync("key-2", EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None)
			.ConfigureAwait(false);
		await _sut.SuspendKeyAsync("key-2", "test", CancellationToken.None).ConfigureAwait(false);

		// Act
		var activeKeys = await _sut.ListKeysAsync(KeyStatus.Active, null, CancellationToken.None).ConfigureAwait(false);
		var suspendedKeys = await _sut.ListKeysAsync(KeyStatus.Suspended, null, CancellationToken.None).ConfigureAwait(false);

		// Assert
		activeKeys.Count.ShouldBe(1);
		suspendedKeys.Count.ShouldBe(1);
	}

	[Fact]
	public async Task Get_active_key_by_purpose()
	{
		// Arrange
		await _sut.RotateKeyAsync("key-1", EncryptionAlgorithm.Aes256Gcm, "encryption", null, CancellationToken.None)
			.ConfigureAwait(false);

		// Act
		var key = await _sut.GetActiveKeyAsync("encryption", CancellationToken.None).ConfigureAwait(false);

		// Assert
		key.ShouldNotBeNull();
		key.KeyId.ShouldBe("key-1");
	}

	[Fact]
	public async Task Return_null_when_no_active_key_for_purpose()
	{
		// Act
		var key = await _sut.GetActiveKeyAsync("nonexistent-purpose", CancellationToken.None).ConfigureAwait(false);

		// Assert
		key.ShouldBeNull();
	}

	[Fact]
	public async Task Provide_key_material_for_valid_key()
	{
		// Arrange
		await _sut.RotateKeyAsync("test-key", EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None)
			.ConfigureAwait(false);

		// Act
		IKeyMaterialProvider materialProvider = _sut;
		var material = await materialProvider.GetKeyMaterialAsync("test-key", 1, CancellationToken.None)
			.ConfigureAwait(false);

		// Assert
		material.ShouldNotBeNull();
		material.Length.ShouldBe(32); // AES-256
	}

	[Fact]
	public async Task Throw_for_key_material_of_nonexistent_key()
	{
		// Act & Assert
		IKeyMaterialProvider materialProvider = _sut;
		await Should.ThrowAsync<EncryptionException>(
			() => materialProvider.GetKeyMaterialAsync("nonexistent", 1, CancellationToken.None))
			.ConfigureAwait(false);
	}

	[Fact]
	public async Task Throw_for_key_material_of_nonexistent_version()
	{
		// Arrange
		await _sut.RotateKeyAsync("test-key", EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None)
			.ConfigureAwait(false);

		// Act & Assert
		IKeyMaterialProvider materialProvider = _sut;
		await Should.ThrowAsync<EncryptionException>(
			() => materialProvider.GetKeyMaterialAsync("test-key", 999, CancellationToken.None))
			.ConfigureAwait(false);
	}

	[Fact]
	public async Task Return_copy_of_key_material()
	{
		// Arrange
		await _sut.RotateKeyAsync("test-key", EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None)
			.ConfigureAwait(false);

		IKeyMaterialProvider materialProvider = _sut;

		// Act
		var material1 = await materialProvider.GetKeyMaterialAsync("test-key", 1, CancellationToken.None)
			.ConfigureAwait(false);
		var material2 = await materialProvider.GetKeyMaterialAsync("test-key", 1, CancellationToken.None)
			.ConfigureAwait(false);

		// Assert - should be equal but not the same reference
		material1.ShouldBe(material2);
		ReferenceEquals(material1, material2).ShouldBeFalse();
	}

	[Fact]
	public async Task Destroy_key_immediately()
	{
		// Arrange
		await _sut.RotateKeyAsync("test-key", EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None)
			.ConfigureAwait(false);

		// Act
		var destroyed = _sut.DestroyKeyImmediately("test-key");

		// Assert
		destroyed.ShouldBeTrue();
	}

	[Fact]
	public void Return_false_when_destroying_nonexistent_key()
	{
		// Act
		var destroyed = _sut.DestroyKeyImmediately("nonexistent");

		// Assert
		destroyed.ShouldBeFalse();
	}

	[Fact]
	public async Task Throw_when_getting_material_of_destroyed_key()
	{
		// Arrange
		await _sut.RotateKeyAsync("test-key", EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None)
			.ConfigureAwait(false);
		_sut.DestroyKeyImmediately("test-key");

		// Act & Assert
		IKeyMaterialProvider materialProvider = _sut;
		await Should.ThrowAsync<EncryptionException>(
			() => materialProvider.GetKeyMaterialAsync("test-key", 1, CancellationToken.None))
			.ConfigureAwait(false);
	}

	[Fact]
	public async Task Rotate_key_with_expiration()
	{
		// Arrange
		var expiresAt = DateTimeOffset.UtcNow.AddDays(90);

		// Act
		var result = await _sut.RotateKeyAsync("test-key", EncryptionAlgorithm.Aes256Gcm, null, expiresAt, CancellationToken.None)
			.ConfigureAwait(false);

		// Assert
		result.Success.ShouldBeTrue();
		result.NewKey.ShouldNotBeNull();
		result.NewKey!.ExpiresAt.ShouldNotBeNull();
	}

	[Fact]
	public async Task Throw_on_disposed_get_key()
	{
		// Arrange
		_sut.Dispose();

		// Act & Assert
		await Should.ThrowAsync<ObjectDisposedException>(
			() => _sut.GetKeyAsync("test", CancellationToken.None)).ConfigureAwait(false);
	}

	[Fact]
	public async Task Throw_on_disposed_rotate_key()
	{
		// Arrange
		_sut.Dispose();

		// Act & Assert
		await Should.ThrowAsync<ObjectDisposedException>(
			() => _sut.RotateKeyAsync("test", EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None))
			.ConfigureAwait(false);
	}

	[Fact]
	public async Task Throw_on_disposed_delete_key()
	{
		// Arrange
		_sut.Dispose();

		// Act & Assert
		await Should.ThrowAsync<ObjectDisposedException>(
			() => _sut.DeleteKeyAsync("test", 30, CancellationToken.None)).ConfigureAwait(false);
	}

	[Fact]
	public async Task Throw_on_disposed_suspend_key()
	{
		// Arrange
		_sut.Dispose();

		// Act & Assert
		await Should.ThrowAsync<ObjectDisposedException>(
			() => _sut.SuspendKeyAsync("test", "reason", CancellationToken.None)).ConfigureAwait(false);
	}

	[Fact]
	public async Task Throw_on_disposed_list_keys()
	{
		// Arrange
		_sut.Dispose();

		// Act & Assert
		await Should.ThrowAsync<ObjectDisposedException>(
			() => _sut.ListKeysAsync(null, null, CancellationToken.None)).ConfigureAwait(false);
	}

	[Fact]
	public async Task Throw_on_disposed_get_active_key()
	{
		// Arrange
		_sut.Dispose();

		// Act & Assert
		await Should.ThrowAsync<ObjectDisposedException>(
			() => _sut.GetActiveKeyAsync(null, CancellationToken.None)).ConfigureAwait(false);
	}

	[Fact]
	public void Throw_on_disposed_destroy_key()
	{
		// Arrange
		_sut.Dispose();

		// Act & Assert
		Should.Throw<ObjectDisposedException>(() => _sut.DestroyKeyImmediately("test"));
	}

	[Fact]
	public async Task Throw_on_null_key_id_for_get_key()
	{
		await Should.ThrowAsync<ArgumentException>(
			() => _sut.GetKeyAsync("", CancellationToken.None)).ConfigureAwait(false);
	}

	[Fact]
	public async Task Throw_on_null_key_id_for_rotate()
	{
		await Should.ThrowAsync<ArgumentException>(
			() => _sut.RotateKeyAsync("", EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None))
			.ConfigureAwait(false);
	}

	[Fact]
	public async Task Throw_on_null_key_id_for_delete()
	{
		await Should.ThrowAsync<ArgumentException>(
			() => _sut.DeleteKeyAsync("", 30, CancellationToken.None)).ConfigureAwait(false);
	}

	[Fact]
	public async Task Throw_on_null_key_id_for_suspend()
	{
		await Should.ThrowAsync<ArgumentException>(
			() => _sut.SuspendKeyAsync("", "reason", CancellationToken.None)).ConfigureAwait(false);
	}

	[Fact]
	public async Task Throw_on_empty_reason_for_suspend()
	{
		await Should.ThrowAsync<ArgumentException>(
			() => _sut.SuspendKeyAsync("test-key", "", CancellationToken.None)).ConfigureAwait(false);
	}

	[Fact]
	public async Task Dispose_clears_key_material()
	{
		// Arrange
		await _sut.RotateKeyAsync("test-key", EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None)
			.ConfigureAwait(false);

		// Act
		_sut.Dispose();

		// Assert - subsequent operations should throw
		Should.Throw<ObjectDisposedException>(() => _sut.DestroyKeyImmediately("test-key"));
	}

	[Fact]
	public void Allow_double_dispose()
	{
		// Act & Assert - should not throw
		_sut.Dispose();
		_sut.Dispose();
	}

	[Fact]
	public void Throw_for_null_logger()
	{
		Should.Throw<ArgumentNullException>(() =>
			new InMemoryKeyManagementProvider(null!));
	}

	[Fact]
	public async Task Use_custom_default_key_id()
	{
		// Arrange
		using var sut = new InMemoryKeyManagementProvider(
			NullLogger<InMemoryKeyManagementProvider>.Instance,
			new InMemoryKeyManagementOptions { DefaultKeyId = "custom-default" });

		// Act
		var key = await sut.GetActiveKeyAsync(null, CancellationToken.None).ConfigureAwait(false);

		// Assert
		key.ShouldNotBeNull();
		key.KeyId.ShouldBe("custom-default");
	}

	public void Dispose()
	{
		_sut.Dispose();
	}
}
