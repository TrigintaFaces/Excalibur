using Microsoft.Extensions.Logging.Abstractions;

namespace Excalibur.Dispatch.Compliance.Tests.Encryption;

[Trait("Category", "Unit")]
[Trait("Component", "Compliance")]
public sealed class AesGcmEncryptionProviderShould : IDisposable
{
	private readonly InMemoryKeyManagementProvider _keyManagement;
	private readonly AesGcmEncryptionProvider _sut;

	public AesGcmEncryptionProviderShould()
	{
		_keyManagement = new InMemoryKeyManagementProvider(
			NullLogger<InMemoryKeyManagementProvider>.Instance);
		_sut = new AesGcmEncryptionProvider(
			_keyManagement,
			NullLogger<AesGcmEncryptionProvider>.Instance);
	}

	[Fact]
	public async Task Encrypt_and_decrypt_round_trip()
	{
		// Arrange
		var plaintext = "Hello, World!"u8.ToArray();
		var context = new EncryptionContext();

		// Act
		var encrypted = await _sut.EncryptAsync(plaintext, context, CancellationToken.None)
			.ConfigureAwait(false);
		var decrypted = await _sut.DecryptAsync(encrypted, context, CancellationToken.None)
			.ConfigureAwait(false);

		// Assert
		decrypted.ShouldBe(plaintext);
	}

	[Fact]
	public async Task Produce_different_ciphertext_for_same_plaintext()
	{
		// Arrange
		var plaintext = "test data"u8.ToArray();
		var context = new EncryptionContext();

		// Act
		var encrypted1 = await _sut.EncryptAsync(plaintext, context, CancellationToken.None)
			.ConfigureAwait(false);
		var encrypted2 = await _sut.EncryptAsync(plaintext, context, CancellationToken.None)
			.ConfigureAwait(false);

		// Assert - different nonces produce different ciphertexts
		encrypted1.Ciphertext.ShouldNotBe(encrypted2.Ciphertext);
		encrypted1.Iv.ShouldNotBe(encrypted2.Iv);
	}

	[Fact]
	public async Task Set_correct_metadata_on_encrypted_data()
	{
		// Arrange
		var plaintext = "metadata test"u8.ToArray();
		var context = new EncryptionContext();

		// Act
		var encrypted = await _sut.EncryptAsync(plaintext, context, CancellationToken.None)
			.ConfigureAwait(false);

		// Assert
		encrypted.Algorithm.ShouldBe(EncryptionAlgorithm.Aes256Gcm);
		encrypted.KeyId.ShouldNotBeNullOrEmpty();
		encrypted.KeyVersion.ShouldBeGreaterThanOrEqualTo(1);
		encrypted.Iv.Length.ShouldBe(12); // GCM nonce
		encrypted.AuthTag.ShouldNotBeNull();
		encrypted.AuthTag!.Length.ShouldBe(16); // 128-bit auth tag
		encrypted.Ciphertext.Length.ShouldBe(plaintext.Length);
	}

	[Fact]
	public async Task Encrypt_with_specific_key_id()
	{
		// Arrange
		await _keyManagement.RotateKeyAsync("custom-key", EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None)
			.ConfigureAwait(false);
		var plaintext = "test"u8.ToArray();
		var context = new EncryptionContext { KeyId = "custom-key" };

		// Act
		var encrypted = await _sut.EncryptAsync(plaintext, context, CancellationToken.None)
			.ConfigureAwait(false);

		// Assert
		encrypted.KeyId.ShouldBe("custom-key");
	}

	[Fact]
	public async Task Encrypt_with_specific_key_version()
	{
		// Arrange
		await _keyManagement.RotateKeyAsync("test-key", EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None)
			.ConfigureAwait(false);
		var plaintext = "test"u8.ToArray();
		var context = new EncryptionContext { KeyId = "test-key", KeyVersion = 1 };

		// Act
		var encrypted = await _sut.EncryptAsync(plaintext, context, CancellationToken.None)
			.ConfigureAwait(false);

		// Assert
		encrypted.KeyVersion.ShouldBe(1);
	}

	[Fact]
	public async Task Throw_when_no_key_found()
	{
		// Arrange
		using var sut = new AesGcmEncryptionProvider(
			_keyManagement,
			NullLogger<AesGcmEncryptionProvider>.Instance);

		// Disable auto-generation
		using var noAutoKeyMgmt = new InMemoryKeyManagementProvider(
			NullLogger<InMemoryKeyManagementProvider>.Instance,
			new InMemoryKeyManagementOptions { AutoGenerateDefaultKey = false });
		using var provider = new AesGcmEncryptionProvider(
			noAutoKeyMgmt,
			NullLogger<AesGcmEncryptionProvider>.Instance);

		var plaintext = "test"u8.ToArray();
		var context = new EncryptionContext();

		// Act & Assert
		var ex = await Should.ThrowAsync<EncryptionException>(
			() => provider.EncryptAsync(plaintext, context, CancellationToken.None))
			.ConfigureAwait(false);
		ex.ErrorCode.ShouldBe(EncryptionErrorCode.KeyNotFound);
	}

	[Fact]
	public async Task Throw_when_decrypting_wrong_algorithm()
	{
		// Arrange
		var encrypted = new EncryptedData
		{
			Algorithm = EncryptionAlgorithm.Aes256CbcHmac,
			Ciphertext = [1, 2, 3],
			Iv = new byte[12],
			AuthTag = new byte[16],
			KeyId = "key-1",
			KeyVersion = 1,
		};
		var context = new EncryptionContext();

		// Act & Assert
		var ex = await Should.ThrowAsync<EncryptionException>(
			() => _sut.DecryptAsync(encrypted, context, CancellationToken.None))
			.ConfigureAwait(false);
		ex.ErrorCode.ShouldBe(EncryptionErrorCode.UnsupportedAlgorithm);
	}

	[Fact]
	public async Task Throw_when_auth_tag_is_invalid_size()
	{
		// Arrange
		var encrypted = new EncryptedData
		{
			Algorithm = EncryptionAlgorithm.Aes256Gcm,
			Ciphertext = [1, 2, 3],
			Iv = new byte[12],
			AuthTag = [1, 2], // Wrong size
			KeyId = "key-1",
			KeyVersion = 1,
		};
		var context = new EncryptionContext();

		// Act & Assert
		var ex = await Should.ThrowAsync<EncryptionException>(
			() => _sut.DecryptAsync(encrypted, context, CancellationToken.None))
			.ConfigureAwait(false);
		ex.ErrorCode.ShouldBe(EncryptionErrorCode.InvalidCiphertext);
	}

	[Fact]
	public async Task Throw_when_nonce_is_invalid_size()
	{
		// Arrange
		var encrypted = new EncryptedData
		{
			Algorithm = EncryptionAlgorithm.Aes256Gcm,
			Ciphertext = [1, 2, 3],
			Iv = new byte[8], // Wrong size (should be 12)
			AuthTag = new byte[16],
			KeyId = "key-1",
			KeyVersion = 1,
		};
		var context = new EncryptionContext();

		// Act & Assert
		var ex = await Should.ThrowAsync<EncryptionException>(
			() => _sut.DecryptAsync(encrypted, context, CancellationToken.None))
			.ConfigureAwait(false);
		ex.ErrorCode.ShouldBe(EncryptionErrorCode.InvalidCiphertext);
	}

	[Fact]
	public async Task Throw_on_encrypt_after_dispose()
	{
		// Arrange
		_sut.Dispose();

		// Act & Assert
		await Should.ThrowAsync<ObjectDisposedException>(
			() => _sut.EncryptAsync([1], new EncryptionContext(), CancellationToken.None))
			.ConfigureAwait(false);
	}

	[Fact]
	public async Task Throw_on_decrypt_after_dispose()
	{
		// Arrange
		_sut.Dispose();
		var encrypted = new EncryptedData
		{
			Algorithm = EncryptionAlgorithm.Aes256Gcm,
			Ciphertext = [1],
			Iv = new byte[12],
			AuthTag = new byte[16],
			KeyId = "key-1",
			KeyVersion = 1,
		};

		// Act & Assert
		await Should.ThrowAsync<ObjectDisposedException>(
			() => _sut.DecryptAsync(encrypted, new EncryptionContext(), CancellationToken.None))
			.ConfigureAwait(false);
	}

	[Fact]
	public async Task Throw_on_fips_validation_after_dispose()
	{
		// Arrange
		_sut.Dispose();

		// Act & Assert
		await Should.ThrowAsync<ObjectDisposedException>(
			() => _sut.ValidateFipsComplianceAsync(CancellationToken.None))
			.ConfigureAwait(false);
	}

	[Fact]
	public async Task Validate_fips_compliance()
	{
		// Act
		var result = await _sut.ValidateFipsComplianceAsync(CancellationToken.None)
			.ConfigureAwait(false);

		// Assert - on non-FIPS systems this will be false
		result.ShouldBeOneOf(true, false);
	}

	[Fact]
	public async Task Throw_on_null_plaintext()
	{
		await Should.ThrowAsync<ArgumentNullException>(
			() => _sut.EncryptAsync(null!, new EncryptionContext(), CancellationToken.None))
			.ConfigureAwait(false);
	}

	[Fact]
	public async Task Throw_on_null_encrypted_data()
	{
		await Should.ThrowAsync<ArgumentNullException>(
			() => _sut.DecryptAsync(null!, new EncryptionContext(), CancellationToken.None))
			.ConfigureAwait(false);
	}

	[Fact]
	public void Throw_for_null_key_management()
	{
		Should.Throw<ArgumentNullException>(() =>
			new AesGcmEncryptionProvider(null!, NullLogger<AesGcmEncryptionProvider>.Instance));
	}

	[Fact]
	public void Throw_for_null_logger()
	{
		Should.Throw<ArgumentNullException>(() =>
			new AesGcmEncryptionProvider(A.Fake<IKeyManagementProvider>(), null!));
	}

	[Fact]
	public void Allow_double_dispose()
	{
		_sut.Dispose();
		_sut.Dispose();
	}

	[Fact]
	public async Task Throw_when_key_not_active_for_encryption()
	{
		// Arrange
		await _keyManagement.RotateKeyAsync("test-key", EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None)
			.ConfigureAwait(false);
		await _keyManagement.SuspendKeyAsync("test-key", "test", CancellationToken.None)
			.ConfigureAwait(false);

		var context = new EncryptionContext { KeyId = "test-key" };

		// Act & Assert
		var ex = await Should.ThrowAsync<EncryptionException>(
			() => _sut.EncryptAsync([1, 2, 3], context, CancellationToken.None))
			.ConfigureAwait(false);
		ex.ErrorCode.ShouldBe(EncryptionErrorCode.KeySuspended);
	}

	[Fact]
	public async Task Throw_when_key_material_unavailable()
	{
		// Arrange - use fake that doesn't implement IKeyMaterialProvider
		var fakeKeyMgmt = A.Fake<IKeyManagementProvider>();
		A.CallTo(() => fakeKeyMgmt.GetActiveKeyAsync(A<string?>._, A<CancellationToken>._))
			.Returns(Task.FromResult<KeyMetadata?>(new KeyMetadata
			{
				KeyId = "k1",
				Version = 1,
				Status = KeyStatus.Active,
				Algorithm = EncryptionAlgorithm.Aes256Gcm,
				CreatedAt = DateTimeOffset.UtcNow,
			}));

		using var provider = new AesGcmEncryptionProvider(
			fakeKeyMgmt,
			NullLogger<AesGcmEncryptionProvider>.Instance);

		// Act & Assert
		var ex = await Should.ThrowAsync<EncryptionException>(
			() => provider.EncryptAsync([1], new EncryptionContext(), CancellationToken.None))
			.ConfigureAwait(false);
		ex.ErrorCode.ShouldBe(EncryptionErrorCode.ServiceUnavailable);
	}

	[Fact]
	public async Task Include_tenant_id_in_aad()
	{
		// Arrange
		var plaintext = "tenant test"u8.ToArray();
		var context = new EncryptionContext { TenantId = "tenant-1" };

		// Act
		var encrypted = await _sut.EncryptAsync(plaintext, context, CancellationToken.None)
			.ConfigureAwait(false);
		encrypted.TenantId.ShouldBe("tenant-1");

		// Decrypt with same tenant context
		var decrypted = await _sut.DecryptAsync(encrypted, context, CancellationToken.None)
			.ConfigureAwait(false);
		decrypted.ShouldBe(plaintext);
	}

	[Fact]
	public async Task Fail_decrypt_with_wrong_tenant_context()
	{
		// Arrange
		var plaintext = "tenant test"u8.ToArray();
		var encryptContext = new EncryptionContext { TenantId = "tenant-1" };
		var decryptContext = new EncryptionContext { TenantId = "wrong-tenant" };

		// Act
		var encrypted = await _sut.EncryptAsync(plaintext, encryptContext, CancellationToken.None)
			.ConfigureAwait(false);

		// Assert - decryption with wrong AAD should fail
		await Should.ThrowAsync<EncryptionException>(
			() => _sut.DecryptAsync(encrypted, decryptContext, CancellationToken.None))
			.ConfigureAwait(false);
	}

	public void Dispose()
	{
		_sut.Dispose();
		_keyManagement.Dispose();
	}
}
