// SPDX-FileCopyrightText: Copyright (c) 2026 The Excalibur Project
// SPDX-License-Identifier: LicenseRef-Excalibur-1.0 OR AGPL-3.0-or-later OR SSPL-1.0 OR Apache-2.0

using Microsoft.Extensions.Logging.Abstractions;

namespace Excalibur.Dispatch.Security.Tests.Compliance.Encryption;

/// <summary>
/// Unit tests for <see cref="InMemoryKeyManagementProvider"/>.
/// </summary>
[Trait("Category", TestCategories.Unit)]
public sealed class InMemoryKeyManagementProviderShould : IDisposable
{
	private readonly InMemoryKeyManagementProvider _sut;

	public InMemoryKeyManagementProviderShould()
	{
		_sut = new InMemoryKeyManagementProvider(
			NullLogger<InMemoryKeyManagementProvider>.Instance,
			new InMemoryKeyManagementOptions { AutoGenerateDefaultKey = false });
	}

	public void Dispose() => _sut.Dispose();

	#region RotateKeyAsync Tests

	[Fact]
	public async Task RotateKeyAsync_CreatesNewKey_WhenKeyDoesNotExist()
	{
		// Arrange
		const string keyId = "new-key";

		// Act
		var result = await _sut.RotateKeyAsync(keyId, EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None);

		// Assert
		_ = result.ShouldNotBeNull();
		result.Success.ShouldBeTrue();
		_ = result.NewKey.ShouldNotBeNull();
		result.NewKey.KeyId.ShouldBe(keyId);
		result.NewKey.Version.ShouldBe(1);
		result.NewKey.Status.ShouldBe(KeyStatus.Active);
		result.NewKey.Algorithm.ShouldBe(EncryptionAlgorithm.Aes256Gcm);
		result.PreviousKey.ShouldBeNull();
	}

	[Fact]
	public async Task RotateKeyAsync_IncrementsVersion_WhenKeyExists()
	{
		// Arrange
		const string keyId = "existing-key";
		_ = await _sut.RotateKeyAsync(keyId, EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None);

		// Act
		var result = await _sut.RotateKeyAsync(keyId, EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None);

		// Assert
		result.Success.ShouldBeTrue();
		result.NewKey.Version.ShouldBe(2);
		_ = result.PreviousKey.ShouldNotBeNull();
		result.PreviousKey.Version.ShouldBe(1);
		// PreviousKey captures status before rotation
		result.PreviousKey.Status.ShouldBe(KeyStatus.Active);

		// After rotation, the old version should be DecryptOnly in the store
		var v1 = await _sut.GetKeyVersionAsync(keyId, 1, CancellationToken.None);
		v1.Status.ShouldBe(KeyStatus.DecryptOnly);
	}

	[Fact]
	public async Task RotateKeyAsync_SetsPurpose_WhenProvided()
	{
		// Arrange
		const string keyId = "purpose-key";
		const string purpose = "field-encryption";

		// Act
		var result = await _sut.RotateKeyAsync(keyId, EncryptionAlgorithm.Aes256Gcm, purpose, null, CancellationToken.None);

		// Assert
		result.NewKey.Purpose.ShouldBe(purpose);
	}

	[Fact]
	public async Task RotateKeyAsync_SetsExpiration_WhenProvided()
	{
		// Arrange
		const string keyId = "expiring-key";
		var expiresAt = DateTimeOffset.UtcNow.AddDays(90);

		// Act
		var result = await _sut.RotateKeyAsync(keyId, EncryptionAlgorithm.Aes256Gcm, null, expiresAt, CancellationToken.None);

		// Assert
		_ = result.NewKey.ExpiresAt.ShouldNotBeNull();
		result.NewKey.ExpiresAt.Value.ShouldBe(expiresAt, TimeSpan.FromSeconds(1));
	}

	[Fact]
	public async Task RotateKeyAsync_WithEmptyKeyId_ThrowsArgumentException()
	{
		// Act & Assert
		_ = await Should.ThrowAsync<ArgumentException>(() => _sut.RotateKeyAsync(string.Empty, EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None));
	}

	#endregion RotateKeyAsync Tests

	#region GetKeyAsync Tests

	[Fact]
	public async Task GetKeyAsync_ReturnsLatestVersion()
	{
		// Arrange
		const string keyId = "multi-version-key";
		_ = await _sut.RotateKeyAsync(keyId, EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None);
		_ = await _sut.RotateKeyAsync(keyId, EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None);
		_ = await _sut.RotateKeyAsync(keyId, EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None);

		// Act
		var result = await _sut.GetKeyAsync(keyId, CancellationToken.None);

		// Assert
		_ = result.ShouldNotBeNull();
		result.Version.ShouldBe(3);
	}

	[Fact]
	public async Task GetKeyAsync_ReturnsNull_WhenKeyNotFound()
	{
		// Act
		var result = await _sut.GetKeyAsync("nonexistent-key", CancellationToken.None);

		// Assert
		result.ShouldBeNull();
	}

	[Fact]
	public async Task GetKeyAsync_WithEmptyKeyId_ThrowsArgumentException()
	{
		// Act & Assert
		_ = await Should.ThrowAsync<ArgumentException>(() => _sut.GetKeyAsync(string.Empty, CancellationToken.None));
	}

	#endregion GetKeyAsync Tests

	#region GetKeyVersionAsync Tests

	[Fact]
	public async Task GetKeyVersionAsync_ReturnsSpecificVersion()
	{
		// Arrange
		const string keyId = "versioned-key";
		_ = await _sut.RotateKeyAsync(keyId, EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None);
		_ = await _sut.RotateKeyAsync(keyId, EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None);

		// Act
		var v1 = await _sut.GetKeyVersionAsync(keyId, 1, CancellationToken.None);
		var v2 = await _sut.GetKeyVersionAsync(keyId, 2, CancellationToken.None);

		// Assert
		_ = v1.ShouldNotBeNull();
		v1.Version.ShouldBe(1);
		v1.Status.ShouldBe(KeyStatus.DecryptOnly);

		_ = v2.ShouldNotBeNull();
		v2.Version.ShouldBe(2);
		v2.Status.ShouldBe(KeyStatus.Active);
	}

	[Fact]
	public async Task GetKeyVersionAsync_ReturnsNull_WhenVersionNotFound()
	{
		// Arrange
		const string keyId = "single-version-key";
		_ = await _sut.RotateKeyAsync(keyId, EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None);

		// Act
		var result = await _sut.GetKeyVersionAsync(keyId, 99, CancellationToken.None);

		// Assert
		result.ShouldBeNull();
	}

	#endregion GetKeyVersionAsync Tests

	#region GetActiveKeyAsync Tests

	[Fact]
	public async Task GetActiveKeyAsync_ReturnsActiveKey()
	{
		// Arrange
		const string keyId = "active-key";
		_ = await _sut.RotateKeyAsync(keyId, EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None);

		// Act
		var result = await _sut.GetActiveKeyAsync(null, CancellationToken.None);

		// Assert
		_ = result.ShouldNotBeNull();
		result.Status.ShouldBe(KeyStatus.Active);
	}

	[Fact]
	public async Task GetActiveKeyAsync_FiltersByPurpose()
	{
		// Arrange
		_ = await _sut.RotateKeyAsync("key1", EncryptionAlgorithm.Aes256Gcm, "purpose-A", null, CancellationToken.None);
		_ = await _sut.RotateKeyAsync("key2", EncryptionAlgorithm.Aes256Gcm, "purpose-B", null, CancellationToken.None);

		// Act
		var result = await _sut.GetActiveKeyAsync("purpose-B", cancellationToken: CancellationToken.None);

		// Assert
		_ = result.ShouldNotBeNull();
		result.KeyId.ShouldBe("key2");
		result.Purpose.ShouldBe("purpose-B");
	}

	[Fact]
	public async Task GetActiveKeyAsync_ReturnsNull_WhenNoActiveKey()
	{
		// Arrange - no keys created
		using var sut = new InMemoryKeyManagementProvider(
			NullLogger<InMemoryKeyManagementProvider>.Instance,
			new InMemoryKeyManagementOptions { AutoGenerateDefaultKey = false });

		// Act
		var result = await sut.GetActiveKeyAsync("nonexistent-purpose", CancellationToken.None);

		// Assert
		result.ShouldBeNull();
	}

	[Fact]
	public async Task GetActiveKeyAsync_SkipsExpiredKeys()
	{
		// Arrange - create key that expires immediately
		const string keyId = "expired-key";
		_ = await _sut.RotateKeyAsync(keyId, EncryptionAlgorithm.Aes256Gcm, null, DateTimeOffset.UtcNow.AddMilliseconds(-1), CancellationToken.None);

		// Act
		var result = await _sut.GetActiveKeyAsync(null, cancellationToken: CancellationToken.None);

		// Assert - expired key should not be returned
		result.ShouldBeNull();
	}

	#endregion GetActiveKeyAsync Tests

	#region ListKeysAsync Tests

	[Fact]
	public async Task ListKeysAsync_ReturnsAllKeys()
	{
		// Arrange
		_ = await _sut.RotateKeyAsync("key1", EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None);
		_ = await _sut.RotateKeyAsync("key2", EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None);
		_ = await _sut.RotateKeyAsync("key3", EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None);

		// Act
		var result = await _sut.ListKeysAsync(null, null, CancellationToken.None);

		// Assert
		result.Count.ShouldBe(3);
	}

	[Fact]
	public async Task ListKeysAsync_FiltersByStatus()
	{
		// Arrange
		_ = await _sut.RotateKeyAsync("key1", EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None);
		_ = await _sut.RotateKeyAsync("key1", EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None); // v1 becomes DecryptOnly
		_ = await _sut.RotateKeyAsync("key2", EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None);

		// Act
		var activeKeys = await _sut.ListKeysAsync(status: KeyStatus.Active, null, CancellationToken.None);

		// Assert - should only return latest version of each key
		activeKeys.Count.ShouldBe(2);
		activeKeys.ShouldAllBe(k => k.Status == KeyStatus.Active);
	}

	[Fact]
	public async Task ListKeysAsync_FiltersByPurpose()
	{
		// Arrange
		_ = await _sut.RotateKeyAsync("key1", EncryptionAlgorithm.Aes256Gcm, "purpose-X", null, CancellationToken.None);
		_ = await _sut.RotateKeyAsync("key2", EncryptionAlgorithm.Aes256Gcm, "purpose-Y", null, CancellationToken.None);
		_ = await _sut.RotateKeyAsync("key3", EncryptionAlgorithm.Aes256Gcm, "purpose-X", null, CancellationToken.None);

		// Act
		var result = await _sut.ListKeysAsync(null, "purpose-X", CancellationToken.None);

		// Assert
		result.Count.ShouldBe(2);
		result.ShouldAllBe(k => k.Purpose == "purpose-X");
	}

	#endregion ListKeysAsync Tests

	#region DeleteKeyAsync Tests

	[Fact]
	public async Task DeleteKeyAsync_MarksKeyAsPendingDestruction()
	{
		// Arrange
		const string keyId = "delete-me";
		_ = await _sut.RotateKeyAsync(keyId, EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None);

		// Act
		var result = await _sut.DeleteKeyAsync(keyId, retentionDays: 30, CancellationToken.None);

		// Assert
		result.ShouldBeTrue();

		var key = await _sut.GetKeyAsync(keyId, CancellationToken.None);
		_ = key.ShouldNotBeNull();
		key.Status.ShouldBe(KeyStatus.PendingDestruction);
	}

	[Fact]
	public async Task DeleteKeyAsync_ReturnsFalse_WhenKeyNotFound()
	{
		// Act
		var result = await _sut.DeleteKeyAsync("nonexistent", 30, CancellationToken.None);

		// Assert
		result.ShouldBeFalse();
	}

	#endregion DeleteKeyAsync Tests

	#region SuspendKeyAsync Tests

	[Fact]
	public async Task SuspendKeyAsync_SuspendsAllVersions()
	{
		// Arrange
		const string keyId = "suspend-me";
		_ = await _sut.RotateKeyAsync(keyId, EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None);
		_ = await _sut.RotateKeyAsync(keyId, EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None);

		// Act
		var result = await _sut.SuspendKeyAsync(keyId, "Security incident", CancellationToken.None);

		// Assert
		result.ShouldBeTrue();

		var v1 = await _sut.GetKeyVersionAsync(keyId, 1, CancellationToken.None);
		var v2 = await _sut.GetKeyVersionAsync(keyId, 2, CancellationToken.None);

		v1.Status.ShouldBe(KeyStatus.Suspended);
		v2.Status.ShouldBe(KeyStatus.Suspended);
	}

	[Fact]
	public async Task SuspendKeyAsync_ReturnsFalse_WhenKeyNotFound()
	{
		// Act
		var result = await _sut.SuspendKeyAsync("nonexistent", "reason", CancellationToken.None);

		// Assert
		result.ShouldBeFalse();
	}

	[Fact]
	public async Task SuspendKeyAsync_WithEmptyReason_ThrowsArgumentException()
	{
		// Arrange
		_ = await _sut.RotateKeyAsync("key", EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None);

		// Act & Assert
		_ = await Should.ThrowAsync<ArgumentException>(() => _sut.SuspendKeyAsync("key", string.Empty, CancellationToken.None));
	}

	#endregion SuspendKeyAsync Tests

	#region DestroyKeyImmediately Tests

	[Fact]
	public async Task DestroyKeyImmediately_RemovesKeyCompletely()
	{
		// Arrange
		const string keyId = "destroy-me";
		_ = await _sut.RotateKeyAsync(keyId, EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None);

		// Act
		var result = _sut.DestroyKeyImmediately(keyId);

		// Assert
		result.ShouldBeTrue();
		var key = await _sut.GetKeyAsync(keyId, CancellationToken.None);
		key.ShouldBeNull();
	}

	[Fact]
	public void DestroyKeyImmediately_ReturnsFalse_WhenKeyNotFound()
	{
		// Act
		var result = _sut.DestroyKeyImmediately("nonexistent");

		// Assert
		result.ShouldBeFalse();
	}

	#endregion DestroyKeyImmediately Tests

	#region AutoGenerateDefaultKey Tests

	[Fact]
	public async Task Constructor_WithAutoGenerate_CreatesDefaultKey()
	{
		// Arrange & Act
		using var sut = new InMemoryKeyManagementProvider(
			NullLogger<InMemoryKeyManagementProvider>.Instance,
			new InMemoryKeyManagementOptions { AutoGenerateDefaultKey = true, DefaultKeyId = "auto-default" });

		// Assert
		var key = await sut.GetKeyAsync("auto-default", CancellationToken.None);
		_ = key.ShouldNotBeNull();
		key.Status.ShouldBe(KeyStatus.Active);
	}

	#endregion AutoGenerateDefaultKey Tests

	#region Dispose Tests

	[Fact]
	public async Task Dispose_ClearsAllKeyMaterial()
	{
		// Arrange
		const string keyId = "dispose-test";
		_ = await _sut.RotateKeyAsync(keyId, EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None);

		// Act
		_sut.Dispose();

		// Assert - should throw ObjectDisposedException
		_ = await Should.ThrowAsync<ObjectDisposedException>(() => _sut.GetKeyAsync(keyId, CancellationToken.None));
	}

	[Fact]
	public void Dispose_CanBeCalledMultipleTimes()
	{
		// Act & Assert - should not throw
		_sut.Dispose();
		_sut.Dispose();
	}

	#endregion Dispose Tests
}
