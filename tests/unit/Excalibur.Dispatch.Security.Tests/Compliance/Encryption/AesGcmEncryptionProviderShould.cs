// SPDX-FileCopyrightText: Copyright (c) 2026 The Excalibur Project
// SPDX-License-Identifier: LicenseRef-Excalibur-1.0 OR AGPL-3.0-or-later OR SSPL-1.0 OR Apache-2.0

using System.Security.Cryptography;
using System.Text;

using Microsoft.Extensions.Logging.Abstractions;

namespace Excalibur.Dispatch.Security.Tests.Compliance.Encryption;

/// <summary>
/// Unit tests for <see cref="AesGcmEncryptionProvider"/>.
/// </summary>
[Trait("Category", TestCategories.Unit)]
public sealed class AesGcmEncryptionProviderShould : IDisposable
{
	private readonly InMemoryKeyManagementProvider _keyManagement;
	private readonly AesGcmEncryptionProvider _sut;

	public AesGcmEncryptionProviderShould()
	{
		_keyManagement = new InMemoryKeyManagementProvider(
			NullLogger<InMemoryKeyManagementProvider>.Instance,
			new InMemoryKeyManagementOptions { AutoGenerateDefaultKey = true });

		_sut = new AesGcmEncryptionProvider(
			_keyManagement,
			NullLogger<AesGcmEncryptionProvider>.Instance);
	}

	public void Dispose()
	{
		_sut.Dispose();
		_keyManagement.Dispose();
	}

	#region EncryptAsync Tests

	[Fact]
	public async Task EncryptAsync_WithValidPlaintext_ReturnsEncryptedData()
	{
		// Arrange
		var plaintext = "Hello, World!"u8.ToArray();
		var context = EncryptionContext.Default;

		// Act
		var result = await _sut.EncryptAsync(plaintext, context, CancellationToken.None);

		// Assert
		_ = result.ShouldNotBeNull();
		result.Ciphertext.ShouldNotBeEmpty();
		result.Ciphertext.Length.ShouldBe(plaintext.Length);
		result.KeyId.ShouldNotBeNullOrEmpty();
		result.KeyVersion.ShouldBeGreaterThan(0);
		result.Algorithm.ShouldBe(EncryptionAlgorithm.Aes256Gcm);
		result.Iv.Length.ShouldBe(12); // 96-bit nonce
		_ = result.AuthTag.ShouldNotBeNull();
		result.AuthTag.Length.ShouldBe(16); // 128-bit tag
	}

	[Fact]
	public async Task EncryptAsync_WithEmptyPlaintext_SucceedsWithEmptyCiphertext()
	{
		// Arrange
		var plaintext = Array.Empty<byte>();
		var context = EncryptionContext.Default;

		// Act
		var result = await _sut.EncryptAsync(plaintext, context, CancellationToken.None);

		// Assert
		result.Ciphertext.ShouldBeEmpty();
		_ = result.AuthTag.ShouldNotBeNull();
	}

	[Fact]
	public async Task EncryptAsync_WithNullPlaintext_ThrowsArgumentNullException()
	{
		// Arrange
		byte[] plaintext = null!;
		var context = EncryptionContext.Default;

		// Act & Assert
		_ = await Should.ThrowAsync<ArgumentNullException>(() => _sut.EncryptAsync(plaintext, context, CancellationToken.None));
	}

	[Fact]
	public async Task EncryptAsync_ProducesUniqueCiphertextForSameInput()
	{
		// Arrange - nonce should be unique per encryption
		var plaintext = "Same input twice"u8.ToArray();
		var context = EncryptionContext.Default;

		// Act
		var result1 = await _sut.EncryptAsync(plaintext, context, CancellationToken.None);
		var result2 = await _sut.EncryptAsync(plaintext, context, CancellationToken.None);

		// Assert - different IVs and ciphertexts due to random nonce
		result1.Iv.ShouldNotBe(result2.Iv);
		result1.Ciphertext.ShouldNotBe(result2.Ciphertext);
	}

	[Fact]
	public async Task EncryptAsync_WithTenantId_IncludesTenantInMetadata()
	{
		// Arrange
		var plaintext = "Tenant data"u8.ToArray();
		var context = EncryptionContext.ForTenant("tenant-123");

		// Act
		var result = await _sut.EncryptAsync(plaintext, context, CancellationToken.None);

		// Assert
		result.TenantId.ShouldBe("tenant-123");
	}

	[Fact]
	public async Task EncryptAsync_WhenDisposed_ThrowsObjectDisposedException()
	{
		// Arrange
		var plaintext = "Test"u8.ToArray();
		_sut.Dispose();

		// Act & Assert
		_ = await Should.ThrowAsync<ObjectDisposedException>(() => _sut.EncryptAsync(plaintext, EncryptionContext.Default, CancellationToken.None));
	}

	[Fact]
	public async Task EncryptAsync_WithFipsRequired_AndFipsCompliantKey_Succeeds()
	{
		// Arrange - The InMemory provider reflects system FIPS mode
		// On non-FIPS systems, keys are not marked FIPS compliant, so we test
		// that encryption works when FIPS is NOT required
		var plaintext = "Test"u8.ToArray();
		var context = new EncryptionContext { RequireFipsCompliance = false };

		// Act
		var result = await _sut.EncryptAsync(plaintext, context, CancellationToken.None);

		// Assert
		_ = result.ShouldNotBeNull();
		result.Ciphertext.ShouldNotBeEmpty();
	}

	#endregion EncryptAsync Tests

	#region DecryptAsync Tests

	[Fact]
	public async Task DecryptAsync_WithValidEncryptedData_ReturnsOriginalPlaintext()
	{
		// Arrange
		var originalPlaintext = "Hello, World!"u8.ToArray();
		var context = EncryptionContext.Default;
		var encryptedData = await _sut.EncryptAsync(originalPlaintext, context, CancellationToken.None);

		// Act
		var decryptedPlaintext = await _sut.DecryptAsync(encryptedData, context, CancellationToken.None);

		// Assert
		decryptedPlaintext.ShouldBe(originalPlaintext);
	}

	[Fact]
	public async Task DecryptAsync_WithEmptyCiphertext_ReturnsEmptyPlaintext()
	{
		// Arrange
		var originalPlaintext = Array.Empty<byte>();
		var context = EncryptionContext.Default;
		var encryptedData = await _sut.EncryptAsync(originalPlaintext, context, CancellationToken.None);

		// Act
		var decryptedPlaintext = await _sut.DecryptAsync(encryptedData, context, CancellationToken.None);

		// Assert
		decryptedPlaintext.ShouldBeEmpty();
	}

	[Fact]
	public async Task DecryptAsync_WithLargeData_SuccessfullyRoundTrips()
	{
		// Arrange - 1 MB of random data
		var originalPlaintext = new byte[1024 * 1024];
		RandomNumberGenerator.Fill(originalPlaintext);
		var context = EncryptionContext.Default;

		// Act
		var encryptedData = await _sut.EncryptAsync(originalPlaintext, context, CancellationToken.None);
		var decryptedPlaintext = await _sut.DecryptAsync(encryptedData, context, CancellationToken.None);

		// Assert
		decryptedPlaintext.ShouldBe(originalPlaintext);
	}

	[Fact]
	public async Task DecryptAsync_WithTamperedCiphertext_ThrowsEncryptionException()
	{
		// Arrange
		var plaintext = "Original data"u8.ToArray();
		var context = EncryptionContext.Default;
		var encryptedData = await _sut.EncryptAsync(plaintext, context, CancellationToken.None);

		// Tamper with ciphertext
		var tamperedCiphertext = encryptedData.Ciphertext.ToArray();
		tamperedCiphertext[0] ^= 0xFF;

		var tamperedData = encryptedData with { Ciphertext = tamperedCiphertext };

		// Act & Assert
		var ex = await Should.ThrowAsync<EncryptionException>(() => _sut.DecryptAsync(tamperedData, context, CancellationToken.None));
		ex.ErrorCode.ShouldBe(EncryptionErrorCode.AuthenticationFailed);
	}

	[Fact]
	public async Task DecryptAsync_WithTamperedAuthTag_ThrowsEncryptionException()
	{
		// Arrange
		var plaintext = "Original data"u8.ToArray();
		var context = EncryptionContext.Default;
		var encryptedData = await _sut.EncryptAsync(plaintext, context, CancellationToken.None);

		// Tamper with auth tag
		var tamperedTag = encryptedData.AuthTag.ToArray();
		tamperedTag[0] ^= 0xFF;

		var tamperedData = encryptedData with { AuthTag = tamperedTag };

		// Act & Assert
		var ex = await Should.ThrowAsync<EncryptionException>(() => _sut.DecryptAsync(tamperedData, context, CancellationToken.None));
		ex.ErrorCode.ShouldBe(EncryptionErrorCode.AuthenticationFailed);
	}

	[Fact]
	public async Task DecryptAsync_WithWrongTenantContext_ThrowsEncryptionException()
	{
		// Arrange - AAD includes tenant ID
		var plaintext = "Tenant-specific data"u8.ToArray();
		var encryptContext = EncryptionContext.ForTenant("tenant-A");
		var decryptContext = EncryptionContext.ForTenant("tenant-B");

		var encryptedData = await _sut.EncryptAsync(plaintext, encryptContext, CancellationToken.None);

		// Act & Assert - Different tenant causes AAD mismatch
		var ex = await Should.ThrowAsync<EncryptionException>(() => _sut.DecryptAsync(encryptedData, decryptContext, CancellationToken.None));
		ex.ErrorCode.ShouldBe(EncryptionErrorCode.AuthenticationFailed);
	}

	[Fact]
	public async Task DecryptAsync_WithInvalidNonceSize_ThrowsEncryptionException()
	{
		// Arrange
		var plaintext = "Test"u8.ToArray();
		var encryptedData = await _sut.EncryptAsync(plaintext, EncryptionContext.Default, CancellationToken.None);

		// Create data with wrong nonce size
		var invalidData = encryptedData with { Iv = new byte[8] }; // Should be 12

		// Act & Assert
		var ex = await Should.ThrowAsync<EncryptionException>(() => _sut.DecryptAsync(invalidData, EncryptionContext.Default, CancellationToken.None));
		ex.ErrorCode.ShouldBe(EncryptionErrorCode.InvalidCiphertext);
	}

	[Fact]
	public async Task DecryptAsync_WithMissingAuthTag_ThrowsEncryptionException()
	{
		// Arrange
		var plaintext = "Test"u8.ToArray();
		var encryptedData = await _sut.EncryptAsync(plaintext, EncryptionContext.Default, CancellationToken.None);

		// Create data without auth tag
		var invalidData = encryptedData with { AuthTag = null };

		// Act & Assert
		var ex = await Should.ThrowAsync<EncryptionException>(() => _sut.DecryptAsync(invalidData, EncryptionContext.Default, CancellationToken.None));
		ex.ErrorCode.ShouldBe(EncryptionErrorCode.InvalidCiphertext);
	}

	[Fact]
	public async Task DecryptAsync_WithWrongAlgorithm_ThrowsEncryptionException()
	{
		// Arrange
		var plaintext = "Test"u8.ToArray();
		var encryptedData = await _sut.EncryptAsync(plaintext, EncryptionContext.Default, CancellationToken.None);

		// Create data with unknown algorithm value
		var invalidData = encryptedData with { Algorithm = (EncryptionAlgorithm)99 };

		// Act & Assert
		var ex = await Should.ThrowAsync<EncryptionException>(() => _sut.DecryptAsync(invalidData, EncryptionContext.Default, CancellationToken.None));
		ex.ErrorCode.ShouldBe(EncryptionErrorCode.UnsupportedAlgorithm);
	}

	[Fact]
	public async Task DecryptAsync_WithNullEncryptedData_ThrowsArgumentNullException()
	{
		// Arrange
		EncryptedData encryptedData = null!;

		// Act & Assert
		_ = await Should.ThrowAsync<ArgumentNullException>(() => _sut.DecryptAsync(encryptedData, EncryptionContext.Default, CancellationToken.None));
	}

	#endregion DecryptAsync Tests

	#region ValidateFipsComplianceAsync Tests

	[Fact]
	public async Task ValidateFipsComplianceAsync_ReturnsBoolean()
	{
		// Act
		var result = await _sut.ValidateFipsComplianceAsync(CancellationToken.None);

		// Assert - The result depends on system FIPS mode, but should not throw
		result.ShouldBeOneOf(true, false);
	}

	[Fact]
	public async Task ValidateFipsComplianceAsync_WhenDisposed_ThrowsObjectDisposedException()
	{
		// Arrange
		_sut.Dispose();

		// Act & Assert
		_ = await Should.ThrowAsync<ObjectDisposedException>(() => _sut.ValidateFipsComplianceAsync(CancellationToken.None));
	}

	#endregion ValidateFipsComplianceAsync Tests

	#region Key Resolution Tests

	[Fact]
	public async Task EncryptAsync_WithSpecificKeyId_UsesRequestedKey()
	{
		// Arrange
		const string specificKeyId = "my-specific-key";
		_ = await _keyManagement.RotateKeyAsync(specificKeyId, EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None);

		var plaintext = "Test"u8.ToArray();
		var context = new EncryptionContext { KeyId = specificKeyId };

		// Act
		var result = await _sut.EncryptAsync(plaintext, context, CancellationToken.None);

		// Assert
		result.KeyId.ShouldBe(specificKeyId);
	}

	[Fact]
	public async Task DecryptAsync_WithSuspendedKey_ThrowsEncryptionException()
	{
		// Arrange
		const string keyId = "suspended-key";
		_ = await _keyManagement.RotateKeyAsync(keyId, EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None);

		var plaintext = "Test"u8.ToArray();
		var context = new EncryptionContext { KeyId = keyId };
		var encryptedData = await _sut.EncryptAsync(plaintext, context, CancellationToken.None);

		// Suspend the key
		_ = await _keyManagement.SuspendKeyAsync(keyId, "Security incident", CancellationToken.None);

		// Act & Assert
		var ex = await Should.ThrowAsync<EncryptionException>(() => _sut.DecryptAsync(encryptedData, context, CancellationToken.None));
		ex.ErrorCode.ShouldBe(EncryptionErrorCode.KeySuspended);
	}

	[Fact]
	public async Task EncryptAsync_WithNoActiveKey_ThrowsEncryptionException()
	{
		// Arrange - dispose to clear keys, create new provider without auto-generate
		_keyManagement.Dispose();

		using var emptyKeyManagement = new InMemoryKeyManagementProvider(
			NullLogger<InMemoryKeyManagementProvider>.Instance,
			new InMemoryKeyManagementOptions { AutoGenerateDefaultKey = false });

		using var sut = new AesGcmEncryptionProvider(
			emptyKeyManagement,
			NullLogger<AesGcmEncryptionProvider>.Instance);

		var plaintext = "Test"u8.ToArray();

		// Act & Assert
		var ex = await Should.ThrowAsync<EncryptionException>(() => sut.EncryptAsync(plaintext, EncryptionContext.Default, CancellationToken.None));
		ex.ErrorCode.ShouldBe(EncryptionErrorCode.KeyNotFound);
	}

	#endregion Key Resolution Tests

	#region AAD (Associated Authenticated Data) Tests

	[Fact]
	public async Task EncryptDecrypt_WithAssociatedData_BindsCiphertextToAAD()
	{
		// Arrange
		var plaintext = "Sensitive data"u8.ToArray();
		var aad = "metadata-binding"u8.ToArray();
		var context = new EncryptionContext { AssociatedData = aad };

		// Act
		var encryptedData = await _sut.EncryptAsync(plaintext, context, CancellationToken.None);
		var decrypted = await _sut.DecryptAsync(encryptedData, context, CancellationToken.None);

		// Assert
		decrypted.ShouldBe(plaintext);
	}

	[Fact]
	public async Task DecryptAsync_WithDifferentAssociatedData_ThrowsEncryptionException()
	{
		// Arrange
		var plaintext = "Sensitive data"u8.ToArray();
		var encryptContext = new EncryptionContext { AssociatedData = "original-aad"u8.ToArray() };
		var decryptContext = new EncryptionContext { AssociatedData = "different-aad"u8.ToArray() };

		var encryptedData = await _sut.EncryptAsync(plaintext, encryptContext, CancellationToken.None);

		// Act & Assert - AAD mismatch causes authentication failure
		var ex = await Should.ThrowAsync<EncryptionException>(() => _sut.DecryptAsync(encryptedData, decryptContext, CancellationToken.None));
		ex.ErrorCode.ShouldBe(EncryptionErrorCode.AuthenticationFailed);
	}

	#endregion AAD (Associated Authenticated Data) Tests

	#region Unicode and Binary Data Tests

	[Fact]
	public async Task EncryptDecrypt_WithUnicodeText_PreservesContent()
	{
		// Arrange - various Unicode characters
		var unicodeText = "Hello ‰∏ñÁïå üåç ŸÖÿ±ÿ≠ÿ®ÿß ◊©◊ú◊ï◊ù";
		var plaintext = Encoding.UTF8.GetBytes(unicodeText);
		var context = EncryptionContext.Default;

		// Act
		var encryptedData = await _sut.EncryptAsync(plaintext, context, CancellationToken.None);
		var decrypted = await _sut.DecryptAsync(encryptedData, context, CancellationToken.None);

		// Assert
		var decryptedText = Encoding.UTF8.GetString(decrypted);
		decryptedText.ShouldBe(unicodeText);
	}

	[Fact]
	public async Task EncryptDecrypt_WithBinaryData_PreservesAllBytes()
	{
		// Arrange - all possible byte values
		var plaintext = new byte[256];
		for (var i = 0; i < 256; i++)
		{
			plaintext[i] = (byte)i;
		}

		var context = EncryptionContext.Default;

		// Act
		var encryptedData = await _sut.EncryptAsync(plaintext, context, CancellationToken.None);
		var decrypted = await _sut.DecryptAsync(encryptedData, context, CancellationToken.None);

		// Assert
		decrypted.ShouldBe(plaintext);
	}

	#endregion Unicode and Binary Data Tests
}
