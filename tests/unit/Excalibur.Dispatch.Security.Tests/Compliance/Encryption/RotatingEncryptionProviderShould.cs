// SPDX-FileCopyrightText: Copyright (c) 2026 The Excalibur Project
// SPDX-License-Identifier: LicenseRef-Excalibur-1.0 OR AGPL-3.0-or-later OR SSPL-1.0 OR Apache-2.0

using Microsoft.Extensions.Logging.Abstractions;

namespace Excalibur.Dispatch.Security.Tests.Compliance.Encryption;

/// <summary>
/// Unit tests for <see cref="RotatingEncryptionProvider"/>.
/// </summary>
[Trait("Category", TestCategories.Unit)]
public sealed class RotatingEncryptionProviderShould : IDisposable
{
	private readonly InMemoryKeyManagementProvider _keyManagement;
	private readonly RotatingEncryptionProvider _sut;
	// Note: Inner provider is created inline and disposed by _sut.Dispose()

	public RotatingEncryptionProviderShould()
	{
		_keyManagement = new InMemoryKeyManagementProvider(
			NullLogger<InMemoryKeyManagementProvider>.Instance,
			new InMemoryKeyManagementOptions { AutoGenerateDefaultKey = true });

		var innerProvider = new AesGcmEncryptionProvider(
			_keyManagement,
			NullLogger<AesGcmEncryptionProvider>.Instance);

		_sut = new RotatingEncryptionProvider(
			innerProvider,
			_keyManagement,
			NullLogger<RotatingEncryptionProvider>.Instance);
	}

	public void Dispose()
	{
		_sut.Dispose(); // This also disposes inner provider
		_keyManagement.Dispose();
	}

	#region EncryptAsync Tests

	[Fact]
	public async Task EncryptAsync_DelegatesToInnerProvider()
	{
		// Arrange
		var plaintext = "Hello, World!"u8.ToArray();
		var context = EncryptionContext.Default;

		// Act
		var result = await _sut.EncryptAsync(plaintext, context, CancellationToken.None);

		// Assert
		_ = result.ShouldNotBeNull();
		result.Ciphertext.ShouldNotBeEmpty();
	}

	[Fact]
	public async Task EncryptAsync_WhenDisposed_ThrowsObjectDisposedException()
	{
		// Arrange
		_sut.Dispose();
		var plaintext = "Test"u8.ToArray();

		// Act & Assert
		_ = await Should.ThrowAsync<ObjectDisposedException>(() => _sut.EncryptAsync(plaintext, EncryptionContext.Default, CancellationToken.None));
	}

	[Fact]
	public async Task EncryptAsync_WithNullPlaintext_ThrowsArgumentNullException()
	{
		// Act & Assert
		_ = await Should.ThrowAsync<ArgumentNullException>(() => _sut.EncryptAsync(null!, EncryptionContext.Default, CancellationToken.None));
	}

	#endregion EncryptAsync Tests

	#region DecryptAsync Tests

	[Fact]
	public async Task DecryptAsync_WithCurrentKeyVersion_Succeeds()
	{
		// Arrange
		var plaintext = "Current key data"u8.ToArray();
		var encrypted = await _sut.EncryptAsync(plaintext, EncryptionContext.Default, CancellationToken.None);

		// Act
		var decrypted = await _sut.DecryptAsync(encrypted, EncryptionContext.Default, CancellationToken.None);

		// Assert
		decrypted.ShouldBe(plaintext);
	}

	[Fact]
	public async Task DecryptAsync_WithOldKeyVersion_Succeeds()
	{
		// Arrange - encrypt with v1
		var plaintext = "Old key data"u8.ToArray();
		var encrypted = await _sut.EncryptAsync(plaintext, EncryptionContext.Default, CancellationToken.None);

		// Rotate key to v2
		_ = await _keyManagement.RotateKeyAsync("default", EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None);

		// Act - decrypt should still work with v1
		var decrypted = await _sut.DecryptAsync(encrypted, EncryptionContext.Default, CancellationToken.None);

		// Assert
		decrypted.ShouldBe(plaintext);
	}

	[Fact]
	public async Task DecryptAsync_WhenDisposed_ThrowsObjectDisposedException()
	{
		// Arrange
		var plaintext = "Test"u8.ToArray();
		var encrypted = await _sut.EncryptAsync(plaintext, EncryptionContext.Default, CancellationToken.None);
		_sut.Dispose();

		// Act & Assert
		_ = await Should.ThrowAsync<ObjectDisposedException>(() => _sut.DecryptAsync(encrypted, EncryptionContext.Default, CancellationToken.None));
	}

	[Fact]
	public async Task DecryptAsync_WithNullEncryptedData_ThrowsArgumentNullException()
	{
		// Act & Assert
		_ = await Should.ThrowAsync<ArgumentNullException>(() => _sut.DecryptAsync(null!, EncryptionContext.Default, CancellationToken.None));
	}

	#endregion DecryptAsync Tests

	#region Key Rotation Tests

	[Fact]
	public async Task RotateKeyAsync_CreatesNewKeyVersion()
	{
		// Arrange
		const string keyId = "rotate-test";
		_ = await _keyManagement.RotateKeyAsync(keyId, EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None);
		var v1 = await _keyManagement.GetKeyAsync(keyId, CancellationToken.None);

		// Act
		var result = await _sut.RotateKeyAsync(keyId, EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None);

		// Assert
		result.Success.ShouldBeTrue();
		result.NewKey.Version.ShouldBe(2);
		_ = result.PreviousKey.ShouldNotBeNull();
		result.PreviousKey.Version.ShouldBe(1);
	}

	[Fact]
	public async Task RotateKeyAsync_WhenDisposed_ThrowsObjectDisposedException()
	{
		// Arrange
		_sut.Dispose();

		// Act & Assert
		_ = await Should.ThrowAsync<ObjectDisposedException>(() => _sut.RotateKeyAsync("test", EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None));
	}

	#endregion Key Rotation Tests

	#region ReEncryptAsync Tests

	[Fact]
	public async Task ReEncryptAsync_WithOldKeyVersion_EncryptsWithNewKey()
	{
		// Arrange
		var plaintext = "Re-encrypt me"u8.ToArray();
		var encrypted = await _sut.EncryptAsync(plaintext, EncryptionContext.Default, CancellationToken.None);
		var originalVersion = encrypted.KeyVersion;

		// Rotate key
		_ = await _keyManagement.RotateKeyAsync("default", EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None);

		// Act
		var reEncrypted = await _sut.ReEncryptAsync(encrypted, EncryptionContext.Default, CancellationToken.None);

		// Assert
		reEncrypted.KeyVersion.ShouldBeGreaterThan(originalVersion);

		// Verify we can still decrypt
		var decrypted = await _sut.DecryptAsync(reEncrypted, EncryptionContext.Default, CancellationToken.None);
		decrypted.ShouldBe(plaintext);
	}

	[Fact]
	public async Task ReEncryptAsync_WithCurrentKeyVersion_ReturnsOriginalData()
	{
		// Arrange
		var plaintext = "Already current"u8.ToArray();
		var encrypted = await _sut.EncryptAsync(plaintext, EncryptionContext.Default, CancellationToken.None);

		// Act - no rotation, so should return original
		var reEncrypted = await _sut.ReEncryptAsync(encrypted, EncryptionContext.Default, CancellationToken.None);

		// Assert - same data returned (no re-encryption needed)
		reEncrypted.KeyId.ShouldBe(encrypted.KeyId);
		reEncrypted.KeyVersion.ShouldBe(encrypted.KeyVersion);
	}

	[Fact]
	public async Task ReEncryptAsync_WhenDisposed_ThrowsObjectDisposedException()
	{
		// Arrange
		var plaintext = "Test"u8.ToArray();
		var encrypted = await _sut.EncryptAsync(plaintext, EncryptionContext.Default, CancellationToken.None);
		_sut.Dispose();

		// Act & Assert
		_ = await Should.ThrowAsync<ObjectDisposedException>(() => _sut.ReEncryptAsync(encrypted, EncryptionContext.Default, CancellationToken.None));
	}

	[Fact]
	public async Task ReEncryptAsync_WithNullEncryptedData_ThrowsArgumentNullException()
	{
		// Act & Assert
		_ = await Should.ThrowAsync<ArgumentNullException>(() => _sut.ReEncryptAsync(null!, EncryptionContext.Default, CancellationToken.None));
	}

	#endregion ReEncryptAsync Tests

	#region ValidateFipsComplianceAsync Tests

	[Fact]
	public async Task ValidateFipsComplianceAsync_DelegatesToInnerProvider()
	{
		// Act
		var result = await _sut.ValidateFipsComplianceAsync(CancellationToken.None);

		// Assert - should not throw, returns system FIPS status
		result.ShouldBeOneOf(true, false);
	}

	[Fact]
	public async Task ValidateFipsComplianceAsync_WhenDisposed_ThrowsObjectDisposedException()
	{
		// Arrange
		_sut.Dispose();

		// Act & Assert
		_ = await Should.ThrowAsync<ObjectDisposedException>(() => _sut.ValidateFipsComplianceAsync(CancellationToken.None));
	}

	#endregion ValidateFipsComplianceAsync Tests

	#region AutoRotateBeforeEncryption Tests

	[Fact]
	public async Task EncryptAsync_WithAutoRotate_RotatesExpiredKey()
	{
		// Arrange - create provider with short max key age
		using var keyMgmt = new InMemoryKeyManagementProvider(
			NullLogger<InMemoryKeyManagementProvider>.Instance,
			new InMemoryKeyManagementOptions { AutoGenerateDefaultKey = true });

		using var inner = new AesGcmEncryptionProvider(
			keyMgmt,
			NullLogger<AesGcmEncryptionProvider>.Instance);

		var options = new RotatingEncryptionOptions
		{
			AutoRotateBeforeEncryption = true,
			MaxKeyAge = TimeSpan.Zero // Key immediately needs rotation
		};

		using var sut = new RotatingEncryptionProvider(
			inner,
			keyMgmt,
			NullLogger<RotatingEncryptionProvider>.Instance,
			options);

		// Get initial key version
		var initialKey = await keyMgmt.GetActiveKeyAsync(null, CancellationToken.None);
		var initialVersion = initialKey.Version;

		// Act - encrypt should trigger rotation
		var plaintext = "Trigger rotation"u8.ToArray();

		// Small delay to ensure key age check works
		await Task.Delay(10);

		_ = await sut.EncryptAsync(plaintext, EncryptionContext.Default, CancellationToken.None);

		// Assert - key should have been rotated
		var newKey = await keyMgmt.GetActiveKeyAsync(null, CancellationToken.None);
		newKey.Version.ShouldBeGreaterThan(initialVersion);
	}

	#endregion AutoRotateBeforeEncryption Tests

	#region Backward Compatibility Tests

	[Fact]
	public async Task MultipleKeyRotations_AllVersionsRemainDecryptable()
	{
		// Arrange - create data with multiple key versions
		var data1 = "Version 1 data"u8.ToArray();
		var encrypted1 = await _sut.EncryptAsync(data1, EncryptionContext.Default, CancellationToken.None);

		_ = await _keyManagement.RotateKeyAsync("default", EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None);
		var data2 = "Version 2 data"u8.ToArray();
		var encrypted2 = await _sut.EncryptAsync(data2, EncryptionContext.Default, CancellationToken.None);

		_ = await _keyManagement.RotateKeyAsync("default", EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None);
		var data3 = "Version 3 data"u8.ToArray();
		var encrypted3 = await _sut.EncryptAsync(data3, EncryptionContext.Default, CancellationToken.None);

		// Act - decrypt all versions
		var decrypted1 = await _sut.DecryptAsync(encrypted1, EncryptionContext.Default, CancellationToken.None);
		var decrypted2 = await _sut.DecryptAsync(encrypted2, EncryptionContext.Default, CancellationToken.None);
		var decrypted3 = await _sut.DecryptAsync(encrypted3, EncryptionContext.Default, CancellationToken.None);

		// Assert - all versions decryptable
		decrypted1.ShouldBe(data1);
		decrypted2.ShouldBe(data2);
		decrypted3.ShouldBe(data3);

		// Verify different key versions were used
		encrypted1.KeyVersion.ShouldBe(1);
		encrypted2.KeyVersion.ShouldBe(2);
		encrypted3.KeyVersion.ShouldBe(3);
	}

	#endregion Backward Compatibility Tests

	#region Constructor Tests

	[Fact]
	public void Constructor_WithNullInner_ThrowsArgumentNullException()
	{
		// Act & Assert
		_ = Should.Throw<ArgumentNullException>(() => new RotatingEncryptionProvider(
			null!,
			_keyManagement,
			NullLogger<RotatingEncryptionProvider>.Instance));
	}

	[Fact]
	public void Constructor_WithNullKeyManagement_ThrowsArgumentNullException()
	{
		// Arrange
		var fakeInner = A.Fake<IEncryptionProvider>();

		// Act & Assert
		_ = Should.Throw<ArgumentNullException>(() => new RotatingEncryptionProvider(
			fakeInner,
			null!,
			NullLogger<RotatingEncryptionProvider>.Instance));
	}

	[Fact]
	public void Constructor_WithNullLogger_ThrowsArgumentNullException()
	{
		// Arrange
		var fakeInner = A.Fake<IEncryptionProvider>();

		// Act & Assert
		_ = Should.Throw<ArgumentNullException>(() => new RotatingEncryptionProvider(
			fakeInner,
			_keyManagement,
			null!));
	}

	#endregion Constructor Tests

	#region Dispose Tests

	[Fact]
	public void Dispose_DisposesInnerProvider()
	{
		// Arrange
		var innerProvider = A.Fake<IEncryptionProvider>(o => o.Implements<IDisposable>());
		var keyManagement = A.Fake<IKeyManagementProvider>();

		var sut = new RotatingEncryptionProvider(
			innerProvider,
			keyManagement,
			NullLogger<RotatingEncryptionProvider>.Instance);

		// Act
		sut.Dispose();

		// Assert
		_ = A.CallTo(() => ((IDisposable)innerProvider).Dispose()).MustHaveHappened();
	}

	[Fact]
	public void Dispose_CanBeCalledMultipleTimes()
	{
		// Act & Assert - should not throw
		_sut.Dispose();
		_sut.Dispose();
	}

	#endregion Dispose Tests
}
