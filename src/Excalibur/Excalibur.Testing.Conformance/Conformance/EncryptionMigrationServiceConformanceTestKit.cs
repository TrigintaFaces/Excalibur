// SPDX-FileCopyrightText: Copyright (c) 2026 The Excalibur Project
// SPDX-License-Identifier: LicenseRef-Excalibur-1.0 OR AGPL-3.0-or-later OR SSPL-1.0 OR Apache-2.0


#pragma warning disable IDE0270 // Null check can be simplified

using Excalibur.Dispatch.Compliance;

namespace Excalibur.Testing.Conformance;

/// <summary>
/// Abstract base class for IEncryptionMigrationService conformance testing.
/// </summary>
/// <remarks>
/// <para>
/// Inherit from this class and implement <see cref="CreateServiceAsync"/> to verify that
/// your encryption migration service implementation conforms to the IEncryptionMigrationService contract.
/// </para>
/// <para>
/// The test kit verifies core migration operations including:
/// <list type="bullet">
/// <item><description>Single item migration with RE-ENCRYPTION pattern (Decrypt â†’ Encrypt)</description></item>
/// <item><description>Batch migration with parallelism and ContinueOnError support</description></item>
/// <item><description>Policy-based migration detection (deprecated keys, algorithms, age)</description></item>
/// <item><description>Migration status tracking and retrieval</description></item>
/// <item><description>Migration estimation for planning</description></item>
/// <item><description>Null parameter validation (ArgumentNullException)</description></item>
/// </list>
/// </para>
/// <para>
/// <strong>COMPLIANCE-CRITICAL:</strong> IEncryptionMigrationService implements GDPR crypto-shredding
/// support by enabling re-encryption with new keys before destroying old keys:
/// <list type="bullet">
/// <item><description>MigrateAsync decrypts with source context, re-encrypts with target context</description></item>
/// <item><description>Round-trip: Original plaintext recoverable from migrated data</description></item>
/// <item><description>RequiresMigrationAsync checks deprecated keys, algorithms, age policies</description></item>
/// <item><description>Batch migration supports ContinueOnError for partial success handling</description></item>
/// </list>
/// </para>
/// </remarks>
/// <example>
/// <code>
/// public class EncryptionMigrationServiceConformanceTests : EncryptionMigrationServiceConformanceTestKit
/// {
///     protected override async Task&lt;(IEncryptionMigrationService Service, IEncryptionProvider Encryption, IKeyManagementProvider KeyManagement)&gt; CreateServiceAsync()
///     {
///         var keyManagement = new InMemoryKeyManagementProvider(
///             NullLogger&lt;InMemoryKeyManagementProvider&gt;.Instance,
///             new InMemoryKeyManagementOptions { AutoGenerateDefaultKey = true });
///
///         var encryption = new AesGcmEncryptionProvider(
///             keyManagement,
///             NullLogger&lt;AesGcmEncryptionProvider&gt;.Instance);
///
///         var service = new EncryptionMigrationService(
///             encryption,
///             NullLogger&lt;EncryptionMigrationService&gt;.Instance);
///
///         return (service, encryption, keyManagement);
///     }
/// }
/// </code>
/// </example>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Naming", "CA1707:Identifiers should not contain underscores",
	Justification = "Test method naming convention")]
public abstract class EncryptionMigrationServiceConformanceTestKit
{
	/// <summary>
	/// Creates a fresh encryption migration service instance along with its dependencies for testing.
	/// </summary>
	/// <returns>A tuple containing the IEncryptionMigrationService, IEncryptionProvider, and IKeyManagementProvider to test.</returns>
	/// <remarks>
	/// <para>
	/// The encryption provider and key management provider are needed to create encrypted data for migration testing.
	/// </para>
	/// <para>
	/// You MUST ensure the key management provider has at least one active key for encryption operations.
	/// </para>
	/// </remarks>
	protected abstract Task<(IEncryptionMigrationService Service, IEncryptionProvider Encryption, IKeyManagementProvider KeyManagement)>
		CreateServiceAsync();

	/// <summary>
	/// Optional cleanup after each test.
	/// </summary>
	/// <returns>A task representing the cleanup operation.</returns>
	protected virtual Task CleanupAsync() => Task.CompletedTask;

	/// <summary>
	/// Generates test plaintext data.
	/// </summary>
	/// <param name="size">The size of the plaintext in bytes.</param>
	/// <returns>Random plaintext bytes.</returns>
	protected virtual byte[] GeneratePlaintext(int size = 256)
	{
		var plaintext = new byte[size];
		System.Security.Cryptography.RandomNumberGenerator.Fill(plaintext);
		return plaintext;
	}

	/// <summary>
	/// Generates a unique key ID for test isolation.
	/// </summary>
	/// <returns>A unique key identifier.</returns>
	protected virtual string GenerateKeyId() => $"test-key-{Guid.NewGuid():N}";

	/// <summary>
	/// Generates a unique migration ID for test isolation.
	/// </summary>
	/// <returns>A unique migration identifier.</returns>
	protected virtual string GenerateMigrationId() => $"migration-{Guid.NewGuid():N}";

	/// <summary>
	/// Generates a unique item ID for test isolation.
	/// </summary>
	/// <returns>A unique item identifier.</returns>
	protected virtual string GenerateItemId() => $"item-{Guid.NewGuid():N}";

	#region MigrateAsync Tests

	/// <summary>
	/// Verifies that MigrateAsync throws ArgumentNullException for null encryptedData.
	/// </summary>
	protected virtual async Task MigrateAsync_NullEncryptedData_ShouldThrowArgumentNullException()
	{
		// Arrange
		var (service, encryption, keyManagement) = await CreateServiceAsync().ConfigureAwait(false);
		try
		{
			// Act & Assert
			var caughtException = false;
			try
			{
				_ = await service.MigrateAsync(
					null!,
					EncryptionContext.Default,
					EncryptionContext.Default,
					CancellationToken.None).ConfigureAwait(false);
			}
			catch (ArgumentNullException)
			{
				caughtException = true;
			}

			if (!caughtException)
			{
				throw new TestFixtureAssertionException(
					"Expected MigrateAsync to throw ArgumentNullException for null encryptedData.");
			}
		}
		finally
		{
			await CleanupAsync().ConfigureAwait(false);
			(encryption as IDisposable)?.Dispose();
			(keyManagement as IDisposable)?.Dispose();
		}
	}

	/// <summary>
	/// Verifies that MigrateAsync throws ArgumentNullException for null sourceContext.
	/// </summary>
	protected virtual async Task MigrateAsync_NullSourceContext_ShouldThrowArgumentNullException()
	{
		// Arrange
		var (service, encryption, keyManagement) = await CreateServiceAsync().ConfigureAwait(false);
		try
		{
			var sourceKeyId = GenerateKeyId();
			_ = await keyManagement.RotateKeyAsync(sourceKeyId, EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None)
				.ConfigureAwait(false);

			var plaintext = GeneratePlaintext();
			var sourceContext = new EncryptionContext { KeyId = sourceKeyId };
			var encrypted = await encryption.EncryptAsync(plaintext, sourceContext, CancellationToken.None).ConfigureAwait(false);

			// Act & Assert
			var caughtException = false;
			try
			{
				_ = await service.MigrateAsync(
					encrypted,
					null!,
					EncryptionContext.Default,
					CancellationToken.None).ConfigureAwait(false);
			}
			catch (ArgumentNullException)
			{
				caughtException = true;
			}

			if (!caughtException)
			{
				throw new TestFixtureAssertionException(
					"Expected MigrateAsync to throw ArgumentNullException for null sourceContext.");
			}
		}
		finally
		{
			await CleanupAsync().ConfigureAwait(false);
			(encryption as IDisposable)?.Dispose();
			(keyManagement as IDisposable)?.Dispose();
		}
	}

	/// <summary>
	/// Verifies that MigrateAsync throws ArgumentNullException for null targetContext.
	/// </summary>
	protected virtual async Task MigrateAsync_NullTargetContext_ShouldThrowArgumentNullException()
	{
		// Arrange
		var (service, encryption, keyManagement) = await CreateServiceAsync().ConfigureAwait(false);
		try
		{
			var sourceKeyId = GenerateKeyId();
			_ = await keyManagement.RotateKeyAsync(sourceKeyId, EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None)
				.ConfigureAwait(false);

			var plaintext = GeneratePlaintext();
			var sourceContext = new EncryptionContext { KeyId = sourceKeyId };
			var encrypted = await encryption.EncryptAsync(plaintext, sourceContext, CancellationToken.None).ConfigureAwait(false);

			// Act & Assert
			var caughtException = false;
			try
			{
				_ = await service.MigrateAsync(
					encrypted,
					sourceContext,
					null!,
					CancellationToken.None).ConfigureAwait(false);
			}
			catch (ArgumentNullException)
			{
				caughtException = true;
			}

			if (!caughtException)
			{
				throw new TestFixtureAssertionException(
					"Expected MigrateAsync to throw ArgumentNullException for null targetContext.");
			}
		}
		finally
		{
			await CleanupAsync().ConfigureAwait(false);
			(encryption as IDisposable)?.Dispose();
			(keyManagement as IDisposable)?.Dispose();
		}
	}

	/// <summary>
	/// Verifies that MigrateAsync returns successful result with migrated data.
	/// </summary>
	protected virtual async Task MigrateAsync_ValidData_ShouldReturnSuccessfulResult()
	{
		// Arrange
		var (service, encryption, keyManagement) = await CreateServiceAsync().ConfigureAwait(false);
		try
		{
			var sourceKeyId = GenerateKeyId();
			var targetKeyId = GenerateKeyId();
			_ = await keyManagement.RotateKeyAsync(sourceKeyId, EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None)
				.ConfigureAwait(false);
			_ = await keyManagement.RotateKeyAsync(targetKeyId, EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None)
				.ConfigureAwait(false);

			var plaintext = GeneratePlaintext();
			var sourceContext = new EncryptionContext { KeyId = sourceKeyId };
			var targetContext = new EncryptionContext { KeyId = targetKeyId };
			var encrypted = await encryption.EncryptAsync(plaintext, sourceContext, CancellationToken.None).ConfigureAwait(false);

			// Act
			var result = await service.MigrateAsync(encrypted, sourceContext, targetContext, CancellationToken.None).ConfigureAwait(false);

			// Assert
			if (result is null)
			{
				throw new TestFixtureAssertionException("Expected MigrateAsync to return EncryptionMigrationResult.");
			}

			if (!result.Success)
			{
				throw new TestFixtureAssertionException(
					$"Expected migration to succeed, but got error: {result.ErrorMessage}");
			}

			if (result.MigratedData is null)
			{
				throw new TestFixtureAssertionException("Expected MigratedData to be populated on success.");
			}

			if (result.MigratedData.KeyId != targetKeyId)
			{
				throw new TestFixtureAssertionException(
					$"Expected MigratedData.KeyId to be '{targetKeyId}', but got '{result.MigratedData.KeyId}'.");
			}

			if (result.Duration == TimeSpan.Zero)
			{
				throw new TestFixtureAssertionException("Expected Duration to be populated.");
			}
		}
		finally
		{
			await CleanupAsync().ConfigureAwait(false);
			(encryption as IDisposable)?.Dispose();
			(keyManagement as IDisposable)?.Dispose();
		}
	}

	/// <summary>
	/// Verifies that MigrateAsync preserves original plaintext after re-encryption (round-trip).
	/// </summary>
	protected virtual async Task MigrateAsync_RoundTrip_ShouldPreserveOriginalPlaintext()
	{
		// Arrange
		var (service, encryption, keyManagement) = await CreateServiceAsync().ConfigureAwait(false);
		try
		{
			var sourceKeyId = GenerateKeyId();
			var targetKeyId = GenerateKeyId();
			_ = await keyManagement.RotateKeyAsync(sourceKeyId, EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None)
				.ConfigureAwait(false);
			_ = await keyManagement.RotateKeyAsync(targetKeyId, EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None)
				.ConfigureAwait(false);

			var originalPlaintext = GeneratePlaintext();
			var sourceContext = new EncryptionContext { KeyId = sourceKeyId };
			var targetContext = new EncryptionContext { KeyId = targetKeyId };
			var encrypted = await encryption.EncryptAsync(originalPlaintext, sourceContext, CancellationToken.None).ConfigureAwait(false);

			// Act
			var result = await service.MigrateAsync(encrypted, sourceContext, targetContext, CancellationToken.None).ConfigureAwait(false);

			// Decrypt the migrated data to verify plaintext
			var decrypted = await encryption.DecryptAsync(result.MigratedData, targetContext, CancellationToken.None)
				.ConfigureAwait(false);

			// Assert
			if (decrypted is null)
			{
				throw new TestFixtureAssertionException("Expected to be able to decrypt migrated data.");
			}

			if (decrypted.Length != originalPlaintext.Length)
			{
				throw new TestFixtureAssertionException(
					$"Expected decrypted length {originalPlaintext.Length}, but got {decrypted.Length}.");
			}

			for (var i = 0; i < originalPlaintext.Length; i++)
			{
				if (decrypted[i] != originalPlaintext[i])
				{
					throw new TestFixtureAssertionException(
						$"Decrypted data differs from original at position {i}.");
				}
			}
		}
		finally
		{
			await CleanupAsync().ConfigureAwait(false);
			(encryption as IDisposable)?.Dispose();
			(keyManagement as IDisposable)?.Dispose();
		}
	}

	#endregion

	#region MigrateBatchAsync Tests

	/// <summary>
	/// Verifies that MigrateBatchAsync throws ArgumentNullException for null items.
	/// </summary>
	protected virtual async Task MigrateBatchAsync_NullItems_ShouldThrowArgumentNullException()
	{
		// Arrange
		var (service, encryption, keyManagement) = await CreateServiceAsync().ConfigureAwait(false);
		try
		{
			// Act & Assert
			var caughtException = false;
			try
			{
				_ = await service.MigrateBatchAsync(
					null!,
					EncryptionContext.Default,
					BatchMigrationOptions.Default,
					CancellationToken.None).ConfigureAwait(false);
			}
			catch (ArgumentNullException)
			{
				caughtException = true;
			}

			if (!caughtException)
			{
				throw new TestFixtureAssertionException(
					"Expected MigrateBatchAsync to throw ArgumentNullException for null items.");
			}
		}
		finally
		{
			await CleanupAsync().ConfigureAwait(false);
			(encryption as IDisposable)?.Dispose();
			(keyManagement as IDisposable)?.Dispose();
		}
	}

	/// <summary>
	/// Verifies that MigrateBatchAsync throws ArgumentNullException for null targetContext.
	/// </summary>
	protected virtual async Task MigrateBatchAsync_NullTargetContext_ShouldThrowArgumentNullException()
	{
		// Arrange
		var (service, encryption, keyManagement) = await CreateServiceAsync().ConfigureAwait(false);
		try
		{
			var items = new List<EncryptionMigrationItem>();

			// Act & Assert
			var caughtException = false;
			try
			{
				_ = await service.MigrateBatchAsync(
					items,
					null!,
					BatchMigrationOptions.Default,
					CancellationToken.None).ConfigureAwait(false);
			}
			catch (ArgumentNullException)
			{
				caughtException = true;
			}

			if (!caughtException)
			{
				throw new TestFixtureAssertionException(
					"Expected MigrateBatchAsync to throw ArgumentNullException for null targetContext.");
			}
		}
		finally
		{
			await CleanupAsync().ConfigureAwait(false);
			(encryption as IDisposable)?.Dispose();
			(keyManagement as IDisposable)?.Dispose();
		}
	}

	/// <summary>
	/// Verifies that MigrateBatchAsync throws ArgumentNullException for null options.
	/// </summary>
	protected virtual async Task MigrateBatchAsync_NullOptions_ShouldThrowArgumentNullException()
	{
		// Arrange
		var (service, encryption, keyManagement) = await CreateServiceAsync().ConfigureAwait(false);
		try
		{
			var items = new List<EncryptionMigrationItem>();

			// Act & Assert
			var caughtException = false;
			try
			{
				_ = await service.MigrateBatchAsync(
					items,
					EncryptionContext.Default,
					null!,
					CancellationToken.None).ConfigureAwait(false);
			}
			catch (ArgumentNullException)
			{
				caughtException = true;
			}

			if (!caughtException)
			{
				throw new TestFixtureAssertionException(
					"Expected MigrateBatchAsync to throw ArgumentNullException for null options.");
			}
		}
		finally
		{
			await CleanupAsync().ConfigureAwait(false);
			(encryption as IDisposable)?.Dispose();
			(keyManagement as IDisposable)?.Dispose();
		}
	}

	/// <summary>
	/// Verifies that MigrateBatchAsync returns successful result for valid batch.
	/// </summary>
	protected virtual async Task MigrateBatchAsync_ValidBatch_ShouldReturnSuccessfulResult()
	{
		// Arrange
		var (service, encryption, keyManagement) = await CreateServiceAsync().ConfigureAwait(false);
		try
		{
			var sourceKeyId = GenerateKeyId();
			var targetKeyId = GenerateKeyId();
			_ = await keyManagement.RotateKeyAsync(sourceKeyId, EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None)
				.ConfigureAwait(false);
			_ = await keyManagement.RotateKeyAsync(targetKeyId, EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None)
				.ConfigureAwait(false);

			var sourceContext = new EncryptionContext { KeyId = sourceKeyId };
			var targetContext = new EncryptionContext { KeyId = targetKeyId };

			// Create batch items
			var items = new List<EncryptionMigrationItem>();
			for (var i = 0; i < 3; i++)
			{
				var plaintext = GeneratePlaintext();
				var encrypted = await encryption.EncryptAsync(plaintext, sourceContext, CancellationToken.None).ConfigureAwait(false);
				items.Add(new EncryptionMigrationItem
				{
					ItemId = GenerateItemId(),
					EncryptedData = encrypted,
					SourceContext = sourceContext,
				});
			}

			var options = new BatchMigrationOptions { MigrationId = GenerateMigrationId(), ContinueOnError = true, };

			// Act
			var result = await service.MigrateBatchAsync(items, targetContext, options, CancellationToken.None).ConfigureAwait(false);

			// Assert
			if (result is null)
			{
				throw new TestFixtureAssertionException("Expected MigrateBatchAsync to return BatchMigrationResult.");
			}

			if (!result.Success)
			{
				throw new TestFixtureAssertionException(
					$"Expected batch migration to succeed. Succeeded: {result.SucceededCount}, Failed: {result.FailedCount}");
			}

			if (result.TotalItems != items.Count)
			{
				throw new TestFixtureAssertionException(
					$"Expected TotalItems to be {items.Count}, but got {result.TotalItems}.");
			}

			if (result.SucceededCount != items.Count)
			{
				throw new TestFixtureAssertionException(
					$"Expected SucceededCount to be {items.Count}, but got {result.SucceededCount}.");
			}

			if (result.FailedCount != 0)
			{
				throw new TestFixtureAssertionException(
					$"Expected FailedCount to be 0, but got {result.FailedCount}.");
			}
		}
		finally
		{
			await CleanupAsync().ConfigureAwait(false);
			(encryption as IDisposable)?.Dispose();
			(keyManagement as IDisposable)?.Dispose();
		}
	}

	/// <summary>
	/// Verifies that MigrateBatchAsync handles empty batch.
	/// </summary>
	protected virtual async Task MigrateBatchAsync_EmptyBatch_ShouldReturnSuccessfulResult()
	{
		// Arrange
		var (service, encryption, keyManagement) = await CreateServiceAsync().ConfigureAwait(false);
		try
		{
			var targetKeyId = GenerateKeyId();
			_ = await keyManagement.RotateKeyAsync(targetKeyId, EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None)
				.ConfigureAwait(false);

			var items = new List<EncryptionMigrationItem>();
			var targetContext = new EncryptionContext { KeyId = targetKeyId };
			var options = new BatchMigrationOptions { MigrationId = GenerateMigrationId(), };

			// Act
			var result = await service.MigrateBatchAsync(items, targetContext, options, CancellationToken.None).ConfigureAwait(false);

			// Assert
			if (result is null)
			{
				throw new TestFixtureAssertionException("Expected MigrateBatchAsync to return BatchMigrationResult for empty batch.");
			}

			if (!result.Success)
			{
				throw new TestFixtureAssertionException("Expected empty batch migration to succeed.");
			}

			if (result.TotalItems != 0)
			{
				throw new TestFixtureAssertionException(
					$"Expected TotalItems to be 0 for empty batch, but got {result.TotalItems}.");
			}
		}
		finally
		{
			await CleanupAsync().ConfigureAwait(false);
			(encryption as IDisposable)?.Dispose();
			(keyManagement as IDisposable)?.Dispose();
		}
	}

	#endregion

	#region RequiresMigrationAsync Tests

	/// <summary>
	/// Verifies that RequiresMigrationAsync throws ArgumentNullException for null encryptedData.
	/// </summary>
	protected virtual async Task RequiresMigrationAsync_NullEncryptedData_ShouldThrowArgumentNullException()
	{
		// Arrange
		var (service, encryption, keyManagement) = await CreateServiceAsync().ConfigureAwait(false);
		try
		{
			// Act & Assert
			var caughtException = false;
			try
			{
				_ = await service.RequiresMigrationAsync(
					null!,
					MigrationPolicy.Default,
					CancellationToken.None).ConfigureAwait(false);
			}
			catch (ArgumentNullException)
			{
				caughtException = true;
			}

			if (!caughtException)
			{
				throw new TestFixtureAssertionException(
					"Expected RequiresMigrationAsync to throw ArgumentNullException for null encryptedData.");
			}
		}
		finally
		{
			await CleanupAsync().ConfigureAwait(false);
			(encryption as IDisposable)?.Dispose();
			(keyManagement as IDisposable)?.Dispose();
		}
	}

	/// <summary>
	/// Verifies that RequiresMigrationAsync throws ArgumentNullException for null policy.
	/// </summary>
	protected virtual async Task RequiresMigrationAsync_NullPolicy_ShouldThrowArgumentNullException()
	{
		// Arrange
		var (service, encryption, keyManagement) = await CreateServiceAsync().ConfigureAwait(false);
		try
		{
			var keyId = GenerateKeyId();
			_ = await keyManagement.RotateKeyAsync(keyId, EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None)
				.ConfigureAwait(false);

			var plaintext = GeneratePlaintext();
			var context = new EncryptionContext { KeyId = keyId };
			var encrypted = await encryption.EncryptAsync(plaintext, context, CancellationToken.None).ConfigureAwait(false);

			// Act & Assert
			var caughtException = false;
			try
			{
				_ = await service.RequiresMigrationAsync(
					encrypted,
					null!,
					CancellationToken.None).ConfigureAwait(false);
			}
			catch (ArgumentNullException)
			{
				caughtException = true;
			}

			if (!caughtException)
			{
				throw new TestFixtureAssertionException(
					"Expected RequiresMigrationAsync to throw ArgumentNullException for null policy.");
			}
		}
		finally
		{
			await CleanupAsync().ConfigureAwait(false);
			(encryption as IDisposable)?.Dispose();
			(keyManagement as IDisposable)?.Dispose();
		}
	}

	/// <summary>
	/// Verifies that RequiresMigrationAsync returns true for deprecated key ID.
	/// </summary>
	protected virtual async Task RequiresMigrationAsync_DeprecatedKeyId_ShouldReturnTrue()
	{
		// Arrange
		var (service, encryption, keyManagement) = await CreateServiceAsync().ConfigureAwait(false);
		try
		{
			var keyId = GenerateKeyId();
			_ = await keyManagement.RotateKeyAsync(keyId, EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None)
				.ConfigureAwait(false);

			var plaintext = GeneratePlaintext();
			var context = new EncryptionContext { KeyId = keyId };
			var encrypted = await encryption.EncryptAsync(plaintext, context, CancellationToken.None).ConfigureAwait(false);

			// Policy marks this key as deprecated
			var policy = MigrationPolicy.ForDeprecatedKeys(keyId);

			// Act
			var requiresMigration = await service.RequiresMigrationAsync(encrypted, policy, CancellationToken.None).ConfigureAwait(false);

			// Assert
			if (!requiresMigration)
			{
				throw new TestFixtureAssertionException(
					"Expected RequiresMigrationAsync to return true for deprecated key ID.");
			}
		}
		finally
		{
			await CleanupAsync().ConfigureAwait(false);
			(encryption as IDisposable)?.Dispose();
			(keyManagement as IDisposable)?.Dispose();
		}
	}

	/// <summary>
	/// Verifies that RequiresMigrationAsync returns false when data does not match policy.
	/// </summary>
	protected virtual async Task RequiresMigrationAsync_NoMatchingPolicy_ShouldReturnFalse()
	{
		// Arrange
		var (service, encryption, keyManagement) = await CreateServiceAsync().ConfigureAwait(false);
		try
		{
			var keyId = GenerateKeyId();
			_ = await keyManagement.RotateKeyAsync(keyId, EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None)
				.ConfigureAwait(false);

			var plaintext = GeneratePlaintext();
			var context = new EncryptionContext { KeyId = keyId };
			var encrypted = await encryption.EncryptAsync(plaintext, context, CancellationToken.None).ConfigureAwait(false);

			// Policy marks different key as deprecated
			var policy = MigrationPolicy.ForDeprecatedKeys("some-other-key-that-does-not-exist");

			// Act
			var requiresMigration = await service.RequiresMigrationAsync(encrypted, policy, CancellationToken.None).ConfigureAwait(false);

			// Assert
			if (requiresMigration)
			{
				throw new TestFixtureAssertionException(
					"Expected RequiresMigrationAsync to return false when key is not deprecated.");
			}
		}
		finally
		{
			await CleanupAsync().ConfigureAwait(false);
			(encryption as IDisposable)?.Dispose();
			(keyManagement as IDisposable)?.Dispose();
		}
	}

	#endregion

	#region GetMigrationStatusAsync Tests

	/// <summary>
	/// Verifies that GetMigrationStatusAsync throws ArgumentNullException for null migrationId.
	/// </summary>
	protected virtual async Task GetMigrationStatusAsync_NullMigrationId_ShouldThrowArgumentNullException()
	{
		// Arrange
		var (service, encryption, keyManagement) = await CreateServiceAsync().ConfigureAwait(false);
		try
		{
			// Act & Assert
			var caughtException = false;
			try
			{
				_ = await service.GetMigrationStatusAsync(null!, CancellationToken.None).ConfigureAwait(false);
			}
			catch (ArgumentNullException)
			{
				caughtException = true;
			}

			if (!caughtException)
			{
				throw new TestFixtureAssertionException(
					"Expected GetMigrationStatusAsync to throw ArgumentNullException for null migrationId.");
			}
		}
		finally
		{
			await CleanupAsync().ConfigureAwait(false);
			(encryption as IDisposable)?.Dispose();
			(keyManagement as IDisposable)?.Dispose();
		}
	}

	/// <summary>
	/// Verifies that GetMigrationStatusAsync returns null for non-existent migration.
	/// </summary>
	protected virtual async Task GetMigrationStatusAsync_NonExistentMigration_ShouldReturnNull()
	{
		// Arrange
		var (service, encryption, keyManagement) = await CreateServiceAsync().ConfigureAwait(false);
		try
		{
			// Act
			var status = await service.GetMigrationStatusAsync("non-existent-migration", CancellationToken.None).ConfigureAwait(false);

			// Assert
			if (status is not null)
			{
				throw new TestFixtureAssertionException(
					"Expected GetMigrationStatusAsync to return null for non-existent migration.");
			}
		}
		finally
		{
			await CleanupAsync().ConfigureAwait(false);
			(encryption as IDisposable)?.Dispose();
			(keyManagement as IDisposable)?.Dispose();
		}
	}

	/// <summary>
	/// Verifies that GetMigrationStatusAsync returns status after batch migration.
	/// </summary>
	protected virtual async Task GetMigrationStatusAsync_AfterBatchMigration_ShouldReturnStatus()
	{
		// Arrange
		var (service, encryption, keyManagement) = await CreateServiceAsync().ConfigureAwait(false);
		try
		{
			var sourceKeyId = GenerateKeyId();
			var targetKeyId = GenerateKeyId();
			_ = await keyManagement.RotateKeyAsync(sourceKeyId, EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None)
				.ConfigureAwait(false);
			_ = await keyManagement.RotateKeyAsync(targetKeyId, EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None)
				.ConfigureAwait(false);

			var sourceContext = new EncryptionContext { KeyId = sourceKeyId };
			var targetContext = new EncryptionContext { KeyId = targetKeyId };

			var items = new List<EncryptionMigrationItem>();
			var plaintext = GeneratePlaintext();
			var encrypted = await encryption.EncryptAsync(plaintext, sourceContext, CancellationToken.None).ConfigureAwait(false);
			items.Add(new EncryptionMigrationItem { ItemId = GenerateItemId(), EncryptedData = encrypted, SourceContext = sourceContext, });

			var migrationId = GenerateMigrationId();
			var options = new BatchMigrationOptions { MigrationId = migrationId, TrackProgress = true, };

			// Run batch migration to create status
			_ = await service.MigrateBatchAsync(items, targetContext, options, CancellationToken.None).ConfigureAwait(false);

			// Act
			var status = await service.GetMigrationStatusAsync(migrationId, CancellationToken.None).ConfigureAwait(false);

			// Assert
			if (status is null)
			{
				throw new TestFixtureAssertionException(
					"Expected GetMigrationStatusAsync to return status after batch migration.");
			}

			if (status.MigrationId != migrationId)
			{
				throw new TestFixtureAssertionException(
					$"Expected MigrationId to be '{migrationId}', but got '{status.MigrationId}'.");
			}

			if (status.State != MigrationState.Completed)
			{
				throw new TestFixtureAssertionException(
					$"Expected State to be Completed, but got {status.State}.");
			}
		}
		finally
		{
			await CleanupAsync().ConfigureAwait(false);
			(encryption as IDisposable)?.Dispose();
			(keyManagement as IDisposable)?.Dispose();
		}
	}

	#endregion

	#region EstimateMigrationAsync Tests

	/// <summary>
	/// Verifies that EstimateMigrationAsync throws ArgumentNullException for null policy.
	/// </summary>
	protected virtual async Task EstimateMigrationAsync_NullPolicy_ShouldThrowArgumentNullException()
	{
		// Arrange
		var (service, encryption, keyManagement) = await CreateServiceAsync().ConfigureAwait(false);
		try
		{
			// Act & Assert
			var caughtException = false;
			try
			{
				_ = await service.EstimateMigrationAsync(null!, CancellationToken.None).ConfigureAwait(false);
			}
			catch (ArgumentNullException)
			{
				caughtException = true;
			}

			if (!caughtException)
			{
				throw new TestFixtureAssertionException(
					"Expected EstimateMigrationAsync to throw ArgumentNullException for null policy.");
			}
		}
		finally
		{
			await CleanupAsync().ConfigureAwait(false);
			(encryption as IDisposable)?.Dispose();
			(keyManagement as IDisposable)?.Dispose();
		}
	}

	/// <summary>
	/// Verifies that EstimateMigrationAsync returns estimate structure.
	/// </summary>
	protected virtual async Task EstimateMigrationAsync_ValidPolicy_ShouldReturnEstimate()
	{
		// Arrange
		var (service, encryption, keyManagement) = await CreateServiceAsync().ConfigureAwait(false);
		try
		{
			var policy = MigrationPolicy.Default;

			// Act
			var estimate = await service.EstimateMigrationAsync(policy, CancellationToken.None).ConfigureAwait(false);

			// Assert
			if (estimate is null)
			{
				throw new TestFixtureAssertionException(
					"Expected EstimateMigrationAsync to return MigrationEstimate.");
			}

			// The estimate structure should be populated (even if with placeholder values)
			// EstimatedItemCount >= 0 is the only valid assertion for a placeholder
			if (estimate.EstimatedItemCount < 0)
			{
				throw new TestFixtureAssertionException(
					$"Expected EstimatedItemCount >= 0, but got {estimate.EstimatedItemCount}.");
			}
		}
		finally
		{
			await CleanupAsync().ConfigureAwait(false);
			(encryption as IDisposable)?.Dispose();
			(keyManagement as IDisposable)?.Dispose();
		}
	}

	#endregion
}
