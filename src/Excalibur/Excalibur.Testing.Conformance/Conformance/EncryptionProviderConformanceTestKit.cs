// SPDX-FileCopyrightText: Copyright (c) 2026 The Excalibur Project
// SPDX-License-Identifier: LicenseRef-Excalibur-1.0 OR AGPL-3.0-or-later OR SSPL-1.0 OR Apache-2.0


#pragma warning disable IDE0270 // Null check can be simplified

using System.Text;

using Excalibur.Dispatch.Compliance;

namespace Excalibur.Testing.Conformance;

/// <summary>
/// Abstract base class for IEncryptionProvider conformance testing.
/// </summary>
/// <remarks>
/// <para>
/// Inherit from this class and implement <see cref="CreateProviderAsync"/> to verify that
/// your encryption provider implementation conforms to the IEncryptionProvider contract.
/// </para>
/// <para>
/// The test kit verifies core encryption operations including:
/// <list type="bullet">
/// <item><description>Round-trip encryption/decryption with plaintext verification</description></item>
/// <item><description>EncryptedData metadata population (KeyId, KeyVersion, Algorithm, IV, AuthTag)</description></item>
/// <item><description>Null parameter validation (ArgumentNullException)</description></item>
/// <item><description>Key status validation (Suspended/Destroyed keys cannot decrypt)</description></item>
/// <item><description>Algorithm validation (UnsupportedAlgorithm error)</description></item>
/// <item><description>FIPS compliance validation</description></item>
/// <item><description>IDisposable handling (ObjectDisposedException after Dispose)</description></item>
/// </list>
/// </para>
/// <para>
/// <strong>COMPLIANCE-CRITICAL:</strong> IEncryptionProvider implements field-level encryption
/// with AES-256-GCM authenticated encryption:
/// <list type="bullet">
/// <item><description>EncryptAsync requires Active key status</description></item>
/// <item><description>DecryptAsync allows Active and DecryptOnly key status</description></item>
/// <item><description>Suspended/Destroyed keys throw EncryptionException with appropriate error codes</description></item>
/// <item><description>Round-trip: Encrypt â†’ Decrypt must return original plaintext</description></item>
/// </list>
/// </para>
/// </remarks>
/// <example>
/// <code>
/// public class AesGcmEncryptionProviderConformanceTests : EncryptionProviderConformanceTestKit
/// {
///     protected override async Task&lt;(IEncryptionProvider Provider, IKeyManagementProvider KeyManagement)&gt; CreateProviderAsync()
///     {
///         var keyManagement = new InMemoryKeyManagementProvider(
///             NullLogger&lt;InMemoryKeyManagementProvider&gt;.Instance,
///             new InMemoryKeyManagementOptions { AutoGenerateDefaultKey = false });
///
///         // Create a test key
///         await keyManagement.RotateKeyAsync("test-key", EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None);
///
///         var provider = new AesGcmEncryptionProvider(
///             keyManagement,
///             NullLogger&lt;AesGcmEncryptionProvider&gt;.Instance,
///             new AesGcmEncryptionOptions());
///
///         return (provider, keyManagement);
///     }
/// }
/// </code>
/// </example>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Naming", "CA1707:Identifiers should not contain underscores",
	Justification = "Test method naming convention")]
public abstract class EncryptionProviderConformanceTestKit
{
	/// <summary>
	/// Creates a fresh encryption provider instance along with its key management provider for testing.
	/// </summary>
	/// <returns>A tuple containing the IEncryptionProvider and IKeyManagementProvider to test.</returns>
	/// <remarks>
	/// <para>
	/// The key management provider is needed to create/rotate keys for testing.
	/// For AesGcmEncryptionProvider, use InMemoryKeyManagementProvider with AutoGenerateDefaultKey = false.
	/// </para>
	/// <para>
	/// You MUST create at least one key via RotateKeyAsync before encryption tests can work.
	/// </para>
	/// </remarks>
	protected abstract Task<(IEncryptionProvider Provider, IKeyManagementProvider KeyManagement)> CreateProviderAsync();

	/// <summary>
	/// Optional cleanup after each test.
	/// </summary>
	/// <returns>A task representing the cleanup operation.</returns>
	protected virtual Task CleanupAsync() => Task.CompletedTask;

	/// <summary>
	/// Generates test plaintext data.
	/// </summary>
	/// <param name="size">The size of the plaintext in bytes.</param>
	/// <returns>Random plaintext bytes.</returns>
	protected virtual byte[] GeneratePlaintext(int size = 256)
	{
		var plaintext = new byte[size];
		System.Security.Cryptography.RandomNumberGenerator.Fill(plaintext);
		return plaintext;
	}

	/// <summary>
	/// Generates a unique key ID for test isolation.
	/// </summary>
	/// <returns>A unique key identifier.</returns>
	protected virtual string GenerateKeyId() => $"test-key-{Guid.NewGuid():N}";

	#region Encrypt Tests

	/// <summary>
	/// Verifies that EncryptAsync throws ArgumentNullException for null plaintext.
	/// </summary>
	protected virtual async Task EncryptAsync_NullPlaintext_ShouldThrowArgumentNullException()
	{
		// Arrange
		var (provider, keyManagement) = await CreateProviderAsync().ConfigureAwait(false);
		try
		{
			var keyId = GenerateKeyId();
			_ = await keyManagement.RotateKeyAsync(keyId, EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None)
				.ConfigureAwait(false);

			// Act & Assert
			var caughtException = false;
			try
			{
				_ = await provider.EncryptAsync(null!, EncryptionContext.Default, CancellationToken.None).ConfigureAwait(false);
			}
			catch (ArgumentNullException)
			{
				caughtException = true;
			}

			if (!caughtException)
			{
				throw new TestFixtureAssertionException(
					"Expected EncryptAsync to throw ArgumentNullException for null plaintext.");
			}
		}
		finally
		{
			await CleanupAsync().ConfigureAwait(false);
			(provider as IDisposable)?.Dispose();
			(keyManagement as IDisposable)?.Dispose();
		}
	}

	/// <summary>
	/// Verifies that EncryptAsync populates all required EncryptedData metadata.
	/// </summary>
	protected virtual async Task EncryptAsync_ShouldPopulateEncryptedDataMetadata()
	{
		// Arrange
		var (provider, keyManagement) = await CreateProviderAsync().ConfigureAwait(false);
		try
		{
			var keyId = GenerateKeyId();
			_ = await keyManagement.RotateKeyAsync(keyId, EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None)
				.ConfigureAwait(false);

			var plaintext = GeneratePlaintext();

			// Act
			var encrypted = await provider.EncryptAsync(plaintext, EncryptionContext.Default, CancellationToken.None).ConfigureAwait(false);

			// Assert
			if (encrypted is null)
			{
				throw new TestFixtureAssertionException("Expected EncryptAsync to return EncryptedData.");
			}

			if (encrypted.Ciphertext is null || encrypted.Ciphertext.Length == 0)
			{
				throw new TestFixtureAssertionException("Expected Ciphertext to be populated.");
			}

			if (string.IsNullOrEmpty(encrypted.KeyId))
			{
				throw new TestFixtureAssertionException("Expected KeyId to be populated.");
			}

			if (encrypted.KeyVersion < 1)
			{
				throw new TestFixtureAssertionException($"Expected KeyVersion >= 1, but got {encrypted.KeyVersion}.");
			}

			if (encrypted.Algorithm != EncryptionAlgorithm.Aes256Gcm)
			{
				throw new TestFixtureAssertionException(
					$"Expected Algorithm to be Aes256Gcm, but got {encrypted.Algorithm}.");
			}

			if (encrypted.Iv is null || encrypted.Iv.Length != 12)
			{
				throw new TestFixtureAssertionException(
					$"Expected IV to be 12 bytes (96-bit nonce), but got {encrypted.Iv?.Length ?? 0} bytes.");
			}

			if (encrypted.AuthTag is null || encrypted.AuthTag.Length != 16)
			{
				throw new TestFixtureAssertionException(
					$"Expected AuthTag to be 16 bytes (128-bit), but got {encrypted.AuthTag?.Length ?? 0} bytes.");
			}
		}
		finally
		{
			await CleanupAsync().ConfigureAwait(false);
			(provider as IDisposable)?.Dispose();
			(keyManagement as IDisposable)?.Dispose();
		}
	}

	/// <summary>
	/// Verifies that EncryptAsync throws when no active key exists.
	/// </summary>
	protected virtual async Task EncryptAsync_NoActiveKey_ShouldThrowEncryptionException()
	{
		// Arrange
		var (provider, keyManagement) = await CreateProviderAsync().ConfigureAwait(false);
		try
		{
			// Don't create any key - should fail
			var plaintext = GeneratePlaintext();

			// Act & Assert
			var caughtException = false;
			EncryptionErrorCode? errorCode = null;
			try
			{
				_ = await provider.EncryptAsync(plaintext, EncryptionContext.Default, CancellationToken.None).ConfigureAwait(false);
			}
			catch (EncryptionException ex)
			{
				caughtException = true;
				errorCode = ex.ErrorCode;
			}

			if (!caughtException)
			{
				throw new TestFixtureAssertionException(
					"Expected EncryptAsync to throw EncryptionException when no active key exists.");
			}

			if (errorCode != EncryptionErrorCode.KeyNotFound)
			{
				throw new TestFixtureAssertionException(
					$"Expected ErrorCode KeyNotFound, but got {errorCode}.");
			}
		}
		finally
		{
			await CleanupAsync().ConfigureAwait(false);
			(provider as IDisposable)?.Dispose();
			(keyManagement as IDisposable)?.Dispose();
		}
	}

	/// <summary>
	/// Verifies that EncryptAsync throws when key is DecryptOnly.
	/// </summary>
	protected virtual async Task EncryptAsync_DecryptOnlyKey_ShouldThrowEncryptionException()
	{
		// Arrange
		var (provider, keyManagement) = await CreateProviderAsync().ConfigureAwait(false);
		try
		{
			var keyId = GenerateKeyId();

			// Create key v1, then rotate to v2 (v1 becomes DecryptOnly)
			_ = await keyManagement.RotateKeyAsync(keyId, EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None)
				.ConfigureAwait(false);
			_ = await keyManagement.RotateKeyAsync(keyId, EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None)
				.ConfigureAwait(false);

			var plaintext = GeneratePlaintext();

			// Try to encrypt with specific DecryptOnly version
			var context = new EncryptionContext { KeyId = keyId, KeyVersion = 1 };

			// Act & Assert
			var caughtException = false;
			EncryptionErrorCode? errorCode = null;
			try
			{
				_ = await provider.EncryptAsync(plaintext, context, CancellationToken.None).ConfigureAwait(false);
			}
			catch (EncryptionException ex)
			{
				caughtException = true;
				errorCode = ex.ErrorCode;
			}

			if (!caughtException)
			{
				throw new TestFixtureAssertionException(
					"Expected EncryptAsync to throw EncryptionException for DecryptOnly key.");
			}

			if (errorCode != EncryptionErrorCode.KeyExpired)
			{
				throw new TestFixtureAssertionException(
					$"Expected ErrorCode KeyExpired for DecryptOnly key, but got {errorCode}.");
			}
		}
		finally
		{
			await CleanupAsync().ConfigureAwait(false);
			(provider as IDisposable)?.Dispose();
			(keyManagement as IDisposable)?.Dispose();
		}
	}

	#endregion

	#region Decrypt Tests

	/// <summary>
	/// Verifies that DecryptAsync throws ArgumentNullException for null encryptedData.
	/// </summary>
	protected virtual async Task DecryptAsync_NullEncryptedData_ShouldThrowArgumentNullException()
	{
		// Arrange
		var (provider, keyManagement) = await CreateProviderAsync().ConfigureAwait(false);
		try
		{
			var keyId = GenerateKeyId();
			_ = await keyManagement.RotateKeyAsync(keyId, EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None)
				.ConfigureAwait(false);

			// Act & Assert
			var caughtException = false;
			try
			{
				_ = await provider.DecryptAsync(null!, EncryptionContext.Default, CancellationToken.None).ConfigureAwait(false);
			}
			catch (ArgumentNullException)
			{
				caughtException = true;
			}

			if (!caughtException)
			{
				throw new TestFixtureAssertionException(
					"Expected DecryptAsync to throw ArgumentNullException for null encryptedData.");
			}
		}
		finally
		{
			await CleanupAsync().ConfigureAwait(false);
			(provider as IDisposable)?.Dispose();
			(keyManagement as IDisposable)?.Dispose();
		}
	}

	/// <summary>
	/// Verifies that DecryptAsync throws for unsupported algorithm.
	/// </summary>
	protected virtual async Task DecryptAsync_UnsupportedAlgorithm_ShouldThrowEncryptionException()
	{
		// Arrange
		var (provider, keyManagement) = await CreateProviderAsync().ConfigureAwait(false);
		try
		{
			var keyId = GenerateKeyId();
			_ = await keyManagement.RotateKeyAsync(keyId, EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None)
				.ConfigureAwait(false);

			// Create fake encrypted data with wrong algorithm
			var fakeEncrypted = new EncryptedData
			{
				Ciphertext = new byte[32],
				KeyId = keyId,
				KeyVersion = 1,
				Algorithm = EncryptionAlgorithm.Aes256CbcHmac, // Not supported by AesGcmEncryptionProvider
				Iv = new byte[12],
				AuthTag = new byte[16]
			};

			// Act & Assert
			var caughtException = false;
			EncryptionErrorCode? errorCode = null;
			try
			{
				_ = await provider.DecryptAsync(fakeEncrypted, EncryptionContext.Default, CancellationToken.None).ConfigureAwait(false);
			}
			catch (EncryptionException ex)
			{
				caughtException = true;
				errorCode = ex.ErrorCode;
			}

			if (!caughtException)
			{
				throw new TestFixtureAssertionException(
					"Expected DecryptAsync to throw EncryptionException for unsupported algorithm.");
			}

			if (errorCode != EncryptionErrorCode.UnsupportedAlgorithm)
			{
				throw new TestFixtureAssertionException(
					$"Expected ErrorCode UnsupportedAlgorithm, but got {errorCode}.");
			}
		}
		finally
		{
			await CleanupAsync().ConfigureAwait(false);
			(provider as IDisposable)?.Dispose();
			(keyManagement as IDisposable)?.Dispose();
		}
	}

	/// <summary>
	/// Verifies that DecryptAsync throws when key is suspended.
	/// </summary>
	protected virtual async Task DecryptAsync_SuspendedKey_ShouldThrowEncryptionException()
	{
		// Arrange
		var (provider, keyManagement) = await CreateProviderAsync().ConfigureAwait(false);
		try
		{
			var keyId = GenerateKeyId();
			_ = await keyManagement.RotateKeyAsync(keyId, EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None)
				.ConfigureAwait(false);

			// Encrypt first
			var plaintext = GeneratePlaintext();
			var encrypted = await provider.EncryptAsync(plaintext, EncryptionContext.Default, CancellationToken.None).ConfigureAwait(false);

			// Suspend the key
			_ = await keyManagement.SuspendKeyAsync(keyId, "test-suspension", CancellationToken.None).ConfigureAwait(false);

			// Act & Assert
			var caughtException = false;
			EncryptionErrorCode? errorCode = null;
			try
			{
				_ = await provider.DecryptAsync(encrypted, EncryptionContext.Default, CancellationToken.None).ConfigureAwait(false);
			}
			catch (EncryptionException ex)
			{
				caughtException = true;
				errorCode = ex.ErrorCode;
			}

			if (!caughtException)
			{
				throw new TestFixtureAssertionException(
					"Expected DecryptAsync to throw EncryptionException for suspended key.");
			}

			if (errorCode != EncryptionErrorCode.KeySuspended)
			{
				throw new TestFixtureAssertionException(
					$"Expected ErrorCode KeySuspended, but got {errorCode}.");
			}
		}
		finally
		{
			await CleanupAsync().ConfigureAwait(false);
			(provider as IDisposable)?.Dispose();
			(keyManagement as IDisposable)?.Dispose();
		}
	}

	/// <summary>
	/// Verifies that DecryptAsync throws for non-existent key.
	/// </summary>
	protected virtual async Task DecryptAsync_NonExistentKey_ShouldThrowEncryptionException()
	{
		// Arrange
		var (provider, keyManagement) = await CreateProviderAsync().ConfigureAwait(false);
		try
		{
			// Create fake encrypted data with non-existent key
			var fakeEncrypted = new EncryptedData
			{
				Ciphertext = new byte[32],
				KeyId = "non-existent-key",
				KeyVersion = 1,
				Algorithm = EncryptionAlgorithm.Aes256Gcm,
				Iv = new byte[12],
				AuthTag = new byte[16]
			};

			// Act & Assert
			var caughtException = false;
			EncryptionErrorCode? errorCode = null;
			try
			{
				_ = await provider.DecryptAsync(fakeEncrypted, EncryptionContext.Default, CancellationToken.None).ConfigureAwait(false);
			}
			catch (EncryptionException ex)
			{
				caughtException = true;
				errorCode = ex.ErrorCode;
			}

			if (!caughtException)
			{
				throw new TestFixtureAssertionException(
					"Expected DecryptAsync to throw EncryptionException for non-existent key.");
			}

			if (errorCode != EncryptionErrorCode.KeyNotFound)
			{
				throw new TestFixtureAssertionException(
					$"Expected ErrorCode KeyNotFound, but got {errorCode}.");
			}
		}
		finally
		{
			await CleanupAsync().ConfigureAwait(false);
			(provider as IDisposable)?.Dispose();
			(keyManagement as IDisposable)?.Dispose();
		}
	}

	#endregion

	#region Round-Trip Tests

	/// <summary>
	/// Verifies that encrypt then decrypt returns the original plaintext.
	/// </summary>
	protected virtual async Task RoundTrip_EncryptDecrypt_ShouldReturnOriginalPlaintext()
	{
		// Arrange
		var (provider, keyManagement) = await CreateProviderAsync().ConfigureAwait(false);
		try
		{
			var keyId = GenerateKeyId();
			_ = await keyManagement.RotateKeyAsync(keyId, EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None)
				.ConfigureAwait(false);

			var originalPlaintext = GeneratePlaintext();

			// Act
			var encrypted = await provider.EncryptAsync(originalPlaintext, EncryptionContext.Default, CancellationToken.None)
				.ConfigureAwait(false);
			var decrypted = await provider.DecryptAsync(encrypted, EncryptionContext.Default, CancellationToken.None).ConfigureAwait(false);

			// Assert
			if (decrypted is null)
			{
				throw new TestFixtureAssertionException("Expected DecryptAsync to return plaintext.");
			}

			if (decrypted.Length != originalPlaintext.Length)
			{
				throw new TestFixtureAssertionException(
					$"Expected decrypted length {originalPlaintext.Length}, but got {decrypted.Length}.");
			}

			for (var i = 0; i < originalPlaintext.Length; i++)
			{
				if (decrypted[i] != originalPlaintext[i])
				{
					throw new TestFixtureAssertionException(
						$"Decrypted data differs from original at position {i}.");
				}
			}
		}
		finally
		{
			await CleanupAsync().ConfigureAwait(false);
			(provider as IDisposable)?.Dispose();
			(keyManagement as IDisposable)?.Dispose();
		}
	}

	/// <summary>
	/// Verifies that encrypt then decrypt works with text data.
	/// </summary>
	protected virtual async Task RoundTrip_TextData_ShouldPreserveContent()
	{
		// Arrange
		var (provider, keyManagement) = await CreateProviderAsync().ConfigureAwait(false);
		try
		{
			var keyId = GenerateKeyId();
			_ = await keyManagement.RotateKeyAsync(keyId, EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None)
				.ConfigureAwait(false);

			var originalText = "Hello, World! This is a test of AES-256-GCM encryption.";
			var originalPlaintext = Encoding.UTF8.GetBytes(originalText);

			// Act
			var encrypted = await provider.EncryptAsync(originalPlaintext, EncryptionContext.Default, CancellationToken.None)
				.ConfigureAwait(false);
			var decrypted = await provider.DecryptAsync(encrypted, EncryptionContext.Default, CancellationToken.None).ConfigureAwait(false);

			// Assert
			var decryptedText = Encoding.UTF8.GetString(decrypted);
			if (decryptedText != originalText)
			{
				throw new TestFixtureAssertionException(
					$"Expected '{originalText}', but got '{decryptedText}'.");
			}
		}
		finally
		{
			await CleanupAsync().ConfigureAwait(false);
			(provider as IDisposable)?.Dispose();
			(keyManagement as IDisposable)?.Dispose();
		}
	}

	/// <summary>
	/// Verifies that decrypt still works after key rotation (using DecryptOnly version).
	/// </summary>
	protected virtual async Task RoundTrip_AfterKeyRotation_ShouldStillDecrypt()
	{
		// Arrange
		var (provider, keyManagement) = await CreateProviderAsync().ConfigureAwait(false);
		try
		{
			var keyId = GenerateKeyId();
			_ = await keyManagement.RotateKeyAsync(keyId, EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None)
				.ConfigureAwait(false);

			// Encrypt with v1
			var originalPlaintext = GeneratePlaintext();
			var encrypted = await provider.EncryptAsync(
				originalPlaintext,
				new EncryptionContext { KeyId = keyId },
				CancellationToken.None).ConfigureAwait(false);

			// Rotate key to v2 (v1 becomes DecryptOnly)
			_ = await keyManagement.RotateKeyAsync(keyId, EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None)
				.ConfigureAwait(false);

			// Verify v1 is now DecryptOnly
			var v1Metadata = await keyManagement.GetKeyVersionAsync(keyId, 1, CancellationToken.None).ConfigureAwait(false);
			if (v1Metadata?.Status != KeyStatus.DecryptOnly)
			{
				throw new TestFixtureAssertionException(
					$"Expected v1 to be DecryptOnly after rotation, but got {v1Metadata?.Status}.");
			}

			// Act - decrypt should still work with the encrypted data
			var decrypted = await provider.DecryptAsync(encrypted, EncryptionContext.Default, CancellationToken.None).ConfigureAwait(false);

			// Assert
			if (decrypted.Length != originalPlaintext.Length)
			{
				throw new TestFixtureAssertionException(
					$"Expected decrypted length {originalPlaintext.Length}, but got {decrypted.Length}.");
			}

			for (var i = 0; i < originalPlaintext.Length; i++)
			{
				if (decrypted[i] != originalPlaintext[i])
				{
					throw new TestFixtureAssertionException(
						$"Decrypted data differs from original at position {i}.");
				}
			}
		}
		finally
		{
			await CleanupAsync().ConfigureAwait(false);
			(provider as IDisposable)?.Dispose();
			(keyManagement as IDisposable)?.Dispose();
		}
	}

	#endregion

	#region ValidateFipsCompliance Tests

	/// <summary>
	/// Verifies that ValidateFipsComplianceAsync returns a boolean.
	/// </summary>
	protected virtual async Task ValidateFipsComplianceAsync_ShouldReturnBoolean()
	{
		// Arrange
		var (provider, keyManagement) = await CreateProviderAsync().ConfigureAwait(false);
		try
		{
			// Act
			var result = await provider.ValidateFipsComplianceAsync(CancellationToken.None).ConfigureAwait(false);

			// Assert - just verify it returns without throwing
			// The actual value depends on the system's FIPS configuration
			_ = result; // Use the result to avoid compiler warning
		}
		finally
		{
			await CleanupAsync().ConfigureAwait(false);
			(provider as IDisposable)?.Dispose();
			(keyManagement as IDisposable)?.Dispose();
		}
	}

	#endregion

	#region Disposable Tests

	/// <summary>
	/// Verifies that disposed provider throws ObjectDisposedException.
	/// </summary>
	protected virtual async Task Disposed_Provider_ShouldThrowObjectDisposedException()
	{
		// Arrange
		var (provider, keyManagement) = await CreateProviderAsync().ConfigureAwait(false);
		var keyId = GenerateKeyId();
		_ = await keyManagement.RotateKeyAsync(keyId, EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None)
			.ConfigureAwait(false);

		try
		{
			// Dispose the provider
			(provider as IDisposable)?.Dispose();

			// Act & Assert
			var caughtException = false;
			try
			{
				_ = await provider.EncryptAsync(new byte[32], EncryptionContext.Default, CancellationToken.None).ConfigureAwait(false);
			}
			catch (ObjectDisposedException)
			{
				caughtException = true;
			}

			// Note: Only IDisposable implementations are required to throw
			if (provider is IDisposable && !caughtException)
			{
				throw new TestFixtureAssertionException(
					"Expected disposed provider to throw ObjectDisposedException.");
			}
		}
		finally
		{
			await CleanupAsync().ConfigureAwait(false);
			(keyManagement as IDisposable)?.Dispose();
		}
	}

	#endregion
}
