// SPDX-FileCopyrightText: Copyright (c) 2026 The Excalibur Project
// SPDX-License-Identifier: LicenseRef-Excalibur-1.0 OR AGPL-3.0-or-later OR SSPL-1.0 OR Apache-2.0


#pragma warning disable IDE0270 // Null check can be simplified

using Excalibur.Dispatch.Compliance;

namespace Excalibur.Testing.Conformance;

/// <summary>
/// Abstract base class for IKeyManagementProvider conformance testing.
/// </summary>
/// <remarks>
/// <para>
/// Inherit from this class and implement <see cref="CreateProvider"/> to verify that
/// your key management provider implementation conforms to the IKeyManagementProvider contract.
/// </para>
/// <para>
/// The test kit verifies core key management operations including:
/// <list type="bullet">
/// <item><description>Key creation via RotateKeyAsync (first call creates new key)</description></item>
/// <item><description>Key rotation with version management (creates new version, marks old as DecryptOnly)</description></item>
/// <item><description>Key retrieval by ID and by version</description></item>
/// <item><description>Key listing with status and purpose filtering</description></item>
/// <item><description>Key deletion with retention period (crypto-shredding for GDPR)</description></item>
/// <item><description>Key suspension for security incidents</description></item>
/// <item><description>Active key retrieval with purpose filtering</description></item>
/// </list>
/// </para>
/// <para>
/// <strong>COMPLIANCE-CRITICAL:</strong> IKeyManagementProvider implements key lifecycle management
/// for encryption and GDPR Right to Erasure via crypto-shredding:
/// <list type="bullet">
/// <item><description>Keys follow lifecycle: Active → DecryptOnly → PendingDestruction → Destroyed</description></item>
/// <item><description>RotateKeyAsync creates new version, does NOT throw on existing key</description></item>
/// <item><description>DeleteKeyAsync schedules deletion with retention period (crypto-shredding)</description></item>
/// <item><description>SuspendKeyAsync immediately prevents key usage for security incidents</description></item>
/// <item><description>IDisposable implementations must securely clear key material</description></item>
/// </list>
/// </para>
/// </remarks>
/// <example>
/// <code>
/// public class SqlServerKeyManagementProviderConformanceTests : KeyManagementProviderConformanceTestKit
/// {
///     private readonly SqlServerFixture _fixture;
///
///     protected override IKeyManagementProvider CreateProvider() =&gt;
///         new SqlServerKeyManagementProvider(_fixture.ConnectionString);
///
///     protected override async Task CleanupAsync() =&gt;
///         await _fixture.CleanupAsync();
/// }
/// </code>
/// </example>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Naming", "CA1707:Identifiers should not contain underscores",
	Justification = "Test method naming convention")]
public abstract class KeyManagementProviderConformanceTestKit
{
	/// <summary>
	/// Creates a fresh key management provider instance for testing.
	/// </summary>
	/// <returns>An IKeyManagementProvider implementation to test.</returns>
	/// <remarks>
	/// <para>
	/// For InMemoryKeyManagementProvider, configure with AutoGenerateDefaultKey = false
	/// to ensure test isolation:
	/// </para>
	/// <code>
	/// protected override IKeyManagementProvider CreateProvider() =>
	///     new InMemoryKeyManagementProvider(
	///         NullLogger&lt;InMemoryKeyManagementProvider&gt;.Instance,
	///         new InMemoryKeyManagementOptions { AutoGenerateDefaultKey = false });
	/// </code>
	/// </remarks>
	protected abstract IKeyManagementProvider CreateProvider();

	/// <summary>
	/// Optional cleanup after each test.
	/// </summary>
	/// <returns>A task representing the cleanup operation.</returns>
	protected virtual Task CleanupAsync() => Task.CompletedTask;

	/// <summary>
	/// Generates a unique key ID for test isolation.
	/// </summary>
	/// <returns>A unique key identifier.</returns>
	protected virtual string GenerateKeyId() => $"test-key-{Guid.NewGuid():N}";

	#region GetKey Tests

	/// <summary>
	/// Verifies that GetKeyAsync returns null for non-existent key.
	/// </summary>
	protected virtual async Task GetKeyAsync_NonExistent_ShouldReturnNull()
	{
		// Arrange
		var provider = CreateProvider();
		try
		{
			// Act
			var result = await provider.GetKeyAsync("non-existent-key", CancellationToken.None).ConfigureAwait(false);

			// Assert
			if (result is not null)
			{
				throw new TestFixtureAssertionException(
					"Expected GetKeyAsync to return null for non-existent key, but got a result.");
			}
		}
		finally
		{
			await CleanupAsync().ConfigureAwait(false);
			(provider as IDisposable)?.Dispose();
		}
	}

	/// <summary>
	/// Verifies that GetKeyAsync throws ArgumentException for null or empty keyId.
	/// </summary>
	protected virtual async Task GetKeyAsync_NullKeyId_ShouldThrowArgumentException()
	{
		// Arrange
		var provider = CreateProvider();
		try
		{
			// Act & Assert
			var caughtException = false;
			try
			{
				_ = await provider.GetKeyAsync(null!, CancellationToken.None).ConfigureAwait(false);
			}
			catch (ArgumentException)
			{
				caughtException = true;
			}

			if (!caughtException)
			{
				throw new TestFixtureAssertionException(
					"Expected GetKeyAsync to throw ArgumentException for null keyId.");
			}
		}
		finally
		{
			await CleanupAsync().ConfigureAwait(false);
			(provider as IDisposable)?.Dispose();
		}
	}

	/// <summary>
	/// Verifies that GetKeyAsync returns the latest version of a key.
	/// </summary>
	protected virtual async Task GetKeyAsync_ExistingKey_ShouldReturnLatestVersion()
	{
		// Arrange
		var provider = CreateProvider();
		try
		{
			var keyId = GenerateKeyId();

			// Create key (version 1)
			var createResult = await provider.RotateKeyAsync(
				keyId,
				EncryptionAlgorithm.Aes256Gcm,
				purpose: "test-purpose",
				expiresAt: null,
				CancellationToken.None).ConfigureAwait(false);

			if (!createResult.Success)
			{
				throw new TestFixtureAssertionException($"Failed to create key: {createResult.ErrorMessage}");
			}

			// Rotate to version 2
			var rotateResult = await provider.RotateKeyAsync(
				keyId,
				EncryptionAlgorithm.Aes256Gcm,
				purpose: "test-purpose",
				expiresAt: null,
				CancellationToken.None).ConfigureAwait(false);

			if (!rotateResult.Success)
			{
				throw new TestFixtureAssertionException($"Failed to rotate key: {rotateResult.ErrorMessage}");
			}

			// Act
			var result = await provider.GetKeyAsync(keyId, CancellationToken.None).ConfigureAwait(false);

			// Assert
			if (result is null)
			{
				throw new TestFixtureAssertionException("Expected GetKeyAsync to return key metadata.");
			}

			if (result.Version != 2)
			{
				throw new TestFixtureAssertionException(
					$"Expected GetKeyAsync to return version 2, but got version {result.Version}.");
			}

			if (result.Status != KeyStatus.Active)
			{
				throw new TestFixtureAssertionException(
					$"Expected latest version to be Active, but got {result.Status}.");
			}
		}
		finally
		{
			await CleanupAsync().ConfigureAwait(false);
			(provider as IDisposable)?.Dispose();
		}
	}

	#endregion

	#region GetKeyVersion Tests

	/// <summary>
	/// Verifies that GetKeyVersionAsync returns null for non-existent version.
	/// </summary>
	protected virtual async Task GetKeyVersionAsync_NonExistentVersion_ShouldReturnNull()
	{
		// Arrange
		var provider = CreateProvider();
		try
		{
			var keyId = GenerateKeyId();

			// Create key (version 1)
			_ = await provider.RotateKeyAsync(
				keyId,
				EncryptionAlgorithm.Aes256Gcm,
				purpose: null,
				expiresAt: null,
				CancellationToken.None).ConfigureAwait(false);

			// Act
			var result = await provider.GetKeyVersionAsync(keyId, 999, CancellationToken.None).ConfigureAwait(false);

			// Assert
			if (result is not null)
			{
				throw new TestFixtureAssertionException(
					"Expected GetKeyVersionAsync to return null for non-existent version.");
			}
		}
		finally
		{
			await CleanupAsync().ConfigureAwait(false);
			(provider as IDisposable)?.Dispose();
		}
	}

	/// <summary>
	/// Verifies that GetKeyVersionAsync returns the correct version metadata.
	/// </summary>
	protected virtual async Task GetKeyVersionAsync_ExistingVersion_ShouldReturnCorrectMetadata()
	{
		// Arrange
		var provider = CreateProvider();
		try
		{
			var keyId = GenerateKeyId();

			// Create key (version 1)
			_ = await provider.RotateKeyAsync(
				keyId,
				EncryptionAlgorithm.Aes256Gcm,
				purpose: "encryption",
				expiresAt: null,
				CancellationToken.None).ConfigureAwait(false);

			// Rotate to version 2
			_ = await provider.RotateKeyAsync(
				keyId,
				EncryptionAlgorithm.Aes256Gcm,
				purpose: "encryption",
				expiresAt: null,
				CancellationToken.None).ConfigureAwait(false);

			// Act - get version 1
			var result = await provider.GetKeyVersionAsync(keyId, 1, CancellationToken.None).ConfigureAwait(false);

			// Assert
			if (result is null)
			{
				throw new TestFixtureAssertionException("Expected GetKeyVersionAsync to return key metadata.");
			}

			if (result.Version != 1)
			{
				throw new TestFixtureAssertionException(
					$"Expected version 1, but got version {result.Version}.");
			}

			if (result.Status != KeyStatus.DecryptOnly)
			{
				throw new TestFixtureAssertionException(
					$"Expected version 1 to be DecryptOnly after rotation, but got {result.Status}.");
			}
		}
		finally
		{
			await CleanupAsync().ConfigureAwait(false);
			(provider as IDisposable)?.Dispose();
		}
	}

	#endregion

	#region ListKeys Tests

	/// <summary>
	/// Verifies that ListKeysAsync returns empty list when no keys exist.
	/// </summary>
	protected virtual async Task ListKeysAsync_NoKeys_ShouldReturnEmptyList()
	{
		// Arrange
		var provider = CreateProvider();
		try
		{
			// Act
			var result = await provider.ListKeysAsync(null, null, CancellationToken.None).ConfigureAwait(false);

			// Assert
			if (result is null)
			{
				throw new TestFixtureAssertionException("Expected ListKeysAsync to return a list, not null.");
			}

			if (result.Count != 0)
			{
				throw new TestFixtureAssertionException(
					$"Expected empty list when no keys exist, but got {result.Count} keys.");
			}
		}
		finally
		{
			await CleanupAsync().ConfigureAwait(false);
			(provider as IDisposable)?.Dispose();
		}
	}

	/// <summary>
	/// Verifies that ListKeysAsync filters by status correctly.
	/// </summary>
	protected virtual async Task ListKeysAsync_FilterByStatus_ShouldFilterCorrectly()
	{
		// Arrange
		var provider = CreateProvider();
		try
		{
			var keyId1 = GenerateKeyId();
			var keyId2 = GenerateKeyId();

			// Create two active keys
			_ = await provider.RotateKeyAsync(keyId1, EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None)
				.ConfigureAwait(false);
			_ = await provider.RotateKeyAsync(keyId2, EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None)
				.ConfigureAwait(false);

			// Suspend one key
			_ = await provider.SuspendKeyAsync(keyId1, "test-suspension", CancellationToken.None).ConfigureAwait(false);

			// Act - filter by Active
			var activeKeys = await provider.ListKeysAsync(KeyStatus.Active, null, CancellationToken.None).ConfigureAwait(false);

			// Assert
			if (activeKeys.Count != 1)
			{
				throw new TestFixtureAssertionException(
					$"Expected 1 active key, but got {activeKeys.Count}.");
			}

			if (activeKeys[0].KeyId != keyId2)
			{
				throw new TestFixtureAssertionException(
					$"Expected active key to be {keyId2}, but got {activeKeys[0].KeyId}.");
			}
		}
		finally
		{
			await CleanupAsync().ConfigureAwait(false);
			(provider as IDisposable)?.Dispose();
		}
	}

	/// <summary>
	/// Verifies that ListKeysAsync filters by purpose correctly.
	/// </summary>
	protected virtual async Task ListKeysAsync_FilterByPurpose_ShouldFilterCorrectly()
	{
		// Arrange
		var provider = CreateProvider();
		try
		{
			var keyId1 = GenerateKeyId();
			var keyId2 = GenerateKeyId();

			// Create keys with different purposes
			_ = await provider.RotateKeyAsync(keyId1, EncryptionAlgorithm.Aes256Gcm, "encryption", null, CancellationToken.None)
				.ConfigureAwait(false);
			_ = await provider.RotateKeyAsync(keyId2, EncryptionAlgorithm.Aes256Gcm, "signing", null, CancellationToken.None)
				.ConfigureAwait(false);

			// Act - filter by purpose
			var encryptionKeys = await provider.ListKeysAsync(null, "encryption", CancellationToken.None).ConfigureAwait(false);

			// Assert
			if (encryptionKeys.Count != 1)
			{
				throw new TestFixtureAssertionException(
					$"Expected 1 key with purpose 'encryption', but got {encryptionKeys.Count}.");
			}

			if (encryptionKeys[0].KeyId != keyId1)
			{
				throw new TestFixtureAssertionException(
					$"Expected key {keyId1}, but got {encryptionKeys[0].KeyId}.");
			}
		}
		finally
		{
			await CleanupAsync().ConfigureAwait(false);
			(provider as IDisposable)?.Dispose();
		}
	}

	#endregion

	#region RotateKey Tests

	/// <summary>
	/// Verifies that RotateKeyAsync creates a new key when one doesn't exist.
	/// </summary>
	protected virtual async Task RotateKeyAsync_NewKey_ShouldCreateVersion1()
	{
		// Arrange
		var provider = CreateProvider();
		try
		{
			var keyId = GenerateKeyId();

			// Act
			var result = await provider.RotateKeyAsync(
				keyId,
				EncryptionAlgorithm.Aes256Gcm,
				purpose: "test",
				expiresAt: DateTimeOffset.UtcNow.AddDays(30),
				CancellationToken.None).ConfigureAwait(false);

			// Assert
			if (!result.Success)
			{
				throw new TestFixtureAssertionException($"Expected RotateKeyAsync to succeed: {result.ErrorMessage}");
			}

			if (result.NewKey is null)
			{
				throw new TestFixtureAssertionException("Expected NewKey to be populated.");
			}

			if (result.NewKey.Version != 1)
			{
				throw new TestFixtureAssertionException(
					$"Expected new key to be version 1, but got {result.NewKey.Version}.");
			}

			if (result.NewKey.Status != KeyStatus.Active)
			{
				throw new TestFixtureAssertionException(
					$"Expected new key to be Active, but got {result.NewKey.Status}.");
			}

			if (result.PreviousKey is not null)
			{
				throw new TestFixtureAssertionException(
					"Expected PreviousKey to be null for new key creation.");
			}
		}
		finally
		{
			await CleanupAsync().ConfigureAwait(false);
			(provider as IDisposable)?.Dispose();
		}
	}

	/// <summary>
	/// Verifies that RotateKeyAsync increments version and marks old as DecryptOnly.
	/// </summary>
	protected virtual async Task RotateKeyAsync_ExistingKey_ShouldCreateNewVersionAndMarkOldDecryptOnly()
	{
		// Arrange
		var provider = CreateProvider();
		try
		{
			var keyId = GenerateKeyId();

			// Create key (version 1)
			_ = await provider.RotateKeyAsync(keyId, EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None)
				.ConfigureAwait(false);

			// Act - rotate to version 2
			var result = await provider.RotateKeyAsync(
				keyId,
				EncryptionAlgorithm.Aes256Gcm,
				purpose: null,
				expiresAt: null,
				CancellationToken.None).ConfigureAwait(false);

			// Assert
			if (!result.Success)
			{
				throw new TestFixtureAssertionException($"Expected rotation to succeed: {result.ErrorMessage}");
			}

			if (result.NewKey is null)
			{
				throw new TestFixtureAssertionException("Expected NewKey to be populated.");
			}

			if (result.NewKey.Version != 2)
			{
				throw new TestFixtureAssertionException(
					$"Expected new key to be version 2, but got {result.NewKey.Version}.");
			}

			if (result.PreviousKey is null)
			{
				throw new TestFixtureAssertionException("Expected PreviousKey to be populated for rotation.");
			}

			if (result.PreviousKey.Version != 1)
			{
				throw new TestFixtureAssertionException(
					$"Expected previous key to be version 1, but got {result.PreviousKey.Version}.");
			}

			// Verify previous version is now DecryptOnly
			var v1Metadata = await provider.GetKeyVersionAsync(keyId, 1, CancellationToken.None).ConfigureAwait(false);
			if (v1Metadata is null)
			{
				throw new TestFixtureAssertionException("Expected version 1 to still exist.");
			}

			if (v1Metadata.Status != KeyStatus.DecryptOnly)
			{
				throw new TestFixtureAssertionException(
					$"Expected version 1 to be DecryptOnly, but got {v1Metadata.Status}.");
			}
		}
		finally
		{
			await CleanupAsync().ConfigureAwait(false);
			(provider as IDisposable)?.Dispose();
		}
	}

	/// <summary>
	/// Verifies that RotateKeyAsync throws for null keyId.
	/// </summary>
	protected virtual async Task RotateKeyAsync_NullKeyId_ShouldThrowArgumentException()
	{
		// Arrange
		var provider = CreateProvider();
		try
		{
			// Act & Assert
			var caughtException = false;
			try
			{
				_ = await provider.RotateKeyAsync(null!, EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None)
					.ConfigureAwait(false);
			}
			catch (ArgumentException)
			{
				caughtException = true;
			}

			if (!caughtException)
			{
				throw new TestFixtureAssertionException(
					"Expected RotateKeyAsync to throw ArgumentException for null keyId.");
			}
		}
		finally
		{
			await CleanupAsync().ConfigureAwait(false);
			(provider as IDisposable)?.Dispose();
		}
	}

	#endregion

	#region DeleteKey Tests

	/// <summary>
	/// Verifies that DeleteKeyAsync returns false for non-existent key.
	/// </summary>
	protected virtual async Task DeleteKeyAsync_NonExistent_ShouldReturnFalse()
	{
		// Arrange
		var provider = CreateProvider();
		try
		{
			// Act
			var result = await provider.DeleteKeyAsync("non-existent-key", 30, CancellationToken.None).ConfigureAwait(false);

			// Assert
			if (result)
			{
				throw new TestFixtureAssertionException(
					"Expected DeleteKeyAsync to return false for non-existent key.");
			}
		}
		finally
		{
			await CleanupAsync().ConfigureAwait(false);
			(provider as IDisposable)?.Dispose();
		}
	}

	/// <summary>
	/// Verifies that DeleteKeyAsync schedules key for deletion (crypto-shredding).
	/// </summary>
	protected virtual async Task DeleteKeyAsync_ExistingKey_ShouldScheduleForDestruction()
	{
		// Arrange
		var provider = CreateProvider();
		try
		{
			var keyId = GenerateKeyId();

			// Create key
			_ = await provider.RotateKeyAsync(keyId, EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None)
				.ConfigureAwait(false);

			// Act
			var result = await provider.DeleteKeyAsync(keyId, 30, CancellationToken.None).ConfigureAwait(false);

			// Assert
			if (!result)
			{
				throw new TestFixtureAssertionException("Expected DeleteKeyAsync to return true.");
			}

			// Verify key is now PendingDestruction
			var metadata = await provider.GetKeyAsync(keyId, CancellationToken.None).ConfigureAwait(false);
			if (metadata is null)
			{
				throw new TestFixtureAssertionException("Expected key to still exist (pending destruction).");
			}

			if (metadata.Status != KeyStatus.PendingDestruction)
			{
				throw new TestFixtureAssertionException(
					$"Expected key status to be PendingDestruction, but got {metadata.Status}.");
			}
		}
		finally
		{
			await CleanupAsync().ConfigureAwait(false);
			(provider as IDisposable)?.Dispose();
		}
	}

	#endregion

	#region SuspendKey Tests

	/// <summary>
	/// Verifies that SuspendKeyAsync returns false for non-existent key.
	/// </summary>
	protected virtual async Task SuspendKeyAsync_NonExistent_ShouldReturnFalse()
	{
		// Arrange
		var provider = CreateProvider();
		try
		{
			// Act
			var result = await provider.SuspendKeyAsync("non-existent-key", "security-reason", CancellationToken.None)
				.ConfigureAwait(false);

			// Assert
			if (result)
			{
				throw new TestFixtureAssertionException(
					"Expected SuspendKeyAsync to return false for non-existent key.");
			}
		}
		finally
		{
			await CleanupAsync().ConfigureAwait(false);
			(provider as IDisposable)?.Dispose();
		}
	}

	/// <summary>
	/// Verifies that SuspendKeyAsync suspends all versions of a key.
	/// </summary>
	protected virtual async Task SuspendKeyAsync_ExistingKey_ShouldSuspendAllVersions()
	{
		// Arrange
		var provider = CreateProvider();
		try
		{
			var keyId = GenerateKeyId();

			// Create key and rotate to have multiple versions
			_ = await provider.RotateKeyAsync(keyId, EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None)
				.ConfigureAwait(false);
			_ = await provider.RotateKeyAsync(keyId, EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None)
				.ConfigureAwait(false);

			// Act
			var result = await provider.SuspendKeyAsync(keyId, "security-incident", CancellationToken.None).ConfigureAwait(false);

			// Assert
			if (!result)
			{
				throw new TestFixtureAssertionException("Expected SuspendKeyAsync to return true.");
			}

			// Verify all versions are suspended
			var v1Metadata = await provider.GetKeyVersionAsync(keyId, 1, CancellationToken.None).ConfigureAwait(false);
			var v2Metadata = await provider.GetKeyVersionAsync(keyId, 2, CancellationToken.None).ConfigureAwait(false);

			if (v1Metadata is null || v2Metadata is null)
			{
				throw new TestFixtureAssertionException("Expected both versions to exist.");
			}

			if (v1Metadata.Status != KeyStatus.Suspended)
			{
				throw new TestFixtureAssertionException(
					$"Expected version 1 to be Suspended, but got {v1Metadata.Status}.");
			}

			if (v2Metadata.Status != KeyStatus.Suspended)
			{
				throw new TestFixtureAssertionException(
					$"Expected version 2 to be Suspended, but got {v2Metadata.Status}.");
			}
		}
		finally
		{
			await CleanupAsync().ConfigureAwait(false);
			(provider as IDisposable)?.Dispose();
		}
	}

	/// <summary>
	/// Verifies that SuspendKeyAsync throws for null/empty reason.
	/// </summary>
	protected virtual async Task SuspendKeyAsync_NullReason_ShouldThrowArgumentException()
	{
		// Arrange
		var provider = CreateProvider();
		try
		{
			var keyId = GenerateKeyId();
			_ = await provider.RotateKeyAsync(keyId, EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None)
				.ConfigureAwait(false);

			// Act & Assert
			var caughtException = false;
			try
			{
				_ = await provider.SuspendKeyAsync(keyId, null!, CancellationToken.None).ConfigureAwait(false);
			}
			catch (ArgumentException)
			{
				caughtException = true;
			}

			if (!caughtException)
			{
				throw new TestFixtureAssertionException(
					"Expected SuspendKeyAsync to throw ArgumentException for null reason.");
			}
		}
		finally
		{
			await CleanupAsync().ConfigureAwait(false);
			(provider as IDisposable)?.Dispose();
		}
	}

	#endregion

	#region GetActiveKey Tests

	/// <summary>
	/// Verifies that GetActiveKeyAsync returns null when no active key exists.
	/// </summary>
	protected virtual async Task GetActiveKeyAsync_NoActiveKey_ShouldReturnNull()
	{
		// Arrange
		var provider = CreateProvider();
		try
		{
			// Act
			var result = await provider.GetActiveKeyAsync(null, CancellationToken.None).ConfigureAwait(false);

			// Assert
			if (result is not null)
			{
				throw new TestFixtureAssertionException(
					"Expected GetActiveKeyAsync to return null when no active key exists.");
			}
		}
		finally
		{
			await CleanupAsync().ConfigureAwait(false);
			(provider as IDisposable)?.Dispose();
		}
	}

	/// <summary>
	/// Verifies that GetActiveKeyAsync returns the active key.
	/// </summary>
	protected virtual async Task GetActiveKeyAsync_ActiveKeyExists_ShouldReturnActiveKey()
	{
		// Arrange
		var provider = CreateProvider();
		try
		{
			var keyId = GenerateKeyId();

			// Create key
			_ = await provider.RotateKeyAsync(keyId, EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None)
				.ConfigureAwait(false);

			// Act
			var result = await provider.GetActiveKeyAsync(null, CancellationToken.None).ConfigureAwait(false);

			// Assert
			if (result is null)
			{
				throw new TestFixtureAssertionException("Expected GetActiveKeyAsync to return an active key.");
			}

			if (result.KeyId != keyId)
			{
				throw new TestFixtureAssertionException(
					$"Expected active key to be {keyId}, but got {result.KeyId}.");
			}

			if (result.Status != KeyStatus.Active)
			{
				throw new TestFixtureAssertionException(
					$"Expected key status to be Active, but got {result.Status}.");
			}
		}
		finally
		{
			await CleanupAsync().ConfigureAwait(false);
			(provider as IDisposable)?.Dispose();
		}
	}

	/// <summary>
	/// Verifies that GetActiveKeyAsync filters by purpose.
	/// </summary>
	protected virtual async Task GetActiveKeyAsync_FilterByPurpose_ShouldFilterCorrectly()
	{
		// Arrange
		var provider = CreateProvider();
		try
		{
			var keyId1 = GenerateKeyId();
			var keyId2 = GenerateKeyId();

			// Create keys with different purposes
			_ = await provider.RotateKeyAsync(keyId1, EncryptionAlgorithm.Aes256Gcm, "encryption", null, CancellationToken.None)
				.ConfigureAwait(false);
			_ = await provider.RotateKeyAsync(keyId2, EncryptionAlgorithm.Aes256Gcm, "signing", null, CancellationToken.None)
				.ConfigureAwait(false);

			// Act
			var result = await provider.GetActiveKeyAsync("signing", CancellationToken.None).ConfigureAwait(false);

			// Assert
			if (result is null)
			{
				throw new TestFixtureAssertionException("Expected GetActiveKeyAsync to return a key.");
			}

			if (result.KeyId != keyId2)
			{
				throw new TestFixtureAssertionException(
					$"Expected key with purpose 'signing' to be {keyId2}, but got {result.KeyId}.");
			}
		}
		finally
		{
			await CleanupAsync().ConfigureAwait(false);
			(provider as IDisposable)?.Dispose();
		}
	}

	/// <summary>
	/// Verifies that GetActiveKeyAsync skips suspended keys.
	/// </summary>
	protected virtual async Task GetActiveKeyAsync_SuspendedKey_ShouldNotReturn()
	{
		// Arrange
		var provider = CreateProvider();
		try
		{
			var keyId = GenerateKeyId();

			// Create and suspend key
			_ = await provider.RotateKeyAsync(keyId, EncryptionAlgorithm.Aes256Gcm, null, null, CancellationToken.None)
				.ConfigureAwait(false);
			_ = await provider.SuspendKeyAsync(keyId, "test-suspension", CancellationToken.None).ConfigureAwait(false);

			// Act
			var result = await provider.GetActiveKeyAsync(null, CancellationToken.None).ConfigureAwait(false);

			// Assert
			if (result is not null)
			{
				throw new TestFixtureAssertionException(
					"Expected GetActiveKeyAsync to return null for suspended key.");
			}
		}
		finally
		{
			await CleanupAsync().ConfigureAwait(false);
			(provider as IDisposable)?.Dispose();
		}
	}

	#endregion

	#region Disposable Tests

	/// <summary>
	/// Verifies that disposed provider throws ObjectDisposedException.
	/// </summary>
	protected virtual async Task Disposed_Provider_ShouldThrowObjectDisposedException()
	{
		// Arrange
		var provider = CreateProvider();
		var keyId = GenerateKeyId();

		try
		{
			// Dispose if IDisposable
			(provider as IDisposable)?.Dispose();

			// Act & Assert
			var caughtException = false;
			try
			{
				_ = await provider.GetKeyAsync(keyId, CancellationToken.None).ConfigureAwait(false);
			}
			catch (ObjectDisposedException)
			{
				caughtException = true;
			}

			// Note: Only IDisposable implementations are required to throw
			// Non-disposable implementations may not support this pattern
			if (provider is IDisposable && !caughtException)
			{
				throw new TestFixtureAssertionException(
					"Expected disposed provider to throw ObjectDisposedException.");
			}
		}
		finally
		{
			await CleanupAsync().ConfigureAwait(false);
		}
	}

	#endregion
}
