// SPDX-FileCopyrightText: Copyright (c) 2026 The Excalibur Project
// SPDX-License-Identifier: LicenseRef-Excalibur-1.0 OR AGPL-3.0-or-later OR SSPL-1.0 OR Apache-2.0


using System.Diagnostics.CodeAnalysis;
using System.Reflection;

namespace Excalibur.Dispatch.Delivery.Handlers;

/// <summary>
/// Bootstraps the handler registry by either using a precompiled handler registry or scanning assemblies.
/// </summary>
public static class HandlerRegistryBootstrapper
{
	/// <summary>
	/// Bootstraps the handler registry with handlers.
	/// </summary>
	/// <param name="registry"> The handler registry to populate. </param>
	/// <param name="fallbackAssemblies"> Assemblies to scan if no precompiled registry is found. </param>
	[RequiresUnreferencedCode(
		"Uses reflection to dynamically load PrecompiledHandlerRegistry. The type should be preserved if using AOT.")]
	public static void Bootstrap(IHandlerRegistry registry, Assembly[] fallbackAssemblies)
	{
		// Try to use precompiled handler registry if available (AOT-compatible) This will be resolved at compile time if the generator has run
		if (TryUsePrecompiledRegistry(registry))
		{
			return;
		}

		// Fallback to reflection-based discovery across currently loaded assemblies.
		var type = ResolvePrecompiledRegistryType();

		var method = type?.GetMethod("RegisterAll", BindingFlags.Public | BindingFlags.Static);

		if (method != null)
		{
			_ = method.Invoke(null, [registry]);
			return;
		}

		registry.RegisterHandlersFromAssemblies(fallbackAssemblies);
	}

	private static Type? ResolvePrecompiledRegistryType()
	{
		const string precompiledRegistryTypeName = "Excalibur.Dispatch.Delivery.Handlers.PrecompiledHandlerRegistry";

		foreach (var assembly in AppDomain.CurrentDomain.GetAssemblies())
		{
			try
			{
				var type = assembly.GetType(precompiledRegistryTypeName, throwOnError: false, ignoreCase: false);
				if (type != null)
				{
					return type;
				}
			}
			catch
			{
				// Ignore any assemblies that can't be inspected.
			}
		}

		return null;
	}

	/// <summary>
	/// Attempts to use the precompiled handler registry if available. This method will be inlined and the call to
	/// PrecompiledHandlerRegistry will be direct if the type exists.
	/// </summary>
	private static bool TryUsePrecompiledRegistry(IHandlerRegistry registry)
	{
		try
		{
			// This will be generated by the source generator and will be AOT-compatible
			PrecompiledHandlerRegistry.RegisterAll(registry);
			return true;
		}
		catch (TypeLoadException)
		{
			// PrecompiledHandlerRegistry doesn't exist, fall back to reflection
			return false;
		}
	}
}
