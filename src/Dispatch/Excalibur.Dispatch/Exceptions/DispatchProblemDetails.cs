// SPDX-FileCopyrightText: Copyright (c) 2026 The Excalibur Project
// SPDX-License-Identifier: LicenseRef-Excalibur-1.0 OR AGPL-3.0-or-later OR SSPL-1.0 OR Apache-2.0


using System.Text.Json.Serialization;

using Excalibur.Dispatch.Abstractions;

namespace Excalibur.Dispatch.Exceptions;

/// <summary>
/// Implements RFC 7807 Problem Details for HTTP APIs with additional fields for distributed tracing. Provides a standardized format for
/// error responses across the Excalibur framework.
/// </summary>
public sealed class DispatchProblemDetails
{
	/// <summary>
	/// Gets or sets a URI reference that identifies the problem type. When dereferenced, it should provide human-readable documentation for
	/// the problem type.
	/// </summary>
	/// <value>
	/// A URI reference that identifies the problem type. When dereferenced, it should provide human-readable documentation for
	/// the problem type.
	/// </value>
	[JsonPropertyName("type")]
	public string Type { get; set; } = "about:blank";

	/// <summary>
	/// Gets or sets a short, human-readable summary of the problem type. Should not change from occurrence to occurrence of the problem.
	/// </summary>
	/// <value>
	/// A short, human-readable summary of the problem type. Should not change from occurrence to occurrence of the problem.
	/// </value>
	[JsonPropertyName("title")]
	public string? Title { get; set; }

	/// <summary>
	/// Gets or sets the HTTP status code generated by the origin server for this occurrence of the problem.
	/// </summary>
	/// <value>
	/// The HTTP status code generated by the origin server for this occurrence of the problem.
	/// </value>
	[JsonPropertyName("status")]
	public int? Status { get; set; }

	/// <summary>
	/// Gets or sets a human-readable explanation specific to this occurrence of the problem.
	/// </summary>
	/// <value>
	/// A human-readable explanation specific to this occurrence of the problem.
	/// </value>
	[JsonPropertyName("detail")]
	public string? Detail { get; set; }

	/// <summary>
	/// Gets or sets a URI reference that identifies the specific occurrence of the problem.
	/// </summary>
	/// <value>
	/// A URI reference that identifies the specific occurrence of the problem.
	/// </value>
	[JsonPropertyName("instance")]
	public string? Instance { get; set; }

	// Extended properties for Excalibur framework

	/// <summary>
	/// Gets or sets the error code for programmatic error handling.
	/// </summary>
	/// <value>
	/// The error code for programmatic error handling.
	/// </value>
	[JsonPropertyName("errorCode")]
	public string? ErrorCode { get; set; }

	/// <summary>
	/// Gets or sets the error category for classification.
	/// </summary>
	/// <value>
	/// The error category for classification.
	/// </value>
	[JsonPropertyName("category")]
	public string? Category { get; set; }

	/// <summary>
	/// Gets or sets the error severity level.
	/// </summary>
	/// <value>
	/// The error severity level.
	/// </value>
	[JsonPropertyName("severity")]
	public string? Severity { get; set; }

	/// <summary>
	/// Gets or sets the correlation ID for tracing the error across services.
	/// </summary>
	/// <value>
	/// The correlation ID for tracing the error across services.
	/// </value>
	[JsonPropertyName("correlationId")]
	public string? CorrelationId { get; set; }

	/// <summary>
	/// Gets or sets the trace ID from distributed tracing.
	/// </summary>
	/// <value>
	/// The trace ID from distributed tracing.
	/// </value>
	[JsonPropertyName("traceId")]
	public string? TraceId { get; set; }

	/// <summary>
	/// Gets or sets the span ID from distributed tracing.
	/// </summary>
	/// <value>
	/// The span ID from distributed tracing.
	/// </value>
	[JsonPropertyName("spanId")]
	public string? SpanId { get; set; }

	/// <summary>
	/// Gets or sets the timestamp when the error occurred.
	/// </summary>
	/// <value>
	/// The timestamp when the error occurred.
	/// </value>
	[JsonPropertyName("timestamp")]
	public DateTimeOffset? Timestamp { get; set; }

	/// <summary>
	/// Gets or sets suggested actions to resolve the error.
	/// </summary>
	/// <value>
	/// Suggested actions to resolve the error.
	/// </value>
	[JsonPropertyName("suggestedAction")]
	public string? SuggestedAction { get; set; }

	/// <summary>
	/// Gets additional extension data for the problem details.
	/// </summary>
	/// <value>
	/// Additional extension data for the problem details.
	/// </value>
	[JsonExtensionData]
	public Dictionary<string, object?>? Extensions { get; init; }

	/// <summary>
	/// Creates a problem details instance from an exception.
	/// </summary>
	/// <param name="exception"> The exception to convert. </param>
	/// <param name="includeDetails"> Whether to include detailed error information. </param>
	/// <returns> A problem details instance. </returns>
	public static DispatchProblemDetails FromException(Exception exception, bool includeDetails = false)
	{
		if (exception is DispatchException dispatchEx)
		{
			return dispatchEx.ToDispatchProblemDetails();
		}

		var extensions = includeDetails
			? new Dictionary<string, object?>(StringComparer.Ordinal) { ["exceptionType"] = exception.GetType().Name, ["stackTrace"] = exception.StackTrace }
			: null;

		var problemDetails = new DispatchProblemDetails
		{
			Type = ProblemDetailsTypes.Internal,
			Title = "An error occurred while processing your request",
			Status = 500,
			Instance = $"urn:excalibur:error:{Guid.NewGuid()}",
			Timestamp = DateTimeOffset.UtcNow,
			Detail = includeDetails ? exception.Message : null,
			Extensions = extensions,
		};

		// Try to extract error code if available
		if (exception.Data.Contains("ErrorCode"))
		{
			problemDetails.ErrorCode = exception.Data["ErrorCode"]?.ToString();
		}

		// Extract correlation ID if available
		if (exception.Data.Contains("CorrelationId"))
		{
			problemDetails.CorrelationId = exception.Data["CorrelationId"]?.ToString();
		}

		return problemDetails;
	}

	/// <summary>
	/// Creates a validation problem details instance.
	/// </summary>
	/// <param name="errors"> The validation errors. </param>
	/// <returns> A problem details instance for validation errors. </returns>
	public static DispatchProblemDetails ForValidation(IDictionary<string, string[]> errors) =>
		new()
		{
			Type = ProblemDetailsTypes.Validation,
			Title = "One or more validation errors occurred",
			Status = 400,
			ErrorCode = ErrorCodes.ValidationFailed,
			Category = nameof(ErrorCategory.Validation),
			Severity = nameof(ErrorSeverity.Warning),
			Timestamp = DateTimeOffset.UtcNow,
			Extensions = new Dictionary<string, object?>(StringComparer.Ordinal) { ["errors"] = errors },
		};

	/// <summary>
	/// Creates a not found problem details instance.
	/// </summary>
	/// <param name="resourceType"> The type of resource that was not found. </param>
	/// <param name="resourceId"> The ID of the resource that was not found. </param>
	/// <returns> A problem details instance for not found errors. </returns>
	public static DispatchProblemDetails ForNotFound(string resourceType, string? resourceId = null)
	{
		var detail = resourceId != null
			? $"The {resourceType} with ID '{resourceId}' was not found"
			: $"The requested {resourceType} was not found";

		return new DispatchProblemDetails
		{
			Type = ProblemDetailsTypes.NotFound,
			Title = "Resource not found",
			Status = 404,
			Detail = detail,
			ErrorCode = ErrorCodes.ResourceNotFound,
			Category = nameof(ErrorCategory.Resource),
			Severity = nameof(ErrorSeverity.Warning),
			Timestamp = DateTimeOffset.UtcNow,
		};
	}

	/// <summary>
	/// Creates an unauthorized problem details instance.
	/// </summary>
	/// <param name="reason"> The reason for the unauthorized access. </param>
	/// <returns> A problem details instance for unauthorized errors. </returns>
	public static DispatchProblemDetails ForUnauthorized(string? reason = null) =>
		new()
		{
			Type = ProblemDetailsTypes.Unauthorized,
			Title = "Unauthorized",
			Status = 401,
			Detail = reason ?? "Authentication is required to access this resource",
			ErrorCode = ErrorCodes.SecurityAuthenticationFailed,
			Category = nameof(ErrorCategory.Security),
			Severity = nameof(ErrorSeverity.Warning),
			Timestamp = DateTimeOffset.UtcNow,
			SuggestedAction = "Please authenticate and try again",
		};

	/// <summary>
	/// Creates a forbidden problem details instance.
	/// </summary>
	/// <param name="reason"> The reason for the forbidden access. </param>
	/// <returns> A problem details instance for forbidden errors. </returns>
	public static DispatchProblemDetails ForForbidden(string? reason = null) =>
		new()
		{
			Type = ProblemDetailsTypes.Forbidden,
			Title = "Forbidden",
			Status = 403,
			Detail = reason ?? "You do not have permission to access this resource",
			ErrorCode = ErrorCodes.SecurityAuthorizationFailed,
			Category = nameof(ErrorCategory.Security),
			Severity = nameof(ErrorSeverity.Warning),
			Timestamp = DateTimeOffset.UtcNow,
			SuggestedAction = "Contact your administrator if you believe you should have access",
		};
}
