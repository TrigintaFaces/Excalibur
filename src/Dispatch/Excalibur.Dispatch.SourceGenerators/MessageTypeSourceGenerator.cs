// SPDX-FileCopyrightText: Copyright (c) 2026 The Excalibur Project
// SPDX-License-Identifier: LicenseRef-Excalibur-1.0 OR AGPL-3.0-or-later OR SSPL-1.0 OR Apache-2.0


using System.Collections.Immutable;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Excalibur.Dispatch.SourceGenerators;

/// <summary>
/// Source generator that creates compile-time message type discovery for AOT compatibility.
/// Works alongside the manual MessageTypeRegistry to provide type discovery.
/// </summary>
[Generator]
public sealed class MessageTypeSourceGenerator : IIncrementalGenerator
{
	private static readonly HashSet<string> MessageInterfaces =
	[
		"IDispatchMessage",
		"IDispatchAction",
		"IDispatchEvent",
		"IDispatchDocument",
		"IIntegrationEvent",
		"IDomainEvent"
	];

	/// <summary>
	/// Initializes the message type source generator with the given context.
	/// Sets up syntax providers to find types implementing message interfaces and registers
	/// source output generation for compile-time message type discovery and AOT preservation.
	/// </summary>
	/// <param name="context">The generator initialization context providing access to syntax providers and source output registration.</param>
	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		// Find all types that implement message interfaces
		var messageTypes = context.SyntaxProvider
			.CreateSyntaxProvider(
				predicate: static (node, _) => IsCandidateType(node),
				transform: static (context, _) => GetMessageTypeInfo(context))
			.Where(static typeInfo => typeInfo != null)
			.Select(static (typeInfo, _) => typeInfo!);

		// Generate registration code
		context.RegisterSourceOutput(messageTypes.Collect(), GenerateTypeRegistrations);
	}

	private static bool IsCandidateType(SyntaxNode node) =>
		node is ClassDeclarationSyntax { BaseList: not null } or
			RecordDeclarationSyntax { BaseList: not null } or
			StructDeclarationSyntax { BaseList: not null };

	private static MessageTypeInfo? GetMessageTypeInfo(GeneratorSyntaxContext context)
	{
		if (context.SemanticModel.GetDeclaredSymbol(context.Node) is not INamedTypeSymbol typeSymbol || typeSymbol.IsAbstract ||
			typeSymbol.IsGenericType)
		{
			return null;
		}

		// Skip nested private/internal types that cannot be accessed from generated code
		if (typeSymbol.ContainingType != null && typeSymbol.DeclaredAccessibility != Accessibility.Public)
		{
			return null;
		}

		// Skip types that aren't accessible from the generated code namespace
		if (typeSymbol.DeclaredAccessibility is Accessibility.Private or
			Accessibility.Internal or Accessibility.ProtectedAndInternal)
		{
			return null;
		}

		// Check if type implements any message interface
		var implementsMessageInterface = false;
		foreach (var @interface in typeSymbol.AllInterfaces)
		{
			if (MessageInterfaces.Contains(@interface.Name))
			{
				implementsMessageInterface = true;
				break;
			}
		}

		if (!implementsMessageInterface)
		{
			return null;
		}

		return new MessageTypeInfo
		{
			FullName = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
			SimpleName = typeSymbol.Name,
			Namespace = typeSymbol.ContainingNamespace.ToDisplayString()
		};
	}

	private static void GenerateTypeRegistrations(SourceProductionContext context, ImmutableArray<MessageTypeInfo> messageTypes)
	{
		if (messageTypes.IsDefaultOrEmpty)
		{
			return;
		}

		var sb = new StringBuilder();

		_ = sb.AppendLine("// <auto-generated/>");
		_ = sb.AppendLine($"// Generated on: {DateTimeOffset.UtcNow:yyyy-MM-dd HH:mm:ss} UTC");
		_ = sb.AppendLine($"// Message types discovered: {messageTypes.Length}");
		_ = sb.AppendLine();

		_ = sb.AppendLine("using System.Runtime.CompilerServices;");
		_ = sb.AppendLine("using System.Diagnostics.CodeAnalysis;");
		_ = sb.AppendLine("using Excalibur.Dispatch.Abstractions;");
		_ = sb.AppendLine();

		_ = sb.AppendLine("namespace Excalibur.Dispatch.Generated;");
		_ = sb.AppendLine();
		_ = sb.AppendLine("/// <summary>");
		_ = sb.AppendLine("/// Auto-generated message type registrations.");
		_ = sb.AppendLine("/// </summary>");
		_ = sb.AppendLine("internal static class GeneratedMessageTypeRegistrations");
		_ = sb.AppendLine("{");
		// Generate array to force type preservation during trimming
		_ = sb.AppendLine(" private static readonly Type[] PreservedMessageTypes = [");

		foreach (var type in messageTypes.OrderBy(static t => t.FullName))
		{
			_ = sb.AppendLine($"  typeof({type.FullName}),");
		}

		_ = sb.AppendLine(" ];");
		_ = sb.AppendLine();

		_ = sb.AppendLine(" [UnconditionalSuppressMessage(\"ReflectionAnalysis\", \"IL2072:UnrecognizedReflectionPattern\",");
		_ = sb.AppendLine("  Justification = \"Types are preserved at compile time by source generator\")]");
		_ = sb.AppendLine(" static GeneratedMessageTypeRegistrations()");
		_ = sb.AppendLine(" {");
		_ = sb.AppendLine("  // Force access to all message type members to prevent trimming");
		_ = sb.AppendLine("  foreach (var type in PreservedMessageTypes)");
		_ = sb.AppendLine("  {");
		_ = sb.AppendLine("   PreserveType(type);");
		_ = sb.AppendLine("  }");
		_ = sb.AppendLine(" }");
		_ = sb.AppendLine();
		_ = sb.AppendLine(" [UnconditionalSuppressMessage(\"ReflectionAnalysis\", \"IL2026:RequiresUnreferencedCode\",");
		_ = sb.AppendLine("  Justification = \"Types are preserved at compile time by source generator\")]");
		_ = sb.AppendLine(" [UnconditionalSuppressMessage(\"ReflectionAnalysis\", \"IL2075:UnrecognizedReflectionPattern\",");
		_ = sb.AppendLine("  Justification = \"Types are preserved at compile time by source generator\")]");
		_ = sb.AppendLine(" private static void PreserveType([DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type type)");
		_ = sb.AppendLine(" {");
		_ = sb.AppendLine("  _ = type.GetConstructors();");
		_ = sb.AppendLine("  _ = type.GetProperties();");
		_ = sb.AppendLine("  _ = type.GetFields();");
		_ = sb.AppendLine(" }");
		_ = sb.AppendLine();

		_ = sb.AppendLine(" [ModuleInitializer]");
		_ = sb.AppendLine(" public static void Initialize()");
		_ = sb.AppendLine(" {");
		_ = sb.AppendLine("  // Message types have been preserved via the static constructor");
		_ = sb.AppendLine(" }");
		_ = sb.AppendLine("}");

		context.AddSource("GeneratedMessageTypeRegistrations.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
	}

	private sealed class MessageTypeInfo
	{
		public string FullName { get; set; } = string.Empty;
		public string SimpleName { get; set; } = string.Empty;
		public string Namespace { get; set; } = string.Empty;
	}
}
