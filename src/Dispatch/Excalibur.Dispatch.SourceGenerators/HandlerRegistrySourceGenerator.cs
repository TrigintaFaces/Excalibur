// SPDX-FileCopyrightText: Copyright (c) 2026 The Excalibur Project
// SPDX-License-Identifier: LicenseRef-Excalibur-1.0 OR AGPL-3.0-or-later OR SSPL-1.0 OR Apache-2.0

using System.Collections.Immutable;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Excalibur.Dispatch.SourceGenerators;

/// <summary>
/// Source generator that discovers all message handlers at compile time and generates
/// registration code for AOT-friendly handler discovery.
/// </summary>
[Generator]
public sealed class HandlerRegistrySourceGenerator : IIncrementalGenerator
{
	/// <summary>
	/// Initializes the handler registry source generator with the given context.
	/// Sets up syntax providers to find handler class declarations and registers
	/// source output generation for compile-time handler registry creation.
	/// </summary>
	/// <param name="context">The generator initialization context providing access to syntax providers and source output registration.</param>
	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		var handlerCandidates = context.SyntaxProvider
			.CreateSyntaxProvider(
				predicate: static (s, _) => s is ClassDeclarationSyntax { BaseList: not null },
				transform: static (ctx, _) =>
					ctx.SemanticModel.GetDeclaredSymbol((ClassDeclarationSyntax)ctx.Node) as INamedTypeSymbol)
			.Where(static symbol => symbol is not null)
			.Collect();

		context.RegisterSourceOutput(handlerCandidates, GenerateHandlerCode);
	}

	private void GenerateHandlerCode(SourceProductionContext context, ImmutableArray<INamedTypeSymbol?> symbols)
	{
		var handlers = CollectHandlers(symbols);

		// Generate registry class
		GenerateRegistryClass(context, handlers);

		// Generate handler invoker
		GenerateHandlerInvoker(context, handlers);

		// Generate handler metadata
		GenerateHandlerMetadata(context, handlers);

		// Generate handler activator
		GenerateHandlerActivator(context, handlers);

		// Generate direct action dispatch table
		GenerateDirectActionDispatch(context, handlers);
	}

	private List<HandlerInfo> CollectHandlers(ImmutableArray<INamedTypeSymbol?> symbols)
	{
		var handlers = new List<HandlerInfo>();

		foreach (var symbol in symbols.Distinct(SymbolEqualityComparer.Default).Where(static s => s is not null))
		{
			if (symbol is not INamedTypeSymbol classSymbol)
			{
				continue;
			}

			foreach (var iface in classSymbol.AllInterfaces)
			{
				if (!iface.IsGenericType)
				{
					continue;
				}

				var isHandler = iface.ContainingNamespace.ToDisplayString() == "Excalibur.Dispatch.Abstractions.Delivery"
								&& (((string?)iface.Name == "IActionHandler" && iface.TypeArguments.Length is 1 or 2)
									|| ((string?)iface.Name == "IEventHandler" && iface.TypeArguments.Length == 1)
									|| ((string?)iface.Name == "IDocumentHandler" && iface.TypeArguments.Length == 1));

				if (!isHandler)
				{
					continue;
				}

				var messageType = iface.TypeArguments[0];
				var responseType = iface.TypeArguments.Length > 1 ? iface.TypeArguments[1] : null;

				handlers.Add(new HandlerInfo
				{
					HandlerType = classSymbol,
					InterfaceType = iface,
					MessageType = messageType,
					ResponseType = responseType,
					HandlerKind = iface.Name
				});
			}
		}

		return handlers;
	}

	private void GenerateRegistryClass(SourceProductionContext context, List<HandlerInfo> handlers)
	{
		var sb = new StringBuilder();

		// File header
		_ = sb.AppendLine("// <auto-generated/>");
		_ = sb.AppendLine("#nullable enable");
		_ = sb.AppendLine();
		_ = sb.AppendLine("using System;");
		_ = sb.AppendLine("using System.Diagnostics.CodeAnalysis;");
		_ = sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
		_ = sb.AppendLine();
		_ = sb.AppendLine("namespace Excalibur.Dispatch.Delivery.Handlers;");
		_ = sb.AppendLine();
		_ = sb.AppendLine("/// <summary>");
		_ = sb.AppendLine("/// AOT-friendly handler registry that registers all discovered handlers at compile time.");
		_ = sb.AppendLine("/// </summary>");
		_ = sb.AppendLine(
			"[UnconditionalSuppressMessage(\"Trimming\", \"IL2026:Members annotated with RequiresUnreferencedCode may break with trimming\",");
		_ = sb.AppendLine(" Justification = \"All handler types are preserved by this source generator\")]");
		_ = sb.AppendLine("public static class PrecompiledHandlerRegistry");
		_ = sb.AppendLine("{");
		_ = sb.AppendLine(" /// <summary>");
		_ = sb.AppendLine(" /// Registers all discovered handlers with the provided registry.");
		_ = sb.AppendLine(" /// </summary>");
		_ = sb.AppendLine(" public static void RegisterAll(IHandlerRegistry registry)");
		_ = sb.AppendLine(" {");
		_ = sb.AppendLine(" ArgumentNullException.ThrowIfNull(registry);");
		_ = sb.AppendLine();

		foreach (var handler in handlers)
		{
			var messageType = handler.MessageType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
			var handlerType = handler.HandlerType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
			var expectsResponse = handler.ResponseType != null;

			_ = sb.AppendLine($" registry.Register(typeof({messageType}),");
			_ = sb.AppendLine($" typeof({handlerType}),");
			_ = sb.AppendLine($" {(expectsResponse ? "true" : "false")});");
		}

		_ = sb.AppendLine(" }");
		_ = sb.AppendLine();

		// Generate ResolveHandlerType method - AOT-safe message-to-handler type resolution
		_ = sb.AppendLine(" /// <summary>");
		_ = sb.AppendLine(" /// Resolves the handler type for a given message type using a compile-time switch expression (AOT-safe).");
		_ = sb.AppendLine(" /// </summary>");
		_ = sb.AppendLine(" /// <param name=\"messageType\">The message type to resolve a handler for.</param>");
		_ = sb.AppendLine(" /// <returns>The handler type, or <c>null</c> if no handler is registered for the message type.</returns>");
		_ = sb.AppendLine(" public static Type? ResolveHandlerType(Type messageType)");
		_ = sb.AppendLine(" {");

		if (handlers.Count > 0)
		{
			_ = sb.AppendLine(" return messageType switch");
			_ = sb.AppendLine(" {");

			foreach (var handler in handlers)
			{
				var messageType = handler.MessageType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
				var handlerType = handler.HandlerType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
				_ = sb.AppendLine($" Type t when t == typeof({messageType}) => typeof({handlerType}),");
			}

			_ = sb.AppendLine(" _ => null");
			_ = sb.AppendLine(" };");
		}
		else
		{
			_ = sb.AppendLine(" return null;");
		}

		_ = sb.AppendLine(" }");
		_ = sb.AppendLine();

		// Generate CreateHandler method - AOT-safe handler creation via DI
		_ = sb.AppendLine(" /// <summary>");
		_ = sb.AppendLine(" /// Creates a handler instance for a given message type using the service provider (AOT-safe).");
		_ = sb.AppendLine(" /// </summary>");
		_ = sb.AppendLine(" /// <param name=\"messageType\">The message type to create a handler for.</param>");
		_ = sb.AppendLine(" /// <param name=\"provider\">The service provider to resolve the handler from.</param>");
		_ = sb.AppendLine(" /// <returns>The handler instance, or <c>null</c> if no handler is registered for the message type.</returns>");
		_ = sb.AppendLine(" public static object? CreateHandler(Type messageType, IServiceProvider provider)");
		_ = sb.AppendLine(" {");
		_ = sb.AppendLine(" ArgumentNullException.ThrowIfNull(provider);");

		if (handlers.Count > 0)
		{
			_ = sb.AppendLine(" var handlerType = ResolveHandlerType(messageType);");
			_ = sb.AppendLine(" return handlerType is not null ? provider.GetRequiredService(handlerType) : null;");
		}
		else
		{
			_ = sb.AppendLine(" return null;");
		}

		_ = sb.AppendLine(" }");
		_ = sb.AppendLine();

		_ = sb.AppendLine(" /// <summary>");
		_ = sb.AppendLine($" /// Gets the total number of handlers registered ({handlers.Count} handlers discovered at compile time).");
		_ = sb.AppendLine(" /// </summary>");
		_ = sb.AppendLine($" public static int HandlerCount => {handlers.Count};");
		_ = sb.AppendLine("}");

		// Report diagnostic about handler discovery
		context.ReportDiagnostic(Diagnostic.Create(
			new DiagnosticDescriptor(
				"HND001",
				"Handler Discovery Complete",
				$"Discovered {handlers.Count} handler(s) for registration",
				"Excalibur.Dispatch.Messaging.Generators",
				DiagnosticSeverity.Info,
				isEnabledByDefault: true),
			Location.None));

		context.AddSource("PrecompiledHandlerRegistry.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
	}

	private void GenerateHandlerInvoker(SourceProductionContext context, List<HandlerInfo> handlers)
	{
		var sb = new StringBuilder();

		// File header
		_ = sb.AppendLine("// <auto-generated/>");
		_ = sb.AppendLine("#nullable enable");
		_ = sb.AppendLine();
		_ = sb.AppendLine("using System;");
		_ = sb.AppendLine("using System.Threading;");
		_ = sb.AppendLine("using System.Threading.Tasks;");
		_ = sb.AppendLine("using Excalibur.Dispatch.Abstractions;");
		_ = sb.AppendLine("using Excalibur.Dispatch.Abstractions.Delivery;");
		_ = sb.AppendLine();
		_ = sb.AppendLine("namespace Excalibur.Dispatch.Delivery.Handlers;");
		_ = sb.AppendLine();
		_ = sb.AppendLine("/// <summary>");
		_ = sb.AppendLine("/// AOT-compatible handler invoker that uses compile-time generated delegates.");
		_ = sb.AppendLine("/// </summary>");
		_ = sb.AppendLine("public static class PrecompiledHandlerInvoker");
		_ = sb.AppendLine("{");
		_ = sb.AppendLine(" /// <summary>");
		_ = sb.AppendLine(" /// Invokes a handler using compile-time generated delegates (AOT-compatible).");
		_ = sb.AppendLine(" /// </summary>");
		_ = sb.AppendLine(
			" public static Task<object?> InvokeAsync(object handler, IDispatchMessage message, CancellationToken cancellationToken)");
		_ = sb.AppendLine(" {");
		_ = sb.AppendLine(" ArgumentNullException.ThrowIfNull(handler);");
		_ = sb.AppendLine(" ArgumentNullException.ThrowIfNull(message);");
		_ = sb.AppendLine();
		_ = sb.AppendLine(" return (handler, message) switch");
		_ = sb.AppendLine(" {");

		// Generate switch cases for each handler
		foreach (var handler in handlers)
		{
			var handlerType = handler.HandlerType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
			var messageType = handler.MessageType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

			if (handler.ResponseType != null)
			{
				// Handler with response type
				_ = handler.ResponseType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
				_ = sb.AppendLine($" ({handlerType} h, {messageType} m) => ");
				_ = sb.AppendLine(
					" h.HandleAsync(m, cancellationToken).ContinueWith(t => (object?)t.Result, TaskContinuationOptions.ExecuteSynchronously),");
			}
			else
			{
				// Handler without response (void/Task)
				_ = sb.AppendLine($" ({handlerType} h, {messageType} m) => ");
				_ = sb.AppendLine(
					" h.HandleAsync(m, cancellationToken).ContinueWith(_ => (object?)null, TaskContinuationOptions.ExecuteSynchronously),");
			}
		}

		_ = sb.AppendLine(
			" _ => throw new InvalidOperationException($\"No invoker found for handler type {handler.GetType()} and message type {message.GetType()}\")");
		_ = sb.AppendLine(" };");
		_ = sb.AppendLine(" }");
		_ = sb.AppendLine();
		_ = sb.AppendLine(" /// <summary>");
		_ = sb.AppendLine(" /// Checks if a handler can process a specific message type.");
		_ = sb.AppendLine(" /// </summary>");
		_ = sb.AppendLine(" public static bool CanHandle(Type handlerType, Type messageType)");
		_ = sb.AppendLine(" {");
		_ = sb.AppendLine(" return (handlerType, messageType) switch");
		_ = sb.AppendLine(" {");

		// Generate type checks
		foreach (var handler in handlers)
		{
			var handlerType = handler.HandlerType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
			var messageType = handler.MessageType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

			_ = sb.AppendLine($" (Type t1, Type t2) when t1 == typeof({handlerType}) && t2 == typeof({messageType}) => true,");
		}

		_ = sb.AppendLine(" _ => false");
		_ = sb.AppendLine(" };");
		_ = sb.AppendLine(" }");
		_ = sb.AppendLine("}");

		context.AddSource("PrecompiledHandlerInvoker.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
	}

	private void GenerateHandlerMetadata(SourceProductionContext context, List<HandlerInfo> handlers)
	{
		var sb = new StringBuilder();

		// File header
		_ = sb.AppendLine("// <auto-generated/>");
		_ = sb.AppendLine("#nullable enable");
		_ = sb.AppendLine("// R0.8: Possible null reference assignment");
#pragma warning disable CS8601
		_ = sb.AppendLine();
		_ = sb.AppendLine("using System;");
		_ = sb.AppendLine("using System.Collections.Generic;");
		_ = sb.AppendLine("using System.Collections.Immutable;");
		_ = sb.AppendLine();
		_ = sb.AppendLine("namespace Excalibur.Dispatch.Delivery.Handlers;");
		_ = sb.AppendLine();
		_ = sb.AppendLine("/// <summary>");
		_ = sb.AppendLine("/// Provides compile-time metadata about discovered handlers.");
		_ = sb.AppendLine("/// </summary>");
		_ = sb.AppendLine("public static class PrecompiledHandlerMetadata");
		_ = sb.AppendLine("{");
		_ = sb.AppendLine(" private static readonly ImmutableDictionary<Type, HandlerMetadata> _handlersByMessageType;");
		_ = sb.AppendLine(" private static readonly ImmutableDictionary<Type, ImmutableArray<Type>> _messageTypesByHandler;");
		_ = sb.AppendLine();
		_ = sb.AppendLine(" static PrecompiledHandlerMetadata()");
		_ = sb.AppendLine(" {");
		_ = sb.AppendLine(" var handlersByMessage = new Dictionary<Type, HandlerMetadata>();");
		_ = sb.AppendLine(" var messagesByHandler = new Dictionary<Type, List<Type>>();");
		_ = sb.AppendLine();

		// Generate initialization code
		foreach (var handler in handlers)
		{
			var handlerType = handler.HandlerType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
			var messageType = handler.MessageType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
			var hasResponse = handler.ResponseType != null;

			_ = sb.AppendLine($" handlersByMessage[typeof({messageType})] = new HandlerMetadata");
			_ = sb.AppendLine(" {");
			_ = sb.AppendLine($" HandlerType = typeof({handlerType}),");
			_ = sb.AppendLine($" MessageType = typeof({messageType}),");
			_ = sb.AppendLine($" HasResponse = {(hasResponse ? "true" : "false")},");
			if (hasResponse)
			{
				var responseType = handler.ResponseType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
				_ = sb.AppendLine($" ResponseType = typeof({responseType})");
			}
			else
			{
				_ = sb.AppendLine(" ResponseType = null");
			}

			_ = sb.AppendLine(" };");
			_ = sb.AppendLine();

			_ = sb.AppendLine($" if (!messagesByHandler.ContainsKey(typeof({handlerType})))");
			_ = sb.AppendLine($" messagesByHandler[typeof({handlerType})] = new List<Type>();");
			_ = sb.AppendLine($" messagesByHandler[typeof({handlerType})].Add(typeof({messageType}));");
			_ = sb.AppendLine();
		}

		_ = sb.AppendLine(" _handlersByMessageType = handlersByMessage.ToImmutableDictionary();");
		_ = sb.AppendLine(" _messageTypesByHandler = messagesByHandler.ToImmutableDictionary(");
		_ = sb.AppendLine(" kvp => kvp.Key,");
		_ = sb.AppendLine(" kvp => kvp.Value.ToImmutableArray());");
		_ = sb.AppendLine(" }");
		_ = sb.AppendLine();
		_ = sb.AppendLine(" /// <summary>");
		_ = sb.AppendLine(" /// Gets handler metadata for a specific message type.");
		_ = sb.AppendLine(" /// </summary>");
		_ = sb.AppendLine(" public static bool TryGetHandlerForMessage(Type messageType, out HandlerMetadata? metadata)");
		_ = sb.AppendLine(" {");
		_ = sb.AppendLine(" return _handlersByMessageType.TryGetValue(messageType, out metadata);");
		_ = sb.AppendLine(" }");
		_ = sb.AppendLine();
		_ = sb.AppendLine(" /// <summary>");
		_ = sb.AppendLine(" /// Gets all message types handled by a specific handler.");
		_ = sb.AppendLine(" /// </summary>");
		_ = sb.AppendLine(" public static ImmutableArray<Type> GetMessageTypesForHandler(Type handlerType)");
		_ = sb.AppendLine(" {");
		_ = sb.AppendLine(" return _messageTypesByHandler.TryGetValue(handlerType, out var types)");
		_ = sb.AppendLine(" ? types");
		_ = sb.AppendLine(" : ImmutableArray<Type>.Empty;");
		_ = sb.AppendLine(" }");
		_ = sb.AppendLine();
		_ = sb.AppendLine(" /// <summary>");
		_ = sb.AppendLine(" /// Metadata about a handler.");
		_ = sb.AppendLine(" /// </summary>");
		_ = sb.AppendLine(" public sealed class HandlerMetadata");
		_ = sb.AppendLine(" {");
		_ = sb.AppendLine(" /// <summary>");
		_ = sb.AppendLine(" /// Gets the type of the handler.");
		_ = sb.AppendLine(" /// </summary>");
		_ = sb.AppendLine(" public required Type HandlerType { get; init; }");
		_ = sb.AppendLine(" /// <summary>");
		_ = sb.AppendLine(" /// Gets the type of the message handled by this handler.");
		_ = sb.AppendLine(" /// </summary>");
		_ = sb.AppendLine(" public required Type MessageType { get; init; }");
		_ = sb.AppendLine(" /// <summary>");
		_ = sb.AppendLine(" /// Gets a value indicating whether this handler produces a response.");
		_ = sb.AppendLine(" /// </summary>");
		_ = sb.AppendLine(" public required bool HasResponse { get; init; }");
		_ = sb.AppendLine(" /// <summary>");
		_ = sb.AppendLine(" /// Gets the type of the response produced by this handler, or null if no response is produced.");
		_ = sb.AppendLine(" /// </summary>");
		_ = sb.AppendLine(" public Type? ResponseType { get; init; }");
		_ = sb.AppendLine(" }");
		_ = sb.AppendLine("}");

		context.AddSource("PrecompiledHandlerMetadata.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
	}

	private void GenerateHandlerActivator(SourceProductionContext context, List<HandlerInfo> handlers)
	{
		var sb = new StringBuilder();

		// File header
		_ = sb.AppendLine("// <auto-generated/>");
		_ = sb.AppendLine("#nullable enable");
		_ = sb.AppendLine();
		_ = sb.AppendLine("using System;");
		_ = sb.AppendLine("using System.Diagnostics.CodeAnalysis;");
		_ = sb.AppendLine("using Excalibur.Dispatch.Abstractions;");
		_ = sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
		_ = sb.AppendLine();
		_ = sb.AppendLine("namespace Excalibur.Dispatch.Delivery.Handlers;");
		_ = sb.AppendLine();
		_ = sb.AppendLine("/// <summary>");
		_ = sb.AppendLine("/// AOT-compatible handler activator that uses compile-time generated property setters.");
		_ = sb.AppendLine("/// </summary>");
		_ = sb.AppendLine("public static class PrecompiledHandlerActivator");
		_ = sb.AppendLine("{");
		_ = sb.AppendLine(" /// <summary>");
		_ = sb.AppendLine(" /// Activates a handler and sets its context property if available (AOT-compatible).");
		_ = sb.AppendLine(" /// </summary>");
		_ = sb.AppendLine(" [RequiresUnreferencedCode(\"Handler activation may require reflection to instantiate handler types\")]");
		_ = sb.AppendLine(
			" public static object ActivateHandler([DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicProperties)] Type handlerType, IMessageContext context, IServiceProvider provider)");
		_ = sb.AppendLine(" {");
		_ = sb.AppendLine(" var handler = provider.GetRequiredService(handlerType);");
		_ = sb.AppendLine(" SetContext(handler, context);");
		_ = sb.AppendLine(" return handler;");
		_ = sb.AppendLine(" }");
		_ = sb.AppendLine();
		_ = sb.AppendLine(" /// <summary>");
		_ = sb.AppendLine(" /// Sets the context on a handler if it has a writable IMessageContext property.");
		_ = sb.AppendLine(" /// </summary>");
		_ = sb.AppendLine(" public static void SetContext(object handler, IMessageContext context)");
		_ = sb.AppendLine(" {");
		_ = sb.AppendLine(" switch (handler)");
		_ = sb.AppendLine(" {");

		// For each handler, check if it has an IMessageContext property and generate setter
		var handlersWithContext = new List<(HandlerInfo handler, string propertyName)>();

		foreach (var handler in handlers.Distinct(new HandlerTypeComparer()))
		{
			// Check if handler has IMessageContext property
			var contextProperty = FindMessageContextProperty(handler.HandlerType);
			if (contextProperty != null)
			{
				handlersWithContext.Add((handler, contextProperty.Name));

				var handlerType = handler.HandlerType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
				_ = sb.AppendLine($" case {handlerType} h:");
				_ = sb.AppendLine($" h.{contextProperty.Name} = context;");
				_ = sb.AppendLine(" break;");
			}
		}

		_ = sb.AppendLine(" default:");
		_ = sb.AppendLine(" // Handler doesn't have a settable IMessageContext property");
		_ = sb.AppendLine(" break;");
		_ = sb.AppendLine(" }");
		_ = sb.AppendLine(" }");
		_ = sb.AppendLine();
		_ = sb.AppendLine(" /// <summary>");
		_ = sb.AppendLine(" /// Checks if a handler type has a settable IMessageContext property.");
		_ = sb.AppendLine(" /// </summary>");
		_ = sb.AppendLine(" public static bool HasContextProperty(Type handlerType)");
		_ = sb.AppendLine(" {");
		_ = sb.AppendLine(" return handlerType switch");
		_ = sb.AppendLine(" {");

		foreach (var (handler, _) in handlersWithContext)
		{
			var handlerType = handler.HandlerType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
			_ = sb.AppendLine($" Type t when t == typeof({handlerType}) => true,");
		}

		_ = sb.AppendLine(" _ => false");
		_ = sb.AppendLine(" };");
		_ = sb.AppendLine(" }");
		_ = sb.AppendLine("}");

		context.AddSource("PrecompiledHandlerActivator.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
	}

	private void GenerateDirectActionDispatch(SourceProductionContext context, List<HandlerInfo> handlers)
	{
		var actionHandlers = new List<HandlerInfo>();
		var seenMessageTypes = new HashSet<ITypeSymbol>(SymbolEqualityComparer.Default);
		foreach (var handler in handlers)
		{
			if (handler.HandlerKind != "IActionHandler")
			{
				continue;
			}

			if (seenMessageTypes.Add(handler.MessageType))
			{
				actionHandlers.Add(handler);
			}
		}

		var sb = new StringBuilder();

		_ = sb.AppendLine("// <auto-generated/>");
		_ = sb.AppendLine("#nullable enable");
		_ = sb.AppendLine();
		_ = sb.AppendLine("using System;");
		_ = sb.AppendLine("using System.Threading;");
		_ = sb.AppendLine("using System.Threading.Tasks;");
		_ = sb.AppendLine("using Excalibur.Dispatch.Abstractions;");
		_ = sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
		_ = sb.AppendLine();
		_ = sb.AppendLine("namespace Excalibur.Dispatch.Delivery.Handlers;");
		_ = sb.AppendLine();
		_ = sb.AppendLine("/// <summary>");
		_ = sb.AppendLine("/// Compile-time generated direct dispatch table for IActionHandler paths.");
		_ = sb.AppendLine("/// </summary>");
		_ = sb.AppendLine("public static class PrecompiledDirectActionDispatch");
		_ = sb.AppendLine("{");
		_ = sb.AppendLine(" private static readonly ValueTask<object?> NoResult = new(result: null);");
		_ = sb.AppendLine();
		_ = sb.AppendLine(" /// <summary>");
		_ = sb.AppendLine(" /// Determines whether this table can dispatch the provided action type.");
		_ = sb.AppendLine(" /// </summary>");
		_ = sb.AppendLine(" public static bool CanHandle(Type actionType)");
		_ = sb.AppendLine(" {");

		if (actionHandlers.Count == 0)
		{
			_ = sb.AppendLine(" return false;");
		}
		else
		{
			_ = sb.AppendLine(" return actionType switch");
			_ = sb.AppendLine(" {");
			foreach (var handler in actionHandlers)
			{
				var messageType = handler.MessageType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
				_ = sb.AppendLine($" Type t when t == typeof({messageType}) => true,");
			}

			_ = sb.AppendLine(" _ => false");
			_ = sb.AppendLine(" };");
		}

		_ = sb.AppendLine(" }");
		_ = sb.AppendLine();
		_ = sb.AppendLine(" /// <summary>");
		_ = sb.AppendLine(" /// Gets metadata for a generated direct action dispatch entry.");
		_ = sb.AppendLine(" /// </summary>");
		_ = sb.AppendLine(" public static bool TryGetMetadata(Type actionType, out bool expectsResponse, out bool requiresContext)");
		_ = sb.AppendLine(" {");
		_ = sb.AppendLine(" switch (actionType)");
		_ = sb.AppendLine(" {");

		foreach (var handler in actionHandlers)
		{
			var messageType = handler.MessageType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
			var requiresContext = FindMessageContextProperty(handler.HandlerType) is not null;
			var expectsResponse = handler.ResponseType is not null;
			_ = sb.AppendLine($" case Type t when t == typeof({messageType}):");
			_ = sb.AppendLine($" expectsResponse = {(expectsResponse ? "true" : "false")};");
			_ = sb.AppendLine($" requiresContext = {(requiresContext ? "true" : "false")};");
			_ = sb.AppendLine(" return true;");
		}

		_ = sb.AppendLine(" default:");
		_ = sb.AppendLine(" expectsResponse = false;");
		_ = sb.AppendLine(" requiresContext = false;");
		_ = sb.AppendLine(" return false;");
		_ = sb.AppendLine(" }");
		_ = sb.AppendLine(" }");
		_ = sb.AppendLine();
		_ = sb.AppendLine(" /// <summary>");
		_ = sb.AppendLine(" /// Invokes a precompiled direct action dispatch entry.");
		_ = sb.AppendLine(" /// </summary>");
		_ = sb.AppendLine(" public static ValueTask<object?> InvokeAsync(");
		_ = sb.AppendLine(" IDispatchAction action,");
		_ = sb.AppendLine(" IServiceProvider provider,");
		_ = sb.AppendLine(" IMessageContext? context,");
		_ = sb.AppendLine(" CancellationToken cancellationToken)");
		_ = sb.AppendLine(" {");
		_ = sb.AppendLine(" ArgumentNullException.ThrowIfNull(action);");
		_ = sb.AppendLine(" ArgumentNullException.ThrowIfNull(provider);");
		_ = sb.AppendLine();
		_ = sb.AppendLine(" return action switch");
		_ = sb.AppendLine(" {");

		foreach (var handler in actionHandlers)
		{
			var messageType = handler.MessageType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
			_ = sb.AppendLine($" {messageType} typedAction => Invoke_{SanitizeIdentifier(messageType)}(typedAction, provider, context, cancellationToken),");
		}

		_ = sb.AppendLine(" _ => throw new InvalidOperationException($\"No precompiled direct action dispatch entry found for {action.GetType().FullName}.\")");
		_ = sb.AppendLine(" };");
		_ = sb.AppendLine(" }");
		_ = sb.AppendLine();

		foreach (var handler in actionHandlers)
		{
			var messageType = handler.MessageType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
			var handlerType = handler.HandlerType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
			var interfaceType = handler.InterfaceType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
			var responseType = handler.ResponseType?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
			var contextProperty = FindMessageContextProperty(handler.HandlerType);
			var helperName = SanitizeIdentifier(messageType);

			_ = sb.AppendLine($" private static ValueTask<object?> Invoke_{helperName}(");
			_ = sb.AppendLine($" {messageType} action,");
			_ = sb.AppendLine(" IServiceProvider provider,");
			_ = sb.AppendLine(" IMessageContext? context,");
			_ = sb.AppendLine(" CancellationToken cancellationToken)");
			_ = sb.AppendLine(" {");

			if (contextProperty is not null)
			{
				_ = sb.AppendLine(" if (context is null)");
				_ = sb.AppendLine(" {");
				_ = sb.AppendLine($" throw new InvalidOperationException(\"Direct dispatch for {messageType} requires a non-null IMessageContext.\");");
				_ = sb.AppendLine(" }");
				_ = sb.AppendLine($" var handler = provider.GetRequiredService<{handlerType}>();");
				_ = sb.AppendLine($" handler.{contextProperty.Name} = context;");
			}
			else
			{
				_ = sb.AppendLine($" var handler = provider.GetRequiredService<{interfaceType}>();");
			}

			if (responseType is null)
			{
				_ = sb.AppendLine(" var task = handler.HandleAsync(action, cancellationToken);");
				_ = sb.AppendLine(" return task.IsCompletedSuccessfully");
				_ = sb.AppendLine(" ? NoResult");
				_ = sb.AppendLine(" : AwaitNoResultAsync(task);");
			}
			else
			{
				_ = sb.AppendLine(" var task = handler.HandleAsync(action, cancellationToken);");
				_ = sb.AppendLine(" return task.IsCompletedSuccessfully");
				_ = sb.AppendLine(" ? new ValueTask<object?>(task.Result)");
				_ = sb.AppendLine(" : AwaitResultAsync(task);");
			}

			_ = sb.AppendLine(" }");
			_ = sb.AppendLine();
		}

		_ = sb.AppendLine(" private static async ValueTask<object?> AwaitNoResultAsync(Task task)");
		_ = sb.AppendLine(" {");
		_ = sb.AppendLine(" await task.ConfigureAwait(false);");
		_ = sb.AppendLine(" return null;");
		_ = sb.AppendLine(" }");
		_ = sb.AppendLine();
		_ = sb.AppendLine(" private static async ValueTask<object?> AwaitResultAsync<TResult>(Task<TResult> task)");
		_ = sb.AppendLine(" {");
		_ = sb.AppendLine(" return await task.ConfigureAwait(false);");
		_ = sb.AppendLine(" }");
		_ = sb.AppendLine("}");

		context.AddSource("PrecompiledDirectActionDispatch.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
	}

	private static string SanitizeIdentifier(string typeName)
	{
		var sb = new StringBuilder(typeName.Length);
		for (var i = 0; i < typeName.Length; i++)
		{
			var c = typeName[i];
			if (char.IsLetterOrDigit(c))
			{
				_ = sb.Append(c);
			}
			else
			{
				_ = sb.Append('_');
			}
		}

		if (sb.Length == 0 || char.IsDigit(sb[0]))
		{
			_ = sb.Insert(0, '_');
		}

		return sb.ToString();
	}

	private IPropertySymbol? FindMessageContextProperty(INamedTypeSymbol handlerType)
	{
		var contextType = "Excalibur.Dispatch.Abstractions.IMessageContext";
		var nullableContextType = $"{contextType}?";

		foreach (var member in handlerType.GetMembers())
		{
			if (member is IPropertySymbol property &&
				(property.Type.ToDisplayString() == contextType || property.Type.ToDisplayString() == nullableContextType) &&
				property.SetMethod is { IsStatic: false } &&
				property.SetMethod.DeclaredAccessibility != Accessibility.Private)
			{
				return property;
			}
		}

		// Check base types
		var baseType = handlerType.BaseType;
		while (baseType != null)
		{
			foreach (var member in baseType.GetMembers())
			{
				if (member is IPropertySymbol property &&
					(property.Type.ToDisplayString() == contextType || property.Type.ToDisplayString() == nullableContextType) &&
					property.SetMethod is { IsStatic: false } &&
					property.SetMethod.DeclaredAccessibility != Accessibility.Private)
				{
					return property;
				}
			}

			baseType = baseType.BaseType;
		}

		return null;
	}

	private sealed class HandlerInfo
	{
		public INamedTypeSymbol HandlerType { get; set; } = null!;
		public INamedTypeSymbol InterfaceType { get; set; } = null!;
		public ITypeSymbol MessageType { get; set; } = null!;
		public ITypeSymbol? ResponseType { get; set; }
		public string HandlerKind { get; set; } = null!;
	}

	private sealed class HandlerTypeComparer : IEqualityComparer<HandlerInfo>
	{
		public bool Equals(HandlerInfo x, HandlerInfo y) => SymbolEqualityComparer.Default.Equals(x.HandlerType, y.HandlerType);

		public int GetHashCode(HandlerInfo obj) => SymbolEqualityComparer.Default.GetHashCode(obj.HandlerType);
	}
}
