// SPDX-FileCopyrightText: Copyright (c) 2026 The Excalibur Project
// SPDX-License-Identifier: LicenseRef-Excalibur-1.0 OR AGPL-3.0-or-later OR SSPL-1.0 OR Apache-2.0

using System.Collections.Immutable;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Excalibur.Dispatch.SourceGenerators.Saga;

/// <summary>
/// Incremental source generator that scans for methods decorated with [SagaStep]
/// and generates AddExcaliburSaga extension methods for automatic DI registration
/// of all discovered saga steps.
/// </summary>
[Generator]
public sealed class SagaRegistrationGenerator : IIncrementalGenerator
{
	private const string SagaStepAttributeName = "Excalibur.Saga.Attributes.SagaStepAttribute";

	/// <inheritdoc/>
	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		// Find all methods with [SagaStep] attribute
		var sagaStepMethods = context.SyntaxProvider
			.CreateSyntaxProvider(
				predicate: static (node, _) => node is MethodDeclarationSyntax { AttributeLists.Count: > 0 },
				transform: static (ctx, _) => GetSagaStepInfo(ctx))
			.Where(static info => info is not null)
			.Collect();

		context.RegisterSourceOutput(sagaStepMethods, GenerateRegistrationCode);
	}

	private static SagaStepInfo? GetSagaStepInfo(GeneratorSyntaxContext context)
	{
		var methodSyntax = (MethodDeclarationSyntax)context.Node;
		var methodSymbol = context.SemanticModel.GetDeclaredSymbol(methodSyntax);

		if (methodSymbol is null)
		{
			return null;
		}

		// Check if method has [SagaStep] attribute
		AttributeData? sagaStepAttr = null;
		foreach (var attr in methodSymbol.GetAttributes())
		{
			if (attr.AttributeClass?.ToDisplayString() == SagaStepAttributeName)
			{
				sagaStepAttr = attr;
				break;
			}
		}

		if (sagaStepAttr is null)
		{
			return null;
		}

		// Extract attribute properties
		var stepName = (string?)null;
		var order = 0;
		var timeoutSeconds = 0;

		foreach (var kvp in sagaStepAttr.NamedArguments)
		{
			switch (kvp.Key)
			{
				case "StepName":
					stepName = kvp.Value.Value as string;
					break;
				case "Order":
					if (kvp.Value.Value is int orderVal)
					{
						order = orderVal;
					}
					break;
				case "TimeoutSeconds":
					if (kvp.Value.Value is int timeoutVal)
					{
						timeoutSeconds = timeoutVal;
					}
					break;
			}
		}

		// Default step name to method name (minus "Async" suffix)
		if (string.IsNullOrEmpty(stepName))
		{
			stepName = methodSymbol.Name;
			if (stepName.EndsWith("Async", StringComparison.Ordinal))
			{
				stepName = stepName.Substring(0, stepName.Length - 5);
			}
		}

		// Get the containing class
		var containingType = methodSymbol.ContainingType;
		if (containingType is null)
		{
			return null;
		}

		return new SagaStepInfo
		{
			StepName = stepName!,
			MethodName = methodSymbol.Name,
			Order = order,
			TimeoutSeconds = timeoutSeconds,
			ContainingTypeFullName = containingType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
			ContainingTypeName = containingType.Name,
			ContainingNamespace = containingType.ContainingNamespace?.ToDisplayString() ?? string.Empty,
		};
	}

	private static void GenerateRegistrationCode(
		SourceProductionContext context,
		ImmutableArray<SagaStepInfo?> steps)
	{
		var validSteps = steps.Where(static s => s is not null).Cast<SagaStepInfo>().ToList();

		if (validSteps.Count == 0)
		{
			return;
		}

		// Group steps by containing saga class
		var sagaGroups = validSteps
			.GroupBy(static s => s.ContainingTypeFullName)
			.ToList();

		var sb = new StringBuilder();

		// File header
		sb.AppendLine("// <auto-generated/>");
		sb.AppendLine("#nullable enable");
		sb.AppendLine();
		sb.AppendLine("using System;");
		sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
		sb.AppendLine();
		sb.AppendLine("namespace Microsoft.Extensions.DependencyInjection;");
		sb.AppendLine();
		sb.AppendLine("/// <summary>");
		sb.AppendLine("/// Generated DI registration extensions for saga step auto-discovery.");
		sb.AppendLine("/// </summary>");
		sb.AppendLine("public static class GeneratedSagaRegistrationExtensions");
		sb.AppendLine("{");

		foreach (var group in sagaGroups)
		{
			var sagaType = group.Key;
			var sagaName = group.First().ContainingTypeName;
			var orderedSteps = group.OrderBy(static s => s.Order).ToList();

			sb.AppendLine($"    /// <summary>");
			sb.AppendLine($"    /// Registers all saga steps discovered in <see cref=\"{sagaType}\"/> ({orderedSteps.Count} steps).");
			sb.AppendLine($"    /// </summary>");
			sb.AppendLine($"    /// <param name=\"services\">The service collection.</param>");
			sb.AppendLine($"    /// <returns>The service collection for chaining.</returns>");
			sb.AppendLine($"    public static IServiceCollection AddExcaliburSaga_{sagaName}(this IServiceCollection services)");
			sb.AppendLine("    {");
			sb.AppendLine("        ArgumentNullException.ThrowIfNull(services);");
			sb.AppendLine();
			sb.AppendLine($"        // Register the saga class itself");
			sb.AppendLine($"        services.AddTransient({sagaType});");
			sb.AppendLine();

			foreach (var step in orderedSteps)
			{
				sb.AppendLine($"        // Step {step.Order}: {step.StepName} (method: {step.MethodName})");
			}

			sb.AppendLine();
			sb.AppendLine("        return services;");
			sb.AppendLine("    }");
			sb.AppendLine();
		}

		sb.AppendLine("}");

		// Report diagnostic about saga discovery
		context.ReportDiagnostic(Diagnostic.Create(
			new DiagnosticDescriptor(
				"SAGA001",
				"Saga Discovery Complete",
				"Discovered {0} saga step(s) across {1} saga(s) for registration",
				"Excalibur.Saga.Generators",
				DiagnosticSeverity.Info,
				isEnabledByDefault: true),
			Location.None,
			validSteps.Count,
			sagaGroups.Count));

		context.AddSource("GeneratedSagaRegistrationExtensions.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
	}

	private sealed class SagaStepInfo
	{
		public string StepName { get; set; } = string.Empty;
		public string MethodName { get; set; } = string.Empty;
		public int Order { get; set; }
		public int TimeoutSeconds { get; set; }
		public string ContainingTypeFullName { get; set; } = string.Empty;
		public string ContainingTypeName { get; set; } = string.Empty;
		public string ContainingNamespace { get; set; } = string.Empty;
	}
}
