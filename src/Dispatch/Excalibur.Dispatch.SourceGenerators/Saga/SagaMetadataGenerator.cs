// SPDX-FileCopyrightText: Copyright (c) 2026 The Excalibur Project
// SPDX-License-Identifier: LicenseRef-Excalibur-1.0 OR AGPL-3.0-or-later OR SSPL-1.0 OR Apache-2.0

using System.Collections.Immutable;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Excalibur.Dispatch.SourceGenerators.Saga;

/// <summary>
/// Incremental source generator that produces static metadata describing saga
/// structure including step names, ordering, and compensation mapping. This
/// metadata is used by the visualization tooling and runtime introspection.
/// </summary>
[Generator]
public sealed class SagaMetadataGenerator : IIncrementalGenerator
{
	private const string SagaStepAttributeName = "Excalibur.Saga.Attributes.SagaStepAttribute";
	private const string SagaCompensationAttributeName = "Excalibur.Saga.Attributes.SagaCompensationAttribute";

	/// <inheritdoc/>
	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		// Collect all methods with [SagaStep] or [SagaCompensation]
		var sagaMethods = context.SyntaxProvider
			.CreateSyntaxProvider(
				predicate: static (node, _) => node is MethodDeclarationSyntax { AttributeLists.Count: > 0 },
				transform: static (ctx, _) => GetSagaMethodInfo(ctx))
			.Where(static info => info is not null)
			.Collect();

		context.RegisterSourceOutput(sagaMethods, GenerateMetadata);
	}

	private static SagaMethodInfo? GetSagaMethodInfo(GeneratorSyntaxContext context)
	{
		var methodSyntax = (MethodDeclarationSyntax)context.Node;
		var methodSymbol = context.SemanticModel.GetDeclaredSymbol(methodSyntax);

		if (methodSymbol is null)
		{
			return null;
		}

		// Check for [SagaStep] or [SagaCompensation] attributes
		var stepName = (string?)null;
		var forStep = (string?)null;
		var order = 0;
		var timeoutSeconds = 0;
		var isStep = false;
		var isCompensation = false;

		foreach (var attr in methodSymbol.GetAttributes())
		{
			var attrName = attr.AttributeClass?.ToDisplayString();

			if (attrName == SagaStepAttributeName)
			{
				isStep = true;
				foreach (var kvp in attr.NamedArguments)
				{
					switch (kvp.Key)
					{
						case "StepName":
							stepName = kvp.Value.Value as string;
							break;
						case "Order":
							if (kvp.Value.Value is int orderVal)
							{
								order = orderVal;
							}
							break;
						case "TimeoutSeconds":
							if (kvp.Value.Value is int timeoutVal)
							{
								timeoutSeconds = timeoutVal;
							}
							break;
					}
				}
			}
			else if (attrName == SagaCompensationAttributeName)
			{
				isCompensation = true;
				foreach (var kvp in attr.NamedArguments)
				{
					switch (kvp.Key)
					{
						case "ForStep":
							forStep = kvp.Value.Value as string;
							break;
						case "Order":
							if (kvp.Value.Value is int compOrder)
							{
								order = compOrder;
							}
							break;
					}
				}
			}
		}

		if (!isStep && !isCompensation)
		{
			return null;
		}

		// Default step name to method name (minus "Async" suffix)
		if (isStep && string.IsNullOrEmpty(stepName))
		{
			stepName = methodSymbol.Name;
			if (stepName.EndsWith("Async", StringComparison.Ordinal))
			{
				stepName = stepName.Substring(0, stepName.Length - 5);
			}
		}

		var containingType = methodSymbol.ContainingType;
		if (containingType is null)
		{
			return null;
		}

		return new SagaMethodInfo
		{
			IsStep = isStep,
			IsCompensation = isCompensation,
			StepName = stepName ?? string.Empty,
			ForStep = forStep ?? string.Empty,
			MethodName = methodSymbol.Name,
			Order = order,
			TimeoutSeconds = timeoutSeconds,
			ContainingTypeFullName = containingType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
			ContainingTypeName = containingType.Name,
		};
	}

	private static void GenerateMetadata(
		SourceProductionContext context,
		ImmutableArray<SagaMethodInfo?> methods)
	{
		var validMethods = methods.Where(static m => m is not null).Cast<SagaMethodInfo>().ToList();

		if (validMethods.Count == 0)
		{
			return;
		}

		// Group by saga class
		var sagaGroups = validMethods
			.GroupBy(static m => m.ContainingTypeFullName)
			.ToList();

		var sb = new StringBuilder();

		sb.AppendLine("// <auto-generated/>");
		sb.AppendLine("#nullable enable");
		sb.AppendLine();
		sb.AppendLine("using System;");
		sb.AppendLine("using System.Collections.Generic;");
		sb.AppendLine("using System.Collections.Immutable;");
		sb.AppendLine();
		sb.AppendLine("namespace Excalibur.Saga.Generated;");
		sb.AppendLine();
		sb.AppendLine("/// <summary>");
		sb.AppendLine("/// Compile-time metadata describing discovered saga structures.");
		sb.AppendLine("/// </summary>");
		sb.AppendLine("public static class PrecompiledSagaMetadata");
		sb.AppendLine("{");

		// Generate step metadata record
		sb.AppendLine("    /// <summary>");
		sb.AppendLine("    /// Describes a single saga step discovered at compile time.");
		sb.AppendLine("    /// </summary>");
		sb.AppendLine("    public sealed class StepMetadata");
		sb.AppendLine("    {");
		sb.AppendLine("        /// <summary>Gets the step name.</summary>");
		sb.AppendLine("        public required string Name { get; init; }");
		sb.AppendLine("        /// <summary>Gets the method name implementing the step.</summary>");
		sb.AppendLine("        public required string MethodName { get; init; }");
		sb.AppendLine("        /// <summary>Gets the step execution order.</summary>");
		sb.AppendLine("        public required int Order { get; init; }");
		sb.AppendLine("        /// <summary>Gets the per-step timeout in seconds (0 = saga default).</summary>");
		sb.AppendLine("        public required int TimeoutSeconds { get; init; }");
		sb.AppendLine("        /// <summary>Gets the compensation method name, or null if none.</summary>");
		sb.AppendLine("        public string? CompensationMethodName { get; init; }");
		sb.AppendLine("        /// <summary>Gets a value indicating whether this step has a compensation handler.</summary>");
		sb.AppendLine("        public bool HasCompensation => CompensationMethodName is not null;");
		sb.AppendLine("    }");
		sb.AppendLine();

		// Generate saga metadata record
		sb.AppendLine("    /// <summary>");
		sb.AppendLine("    /// Describes a saga and its steps discovered at compile time.");
		sb.AppendLine("    /// </summary>");
		sb.AppendLine("    public sealed class SagaInfo");
		sb.AppendLine("    {");
		sb.AppendLine("        /// <summary>Gets the saga class name.</summary>");
		sb.AppendLine("        public required string Name { get; init; }");
		sb.AppendLine("        /// <summary>Gets the fully qualified type name.</summary>");
		sb.AppendLine("        public required string FullTypeName { get; init; }");
		sb.AppendLine("        /// <summary>Gets the ordered steps in this saga.</summary>");
		sb.AppendLine("        public required ImmutableArray<StepMetadata> Steps { get; init; }");
		sb.AppendLine("    }");
		sb.AppendLine();

		// Generate static metadata
		sb.AppendLine("    private static readonly ImmutableArray<SagaInfo> _sagas;");
		sb.AppendLine();
		sb.AppendLine("    static PrecompiledSagaMetadata()");
		sb.AppendLine("    {");
		sb.AppendLine("        var builder = ImmutableArray.CreateBuilder<SagaInfo>();");

		foreach (var group in sagaGroups)
		{
			var sagaType = group.Key;
			var sagaName = group.First().ContainingTypeName;

			var steps = group.Where(static m => m.IsStep).OrderBy(static m => m.Order).ToList();
			var compensations = group.Where(static m => m.IsCompensation)
				.ToDictionary(static m => m.ForStep, static m => m.MethodName, StringComparer.Ordinal);

			sb.AppendLine();
			sb.AppendLine($"        // Saga: {sagaName}");
			sb.AppendLine($"        builder.Add(new SagaInfo");
			sb.AppendLine("        {");
			sb.AppendLine($"            Name = \"{EscapeString(sagaName)}\",");
			sb.AppendLine($"            FullTypeName = \"{EscapeString(sagaType)}\",");
			sb.AppendLine("            Steps = ImmutableArray.Create(new StepMetadata[]");
			sb.AppendLine("            {");

			foreach (var step in steps)
			{
				compensations.TryGetValue(step.StepName, out var compMethod);

				sb.AppendLine("                new StepMetadata");
				sb.AppendLine("                {");
				sb.AppendLine($"                    Name = \"{EscapeString(step.StepName)}\",");
				sb.AppendLine($"                    MethodName = \"{EscapeString(step.MethodName)}\",");
				sb.AppendLine($"                    Order = {step.Order},");
				sb.AppendLine($"                    TimeoutSeconds = {step.TimeoutSeconds},");
				if (compMethod is not null)
				{
					sb.AppendLine($"                    CompensationMethodName = \"{EscapeString(compMethod)}\",");
				}
				sb.AppendLine("                },");
			}

			sb.AppendLine("            }),");
			sb.AppendLine("        });");
		}

		sb.AppendLine();
		sb.AppendLine("        _sagas = builder.ToImmutable();");
		sb.AppendLine("    }");
		sb.AppendLine();

		// Public API
		sb.AppendLine("    /// <summary>");
		sb.AppendLine("    /// Gets all discovered sagas and their metadata.");
		sb.AppendLine("    /// </summary>");
		sb.AppendLine("    public static ImmutableArray<SagaInfo> GetAllSagas() => _sagas;");
		sb.AppendLine();
		sb.AppendLine("    /// <summary>");
		sb.AppendLine("    /// Gets saga metadata by class name.");
		sb.AppendLine("    /// </summary>");
		sb.AppendLine("    /// <param name=\"sagaName\">The saga class name.</param>");
		sb.AppendLine("    /// <returns>The saga info, or null if not found.</returns>");
		sb.AppendLine("    public static SagaInfo? GetSaga(string sagaName)");
		sb.AppendLine("    {");
		sb.AppendLine("        foreach (var saga in _sagas)");
		sb.AppendLine("        {");
		sb.AppendLine("            if (string.Equals(saga.Name, sagaName, StringComparison.Ordinal))");
		sb.AppendLine("            {");
		sb.AppendLine("                return saga;");
		sb.AppendLine("            }");
		sb.AppendLine("        }");
		sb.AppendLine("        return null;");
		sb.AppendLine("    }");

		sb.AppendLine("}");

		context.AddSource("PrecompiledSagaMetadata.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
	}

	private static string EscapeString(string value) =>
		value.Replace("\\", "\\\\").Replace("\"", "\\\"");

	private sealed class SagaMethodInfo
	{
		public bool IsStep { get; set; }
		public bool IsCompensation { get; set; }
		public string StepName { get; set; } = string.Empty;
		public string ForStep { get; set; } = string.Empty;
		public string MethodName { get; set; } = string.Empty;
		public int Order { get; set; }
		public int TimeoutSeconds { get; set; }
		public string ContainingTypeFullName { get; set; } = string.Empty;
		public string ContainingTypeName { get; set; } = string.Empty;
	}
}
