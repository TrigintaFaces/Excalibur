// SPDX-FileCopyrightText: Copyright (c) 2026 The Excalibur Project
// SPDX-License-Identifier: LicenseRef-Excalibur-1.0 OR AGPL-3.0-or-later OR SSPL-1.0 OR Apache-2.0


using System.Collections.Immutable;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Excalibur.Dispatch.SourceGenerators;

/// <summary>
/// Source generator that creates compile-time registry for projection tag resolvers.
/// This eliminates runtime reflection when resolving projection tags for dispatch caching.
/// </summary>
[Generator]
public sealed class ProjectionTagResolverGenerator : IIncrementalGenerator
{
	/// <summary>
	/// Initializes the projection tag resolver source generator with the given context.
	/// Sets up syntax providers to find class declarations that implement IProjectionTagResolver&lt;T&gt;
	/// and registers source output generation for compile-time projection tag resolver registry.
	/// </summary>
	/// <param name="context">The generator initialization context providing access to syntax providers and source output registration.</param>
	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		// Create an incremental value provider for the compilation
		var compilationProvider = context.CompilationProvider;

		// Create an incremental value provider for class declarations that might implement the resolver interface
		var classDeclarationsProvider = context.SyntaxProvider
			.CreateSyntaxProvider(
				predicate: static (node, _) => IsClassDeclarationWithInterfaces(node),
				transform: static (ctx, _) => GetClassDeclarationSymbol(ctx))
			.Where(static result => result is not null)
			.Select(static (result, _) => result!);

		// Combine the compilation and class declarations
		var combined = compilationProvider.Combine(classDeclarationsProvider.Collect());

		// Register the source generator
		context.RegisterSourceOutput(combined, static (ctx, source) => Execute(ctx, source.Left, source.Right));
	}

	private static bool IsClassDeclarationWithInterfaces(SyntaxNode node) => node is ClassDeclarationSyntax { BaseList: not null };

	private static INamedTypeSymbol? GetClassDeclarationSymbol(GeneratorSyntaxContext context)
	{
		var classDeclaration = (ClassDeclarationSyntax)context.Node;
		return context.SemanticModel.GetDeclaredSymbol(classDeclaration) as INamedTypeSymbol;
	}

	private static void Execute(SourceProductionContext context, Compilation compilation, ImmutableArray<INamedTypeSymbol> classSymbols)
	{
		// Sprint 330 T1.2: Namespace updated from Excalibur.Dispatch.Caching to Excalibur.Caching.Projections (AD-330-2)
		var resolverInterface = compilation.GetTypeByMetadataName("Excalibur.Caching.Projections.IProjectionTagResolver`1");

		if (resolverInterface == null)
		{
			return;
		}

		var resolvers = new List<(INamedTypeSymbol ResolverType, INamedTypeSymbol MessageType)>();

		// Process the filtered class symbols instead of iterating through all syntax trees
		foreach (var classSymbol in classSymbols)
		{
			if (classSymbol == null)
			{
				continue;
			}

			foreach (var iface in classSymbol.AllInterfaces)
			{
				if (iface.ConstructedFrom.Equals(resolverInterface, SymbolEqualityComparer.Default))
				{
					if (iface.TypeArguments[0] is INamedTypeSymbol messageType)
					{
						resolvers.Add((classSymbol, messageType));
					}
				}
			}
		}

		if (resolvers.Count > 0)
		{
			var source = GenerateRegistryClass(resolvers);
			context.AddSource("ProjectionTagResolverRegistry.g.cs", source);
		}
	}

	private static string GenerateRegistryClass(List<(INamedTypeSymbol ResolverType, INamedTypeSymbol MessageType)> resolvers)
	{
		var sb = new StringBuilder();
		_ = sb.AppendLine("// <auto-generated/>");
		_ = sb.AppendLine("using System;");
		_ = sb.AppendLine("using System.Collections.Generic;");
		_ = sb.AppendLine("using System.Linq;");
		_ = sb.AppendLine();
		_ = sb.AppendLine("namespace Excalibur.Dispatch.Generated");
		_ = sb.AppendLine("{");
		_ = sb.AppendLine(" public static class ProjectionTagResolverRegistry");
		_ = sb.AppendLine(" {");
		_ = sb.AppendLine(" private static readonly Dictionary<Type, Func<IServiceProvider, object>> _resolverFactories = new()");
		_ = sb.AppendLine(" {");

		foreach (var (resolverType, messageType) in resolvers)
		{
			var resolverFullName = GetFullTypeName(resolverType);
			var messageFullName = GetFullTypeName(messageType);

			_ = sb.AppendLine($" {{ typeof({messageFullName}), sp => ");

			if (HasParameterlessConstructor(resolverType))
			{
				_ = sb.AppendLine($" new {resolverFullName}() }},");
			}
			else
			{
				_ = sb.AppendLine(
					$" sp.GetService(typeof({resolverFullName})) ?? throw new InvalidOperationException(\"Could not resolve {resolverFullName}\") }},");
			}
		}

		_ = sb.AppendLine(" };");
		_ = sb.AppendLine();
		_ = sb.AppendLine(" public static bool HasResolver(Type messageType)");
		_ = sb.AppendLine(" {");
		_ = sb.AppendLine(" return _resolverFactories.ContainsKey(messageType);");
		_ = sb.AppendLine(" }");
		_ = sb.AppendLine();
		_ = sb.AppendLine(" public static object? GetResolver(Type messageType, IServiceProvider serviceProvider)");
		_ = sb.AppendLine(" {");
		_ = sb.AppendLine(
			" return _resolverFactories.TryGetValue(messageType, out var factory) ? factory(serviceProvider) : null;");
		_ = sb.AppendLine(" }");
		_ = sb.AppendLine();
		_ = sb.AppendLine(" public static IEnumerable<string> GetProjectionTags(object message, IServiceProvider serviceProvider)");
		_ = sb.AppendLine(" {");
		_ = sb.AppendLine(" var messageType = message.GetType();");
		_ = sb.AppendLine(" var resolver = GetResolver(messageType, serviceProvider);");
		_ = sb.AppendLine(" if (resolver == null) return Enumerable.Empty<string>();");
		_ = sb.AppendLine();
		_ = sb.AppendLine(" var getTagsMethod = resolver.GetType().GetMethod(\"GetTags\");");
		_ = sb.AppendLine(" if (getTagsMethod == null) return Enumerable.Empty<string>();");
		_ = sb.AppendLine();
		_ = sb.AppendLine(
			" return (IEnumerable<string>)getTagsMethod.Invoke(resolver, new[] { message }) ?? Enumerable.Empty<string>();");
		_ = sb.AppendLine(" }");
		_ = sb.AppendLine(" }");
		_ = sb.AppendLine("}");

		return sb.ToString();
	}

	private static string GetFullTypeName(ITypeSymbol type) =>
		type.ToDisplayString(new SymbolDisplayFormat(
			typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,
			genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters));

	private static bool HasParameterlessConstructor(INamedTypeSymbol type) =>
		type.Constructors.Any(static c => c.Parameters.Length == 0 && c.DeclaredAccessibility == Accessibility.Public);
}
