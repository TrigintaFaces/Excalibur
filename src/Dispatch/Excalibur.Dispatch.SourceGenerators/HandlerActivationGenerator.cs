// SPDX-FileCopyrightText: Copyright (c) 2026 The Excalibur Project
// SPDX-License-Identifier: LicenseRef-Excalibur-1.0 OR AGPL-3.0-or-later OR SSPL-1.0 OR Apache-2.0


using System.Collections.Immutable;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Excalibur.Dispatch.SourceGenerators;

/// <summary>
/// Generates AOT-compatible handler activation code to replace runtime expression compilation.
/// </summary>
[Generator]
public sealed class HandlerActivationGenerator : IIncrementalGenerator
{
	/// <summary>
	/// Initializes the incremental generator pipeline.
	/// </summary>
	/// <param name="context">The generator initialization context.</param>
	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		// Find all classes that implement message handler interfaces
		var handlerProvider = context.SyntaxProvider
			.CreateSyntaxProvider(
				predicate: static (s, _) => IsHandlerClass(s),
				transform: static (ctx, _) => GetHandlerInfo(ctx))
			.Where(static h => h is not null)
			.Collect();

		context.RegisterSourceOutput(handlerProvider, static (spc, handlers) => GenerateHandlerActivation(spc, handlers!));
	}

	/// <summary>
	/// Determines if a syntax node represents a potential handler class.
	/// </summary>
	/// <param name="node">The syntax node to examine.</param>
	/// <returns>True if the node could be a handler class.</returns>
	private static bool IsHandlerClass(SyntaxNode node) =>
		node is ClassDeclarationSyntax { BaseList: not null } classDecl &&
		classDecl.Modifiers.Any(SyntaxKind.PublicKeyword) &&
		!classDecl.Modifiers.Any(SyntaxKind.AbstractKeyword);

	/// <summary>
	/// Extracts handler information from a generator transform context.
	/// </summary>
	/// <param name="context">The generator syntax context.</param>
	/// <returns>Handler information if valid, null otherwise.</returns>
	private static HandlerInfo? GetHandlerInfo(GeneratorSyntaxContext context)
	{
		var classDecl = (ClassDeclarationSyntax)context.Node;
		var model = context.SemanticModel;
		var symbol = model.GetDeclaredSymbol(classDecl);

		if (symbol is not INamedTypeSymbol classSymbol)
		{
			return null;
		}

		// Check if class implements a handler interface (ICommandHandler, IEventHandler, etc.)
		var handlerInterfaces = classSymbol.AllInterfaces
			.Where(IsHandlerInterface)
			.ToArray();

		if (handlerInterfaces.Length == 0)
		{
			return null;
		}

		// Find IMessageContext property
		var contextProperty = classSymbol.GetMembers()
			.OfType<IPropertySymbol>()
			.FirstOrDefault(static p => p.SetMethod != null &&
										p.Type.Name == "IMessageContext" &&
										p.DeclaredAccessibility is Accessibility.Public or Accessibility.Internal);

		return new HandlerInfo(
			classSymbol.ToDisplayString(),
			contextProperty?.Name,
			[.. handlerInterfaces.Select(static i => i.ToDisplayString())]);
	}

	/// <summary>
	/// Determines if a type symbol represents a handler interface.
	/// </summary>
	/// <param name="interfaceSymbol">The interface symbol to check.</param>
	/// <returns>True if this is a handler interface.</returns>
	private static bool IsHandlerInterface(INamedTypeSymbol interfaceSymbol)
	{
		var name = interfaceSymbol.Name;
		return name.EndsWith("Handler", StringComparison.Ordinal) &&
				 (name.StartsWith("ICommand", StringComparison.Ordinal) || name.StartsWith("IEvent", StringComparison.Ordinal) ||
				name.StartsWith("IQuery", StringComparison.Ordinal));
	}

	/// <summary>
	/// Generates the handler activation source code.
	/// </summary>
	/// <param name="context">The source production context.</param>
	/// <param name="handlers">Collection of handler information.</param>
	private static void GenerateHandlerActivation(SourceProductionContext context, ImmutableArray<HandlerInfo> handlers)
	{
		var source = new StringBuilder();

		_ = source.AppendLine("""
			// <auto-generated />
			#nullable enable

			using System;
			using System.Diagnostics.CodeAnalysis;
			using Excalibur.Dispatch.Abstractions;
			using Microsoft.Extensions.DependencyInjection;

			namespace Excalibur.Dispatch.Delivery.Handlers;

			/// <summary>
			/// AOT-compatible handler activator generated at compile time.
			/// </summary>
			public sealed class SourceGeneratedHandlerActivator : IHandlerActivator
			{
				/// <summary>
				/// Activates a handler instance and sets its context property if available.
				/// </summary>
				/// <param name="handlerType">The type of handler to activate.</param>
				/// <param name="context">The message context to inject.</param>
				/// <param name="provider">The service provider for dependency injection.</param>
				/// <returns>The activated handler instance.</returns>
				[RequiresUnreferencedCode("Handler activation may require reflection to instantiate handler types")]
				public object ActivateHandler([DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicProperties)] Type handlerType, IMessageContext context, IServiceProvider provider)
				{
					var handler = provider.GetRequiredService(handlerType);
					SetHandlerContext(handler, context);
					return handler;
				}

				/// <summary>
				/// Sets the message context on a handler if it has a compatible property.
				/// </summary>
				/// <param name="handler">The handler instance.</param>
				/// <param name="context">The message context to set.</param>
				private static void SetHandlerContext(object handler, IMessageContext context)
				{
					switch (handler)
					{
			""");

		foreach (var handler in handlers)
		{
			if (handler.ContextPropertyName is not null)
			{
				_ = source.AppendLine($"""
							case {handler.FullName} typedHandler:
								typedHandler.{handler.ContextPropertyName} = context;
								break;
			""");
			}
		}

		// Always include a default case to avoid empty switch block
		_ = source.AppendLine("""
						default:
							// No context property found on handler
							break;
					}
				}
			}
			""");

		context.AddSource("SourceGeneratedHandlerActivator.g.cs", source.ToString());
	}

	/// <summary>
	/// Information about a handler class discovered during compilation.
	/// </summary>
	private sealed class HandlerInfo(string fullName, string? contextPropertyName, string[] handlerInterfaces)
	{
		/// <summary>
		/// The fully qualified name of the handler class.
		/// </summary>
		public string FullName { get; } = fullName;

		/// <summary>
		/// The name of the IMessageContext property, if any.
		/// </summary>
		public string? ContextPropertyName { get; } = contextPropertyName;

		/// <summary>
		/// The handler interfaces implemented by this class.
		/// </summary>
		public string[] HandlerInterfaces { get; } = handlerInterfaces;
	}
}
