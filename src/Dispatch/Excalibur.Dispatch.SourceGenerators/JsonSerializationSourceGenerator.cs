// SPDX-FileCopyrightText: Copyright (c) 2026 The Excalibur Project
// SPDX-License-Identifier: LicenseRef-Excalibur-1.0 OR AGPL-3.0-or-later OR SSPL-1.0 OR Apache-2.0


// using System.Diagnostics.Metrics; // Not available in netstandard2.0


using System.Collections.Immutable;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Excalibur.Dispatch.SourceGenerators;

/// <summary>
/// Source generator that creates System.Text.Json serialization contexts for message types.
/// Generates JsonSerializerContext implementations for AOT-friendly JSON serialization.
/// </summary>
[Generator]
public sealed class JsonSerializationSourceGenerator : IIncrementalGenerator
{
	/// <summary>
	/// Initializes the JSON serialization source generator with the given context.
	/// Sets up syntax providers to find message types and registers source output generation
	/// for compile-time JsonSerializerContext creation for AOT-compatible serialization.
	/// </summary>
	/// <param name="context">The generator initialization context providing access to syntax providers and source output registration.</param>
	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		// Find all types that implement IDispatchMessage
		var messageTypes = context.SyntaxProvider
			.CreateSyntaxProvider(
				predicate: static (node, _) => node is ClassDeclarationSyntax or RecordDeclarationSyntax,
				transform: static (ctx, _) => GetMessageTypeInfo(ctx))
			.Where(static info => info.HasValue)
			.Select(static (info, _) => info!.Value);

		// Collect all message types
		var collectedTypes = messageTypes.Collect();

		// Generate the source
		context.RegisterSourceOutput(collectedTypes, GenerateJsonContext);
	}

	private static MessageTypeInfo? GetMessageTypeInfo(GeneratorSyntaxContext context)
	{
		var symbol = context.SemanticModel.GetDeclaredSymbol(context.Node);
		if (symbol is not INamedTypeSymbol typeSymbol)
		{
			return null;
		}

		// Skip generic types with unbound type parameters
		if (typeSymbol.IsGenericType && typeSymbol.TypeParameters.Any())
		{
			return null;
		}

		// Skip non-public types (they can't be referenced in generated code)
		if (typeSymbol.DeclaredAccessibility != Accessibility.Public)
		{
			return null;
		}

		// Also check that all containing types are public (for nested types)
		var containingType = typeSymbol.ContainingType;
		while (containingType is not null)
		{
			if (containingType.DeclaredAccessibility != Accessibility.Public)
			{
				return null;
			}

			containingType = containingType.ContainingType;
		}

		// Check if it implements IDispatchMessage
		var implementsDispatchMessage = typeSymbol.AllInterfaces.Any(static i =>
			i.ToDisplayString() is "global::Excalibur.Dispatch.Abstractions.IDispatchMessage" or
				"Excalibur.Dispatch.Abstractions.IDispatchMessage");

		if (!implementsDispatchMessage)
		{
			return null;
		}

		return new MessageTypeInfo
		{
			FullName = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
			Name = typeSymbol.Name,
			Namespace = typeSymbol.ContainingNamespace.ToDisplayString(),
			IsAbstract = typeSymbol.IsAbstract
		};
	}

	private static void GenerateJsonContext(SourceProductionContext context, ImmutableArray<MessageTypeInfo> messageTypes)
	{
		var concreteTypes = messageTypes.IsDefaultOrEmpty
			? Array.Empty<MessageTypeInfo>()
			: messageTypes.Where(static m => !m.IsAbstract).ToArray();

		// Generate the type name registry (existing output)
		GenerateTypeRegistry(context, concreteTypes);

		// Generate the JsonSerializerContext partial class (new output)
		GenerateJsonSerializerContext(context, concreteTypes);

		// Report diagnostic
		context.ReportDiagnostic(Diagnostic.Create(
			new DiagnosticDescriptor(
				"JSON001",
				"JSON Context Generation Complete",
				$"Generated AOT-compatible JSON context with {concreteTypes.Length} message type(s) and common framework types",
				"Excalibur.Dispatch.Serialization",
				DiagnosticSeverity.Info,
				isEnabledByDefault: true),
			Location.None));
	}

	private static void GenerateTypeRegistry(SourceProductionContext context, MessageTypeInfo[] concreteTypes)
	{
		var sb = new StringBuilder();

		_ = sb.AppendLine("// <auto-generated/>");
		_ = sb.AppendLine("#nullable enable");
		_ = sb.AppendLine();
		_ = sb.AppendLine("using System.Text.Json;");
		_ = sb.AppendLine("using System.Text.Json.Serialization;");
		_ = sb.AppendLine("using System.Collections.Generic;");
		_ = sb.AppendLine();
		_ = sb.AppendLine("namespace Excalibur.Dispatch.Serialization;");
		_ = sb.AppendLine();

		_ = sb.AppendLine("/// <summary>");
		_ = sb.AppendLine("/// AOT-compatible type registry for discovered message types.");
		_ = sb.AppendLine("/// </summary>");
		_ = sb.AppendLine("public static class DiscoveredMessageTypeRegistry");
		_ = sb.AppendLine("{");
		_ = sb.AppendLine("    /// <summary>");
		_ = sb.AppendLine("    /// Gets all discovered message type names for AOT compilation.");
		_ = sb.AppendLine("    /// </summary>");
		_ = sb.AppendLine("    public static readonly HashSet<string> MessageTypeNames = new()");
		_ = sb.AppendLine("    {");

		foreach (var messageType in concreteTypes)
		{
			_ = sb.AppendLine($"        \"{messageType.FullName}\",");
		}

		_ = sb.AppendLine("    };");
		_ = sb.AppendLine("}");

		context.AddSource("DiscoveredMessageTypeRegistry.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
	}

	private static void GenerateJsonSerializerContext(SourceProductionContext context, MessageTypeInfo[] concreteTypes)
	{
		var sb = new StringBuilder();

		_ = sb.AppendLine("// <auto-generated/>");
		_ = sb.AppendLine("#nullable enable");
		_ = sb.AppendLine();
		_ = sb.AppendLine("using System;");
		_ = sb.AppendLine("using System.Collections.Generic;");
		_ = sb.AppendLine("using System.Collections.Immutable;");
		_ = sb.AppendLine("using System.Text.Json.Serialization.Metadata;");
		_ = sb.AppendLine();
		_ = sb.AppendLine("namespace Excalibur.Dispatch.Serialization;");
		_ = sb.AppendLine();
		_ = sb.AppendLine("/// <summary>");
		_ = sb.AppendLine("/// Provides a compile-time registry of discovered message types for AOT JSON serialization.");
		_ = sb.AppendLine("/// Consumers should create their own <c>JsonSerializerContext</c> partial class and include");
		_ = sb.AppendLine("/// <c>[JsonSerializable]</c> attributes for each type returned by <see cref=\"MessageTypes\"/>.");
		_ = sb.AppendLine("/// </summary>");
		_ = sb.AppendLine("/// <example>");
		_ = sb.AppendLine("/// <code>");
		_ = sb.AppendLine("/// // In consumer code, create a partial class with all discovered message types:");

		if (concreteTypes.Length > 0)
		{
			foreach (var messageType in concreteTypes)
			{
				_ = sb.AppendLine($"/// [JsonSerializable(typeof({messageType.FullName}))]");
			}
		}
		else
		{
			_ = sb.AppendLine("/// [JsonSerializable(typeof(MyCommand))]");
		}

		_ = sb.AppendLine("/// public partial class AppJsonSerializerContext : JsonSerializerContext {{ }}");
		_ = sb.AppendLine("/// </code>");
		_ = sb.AppendLine("/// </example>");
		_ = sb.AppendLine("public static class DiscoveredMessageTypeMetadata");
		_ = sb.AppendLine("{");
		_ = sb.AppendLine("    /// <summary>");
		_ = sb.AppendLine($"    /// Gets all {concreteTypes.Length} discovered concrete message types (compile-time).");
		_ = sb.AppendLine("    /// </summary>");
		_ = sb.AppendLine("    public static IReadOnlyList<Type> MessageTypes { get; } = ImmutableArray.Create(new Type[]");
		_ = sb.AppendLine("    {");

		foreach (var messageType in concreteTypes)
		{
			_ = sb.AppendLine($"        typeof({messageType.FullName}),");
		}

		_ = sb.AppendLine("    });");
		_ = sb.AppendLine();
		_ = sb.AppendLine("    /// <summary>");
		_ = sb.AppendLine("    /// Checks whether a given type is a discovered message type.");
		_ = sb.AppendLine("    /// </summary>");
		_ = sb.AppendLine("    public static bool IsMessageType(Type type)");
		_ = sb.AppendLine("    {");

		if (concreteTypes.Length > 0)
		{
			_ = sb.AppendLine("        return type switch");
			_ = sb.AppendLine("        {");
			foreach (var messageType in concreteTypes)
			{
				_ = sb.AppendLine($"            Type t when t == typeof({messageType.FullName}) => true,");
			}
			_ = sb.AppendLine("            _ => false");
			_ = sb.AppendLine("        };");
		}
		else
		{
			_ = sb.AppendLine("        return false;");
		}

		_ = sb.AppendLine("    }");
		_ = sb.AppendLine();
		_ = sb.AppendLine("    /// <summary>");
		_ = sb.AppendLine("    /// Attempts to get <see cref=\"JsonTypeInfo\"/> for a message type from the provided context.");
		_ = sb.AppendLine("    /// </summary>");
		_ = sb.AppendLine("    public static JsonTypeInfo? GetTypeInfo(System.Text.Json.Serialization.JsonSerializerContext jsonContext, Type messageType)");
		_ = sb.AppendLine("    {");
		_ = sb.AppendLine("        return jsonContext.GetTypeInfo(messageType);");
		_ = sb.AppendLine("    }");
		_ = sb.AppendLine("}");

		context.AddSource("DiscoveredMessageTypeMetadata.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
	}

	private struct MessageTypeInfo
	{
		public string FullName { get; set; }
		public string Name { get; set; }
		public string Namespace { get; set; }
		public bool IsAbstract { get; set; }
	}
}

