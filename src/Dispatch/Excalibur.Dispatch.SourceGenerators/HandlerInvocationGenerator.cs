// SPDX-FileCopyrightText: Copyright (c) 2026 The Excalibur Project
// SPDX-License-Identifier: LicenseRef-Excalibur-1.0 OR AGPL-3.0-or-later OR SSPL-1.0 OR Apache-2.0


using System.Collections.Immutable;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Excalibur.Dispatch.SourceGenerators;

/// <summary>
/// Generates AOT-compatible handler invocation code to replace runtime expression compilation.
/// </summary>
[Generator]
public sealed class HandlerInvocationGenerator : IIncrementalGenerator
{
	/// <summary>
	/// Initializes the incremental generator pipeline.
	/// </summary>
	/// <param name="context">The generator initialization context.</param>
	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		// Find all classes that implement message handler interfaces with HandleAsync methods
		var handlerProvider = context.SyntaxProvider
			.CreateSyntaxProvider(
				predicate: static (s, _) => IsHandlerClass(s),
				transform: static (ctx, _) => GetHandlerInvocationInfo(ctx))
			.Where(static h => h is not null)
			.Collect();

		context.RegisterSourceOutput(handlerProvider, static (spc, handlers) => GenerateHandlerInvocation(spc, handlers!));
	}

	/// <summary>
	/// Determines if a syntax node represents a potential handler class.
	/// </summary>
	/// <param name="node">The syntax node to examine.</param>
	/// <returns>True if the node could be a handler class.</returns>
	private static bool IsHandlerClass(SyntaxNode node) =>
		node is ClassDeclarationSyntax { BaseList: not null } classDecl &&
		classDecl.Modifiers.Any(SyntaxKind.PublicKeyword) &&
		!classDecl.Modifiers.Any(SyntaxKind.AbstractKeyword);

	/// <summary>
	/// Extracts handler invocation information from a generator transform context.
	/// </summary>
	/// <param name="context">The generator syntax context.</param>
	/// <returns>Handler invocation information if valid, null otherwise.</returns>
	private static HandlerInvocationInfo? GetHandlerInvocationInfo(GeneratorSyntaxContext context)
	{
		var classDecl = (ClassDeclarationSyntax)context.Node;
		var model = context.SemanticModel;
		var symbol = model.GetDeclaredSymbol(classDecl);

		if (symbol is not INamedTypeSymbol classSymbol)
		{
			return null;
		}

		// Check if class implements a handler interface
		var handlerInterfaces = classSymbol.AllInterfaces
			.Where(IsHandlerInterface)
			.ToArray();

		if (handlerInterfaces.Length == 0)
		{
			return null;
		}

		// Find HandleAsync method
		var handleMethod = classSymbol.GetMembers("HandleAsync")
			.OfType<IMethodSymbol>()
			.FirstOrDefault(static m => m.DeclaredAccessibility == Accessibility.Public &&
										m.Parameters.Length == 2 &&
										m.Parameters[1].Type.Name == "CancellationToken");

		if (handleMethod is null)
		{
			return null;
		}

		var messageType = handleMethod.Parameters[0].Type.ToDisplayString();
		var returnType = handleMethod.ReturnType.ToDisplayString();
		var isTaskOfT = returnType.StartsWith("System.Threading.Tasks.Task<", StringComparison.Ordinal) &&
						!returnType.EndsWith("Task<object?>", StringComparison.Ordinal);

		return new HandlerInvocationInfo(
			classSymbol.ToDisplayString(),
			messageType,
			returnType,
			isTaskOfT);
	}

	/// <summary>
	/// Determines if a type symbol represents a handler interface.
	/// </summary>
	/// <param name="interfaceSymbol">The interface symbol to check.</param>
	/// <returns>True if this is a handler interface.</returns>
	private static bool IsHandlerInterface(INamedTypeSymbol interfaceSymbol)
	{
		var name = interfaceSymbol.Name;
		return name.EndsWith("Handler", StringComparison.Ordinal) &&
				 (name.StartsWith("ICommand", StringComparison.Ordinal) || name.StartsWith("IEvent", StringComparison.Ordinal) ||
				name.StartsWith("IQuery", StringComparison.Ordinal));
	}

	/// <summary>
	/// Generates the handler invocation source code.
	/// </summary>
	/// <param name="context">The source production context.</param>
	/// <param name="handlers">Collection of handler invocation information.</param>
	private static void GenerateHandlerInvocation(SourceProductionContext context, ImmutableArray<HandlerInvocationInfo> handlers)
	{
		var source = new StringBuilder();

		_ = source.AppendLine("""
		// <auto-generated />
		#nullable enable

		using System;
		using System.Diagnostics.CodeAnalysis;
		using System.Threading;
		using System.Threading.Tasks;
		using Excalibur.Dispatch.Abstractions;

		namespace Excalibur.Dispatch.Delivery.Handlers;

		/// <summary>
		/// AOT-compatible handler invoker generated at compile time.
		/// </summary>
		public sealed class SourceGeneratedHandlerInvoker : IHandlerInvoker
		{
			/// <summary>
			/// Invokes a handler's HandleAsync method with the provided message.
			/// </summary>
			/// <param name="handler">The handler instance to invoke.</param>
			/// <param name="message">The message to handle.</param>
			/// <param name="cancellationToken">Cancellation token for the operation.</param>
			/// <returns>The result of handler execution, or null for void handlers.</returns>
			[RequiresUnreferencedCode("Handler invocation may require reflection to call handler methods")]
			public Task<object?> InvokeAsync(object handler, IDispatchMessage message, CancellationToken cancellationToken)
			{
				ArgumentNullException.ThrowIfNull(handler);
				ArgumentNullException.ThrowIfNull(message);

				return handler switch
				{
		""");

		foreach (var handler in handlers)
		{
			_ = source.AppendLine($"""
					{handler.HandlerType} typedHandler when message is {handler.MessageType} typedMessage =>
						{GetInvocationCode(handler)},
			""");
		}

		_ = source.AppendLine("""
					_ => throw new InvalidOperationException($"No handler found for {handler.GetType()} with message {message.GetType()}")
				};
			}

			/// <summary>
			/// Converts a Task to Task of object by returning null when complete.
			/// </summary>
			/// <param name="task">The task to convert.</param>
			/// <returns>A task that returns null when the input task completes.</returns>
			private static async Task<object?> ConvertTaskToTaskOfObject(Task task)
			{
				await task.ConfigureAwait(false);
				return null;
			}

			/// <summary>
			/// Converts a Task of T to Task of object by casting the result.
			/// </summary>
			/// <typeparam name="T">The type of the task result.</typeparam>
			/// <param name="task">The task to convert.</param>
			/// <returns>A task that returns the result as object.</returns>
			private static async Task<object?> ConvertTaskOfTToTaskOfObject<T>(Task<T> task)
			{
				var result = await task.ConfigureAwait(false);
				return result;
			}
		}
		""");

		context.AddSource("SourceGeneratedHandlerInvoker.g.cs", source.ToString());
	}

	/// <summary>
	/// Generates the appropriate invocation code based on handler return type.
	/// </summary>
	/// <param name="handler">The handler information.</param>
	/// <returns>C# code for invoking the handler.</returns>
	private static string GetInvocationCode(HandlerInvocationInfo handler)
	{
		if (handler.ReturnType == "System.Threading.Tasks.Task")
		{
			return "ConvertTaskToTaskOfObject(typedHandler.HandleAsync(typedMessage, cancellationToken))";
		}

		if (handler.IsTaskOfT)
		{
			return "ConvertTaskOfTToTaskOfObject(typedHandler.HandleAsync(typedMessage, cancellationToken))";
		}

		// Default case - assume Task<object?> or compatible
		return "typedHandler.HandleAsync(typedMessage, cancellationToken)";
	}

	/// <summary>
	/// Information about a handler's invocation requirements.
	/// </summary>
	private sealed class HandlerInvocationInfo(string handlerType, string messageType, string returnType, bool isTaskOfT)
	{
		/// <summary>
		/// The fully qualified name of the handler class.
		/// </summary>
		public string HandlerType { get; } = handlerType;

		/// <summary>
		/// The fully qualified name of the message type.
		/// </summary>
		public string MessageType { get; } = messageType;

		/// <summary>
		/// The fully qualified return type of HandleAsync.
		/// </summary>
		public string ReturnType { get; } = returnType;

		/// <summary>
		/// Whether the return type is Task&lt;T&gt; (not Task).
		/// </summary>
		public bool IsTaskOfT { get; } = isTaskOfT;
	}
}
