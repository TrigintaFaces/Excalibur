// SPDX-FileCopyrightText: Copyright (c) 2026 The Excalibur Project
// SPDX-License-Identifier: LicenseRef-Excalibur-1.0 OR AGPL-3.0-or-later OR SSPL-1.0 OR Apache-2.0


using System.Collections.Immutable;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Excalibur.Dispatch.SourceGenerators;

/// <summary>
/// Source generator that creates compile-time handler invokers for AOT compatibility.
/// Generates static methods to invoke handlers without reflection.
/// </summary>
[Generator]
public sealed class HandlerInvokerSourceGenerator : IIncrementalGenerator
{
	private static readonly HashSet<string> HandlerInterfaces =
	[
		"IActionHandler", "IEventHandler", "IDocumentHandler", "IQueryHandler"
	];

	/// <summary>
	/// Initializes the handler invoker source generator with the given context.
	/// Sets up syntax providers to find handler implementations and registers
	/// source output generation for compile-time handler invoker creation.
	/// </summary>
	/// <param name="context">The generator initialization context providing access to syntax providers and source output registration.</param>
	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		// Find all handler implementations
		var handlers = context.SyntaxProvider
			.CreateSyntaxProvider(
				predicate: static (node, _) => IsHandlerCandidate(node),
				transform: static (context, _) => GetHandlerInfo(context))
			.Where(static info => info != null)
			.Select(static (info, _) => info!);

		// Generate the handler invoker registry
		context.RegisterSourceOutput(handlers.Collect(), GenerateHandlerInvokerRegistry);
	}

	private static bool IsHandlerCandidate(SyntaxNode node) =>
		node is ClassDeclarationSyntax { BaseList: not null } classDecl &&
		!classDecl.Modifiers.Any(static m => m.IsKind(SyntaxKind.AbstractKeyword));

	private static HandlerInfo? GetHandlerInfo(GeneratorSyntaxContext context)
	{
		if (context.SemanticModel.GetDeclaredSymbol(context.Node) is not INamedTypeSymbol typeSymbol || typeSymbol.IsAbstract)
		{
			return null;
		}

		// Find implemented handler interfaces
		var handlerInterfaces = new List<HandlerInterfaceInfo>();

		foreach (var @interface in typeSymbol.AllInterfaces)
		{
			if (!@interface.IsGenericType)
			{
				continue;
			}

			var unboundInterface = @interface.ConstructUnboundGenericType();
			var interfaceName = unboundInterface.Name;

			if (!HandlerInterfaces.Contains(interfaceName))
			{
				continue;
			}

			var messageType = @interface.TypeArguments[0];
			var resultType = @interface.TypeArguments.Length > 1 ? @interface.TypeArguments[1] : null;

			handlerInterfaces.Add(new HandlerInterfaceInfo
			{
				InterfaceName = interfaceName,
				MessageType = messageType,
				ResultType = resultType,
				HasResult = resultType != null
			});
		}

		if (handlerInterfaces.Count == 0)
		{
			return null;
		}

		return new HandlerInfo
		{
			HandlerType = typeSymbol,
			FullName = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
			SimpleName = typeSymbol.Name,
			Interfaces = handlerInterfaces
		};
	}

	private static void GenerateHandlerInvokerRegistry(SourceProductionContext context, ImmutableArray<HandlerInfo> handlers)
	{
		if (handlers.IsDefaultOrEmpty)
		{
			return;
		}

		var sb = new StringBuilder();

		// File header
		_ = sb.AppendLine("// <auto-generated/>");
		_ = sb.AppendLine($"// Generated on: {DateTimeOffset.UtcNow:yyyy-MM-dd HH:mm:ss} UTC");
		_ = sb.AppendLine($"// Handler types discovered: {handlers.Length}");
		_ = sb.AppendLine();

		// Imports
		_ = sb.AppendLine("#nullable enable");
		_ = sb.AppendLine("using System;");
		_ = sb.AppendLine("using System.Collections.Generic;");
		_ = sb.AppendLine("using System.Collections.Frozen;");
		_ = sb.AppendLine("using System.Threading;");
		_ = sb.AppendLine("using System.Threading.Tasks;");
		_ = sb.AppendLine("using System.Diagnostics.CodeAnalysis;");
		_ = sb.AppendLine("using Excalibur.Dispatch.Abstractions;");
		_ = sb.AppendLine();

		_ = sb.AppendLine("namespace Excalibur.Dispatch.Delivery.Handlers;");
		_ = sb.AppendLine();

		// Generate HandlerInvokerRegistry partial class
		_ = sb.AppendLine("/// <summary>");
		_ = sb.AppendLine("/// Generated handler invoker registry for AOT compatibility.");
		_ = sb.AppendLine("/// </summary>");
		_ = sb.AppendLine("[UnconditionalSuppressMessage(\"AOT\", \"IL2026:RequiresUnreferencedCode\")]");
		_ = sb.AppendLine("[UnconditionalSuppressMessage(\"AOT\", \"IL3050:RequiresDynamicCode\")]");
		_ = sb.AppendLine("public static partial class HandlerInvokerRegistry");
		_ = sb.AppendLine("{");

		// Generate invoker dictionary
		_ = sb.AppendLine(
			" private static readonly FrozenDictionary<Type, Func<object, IDispatchMessage, CancellationToken, Task<object?>>> _invokers;");
		_ = sb.AppendLine();

		// Static constructor
		_ = sb.AppendLine(" static HandlerInvokerRegistry()");
		_ = sb.AppendLine(" {");
		_ = sb.AppendLine(" var invokers = new Dictionary<Type, Func<object, IDispatchMessage, CancellationToken, Task<object?>>>");
		_ = sb.AppendLine(" {");

		foreach (var handler in handlers)
		{
			foreach (var @interface in handler.Interfaces)
			{
				var methodName = $"Invoke_{handler.SimpleName}_{@interface.MessageType.Name}";
				_ = sb.AppendLine($" [typeof({handler.FullName})] = {methodName},");
			}
		}

		_ = sb.AppendLine(" };");
		_ = sb.AppendLine(" _invokers = invokers.ToFrozenDictionary();");
		_ = sb.AppendLine(" }");
		_ = sb.AppendLine();

		// Generate GetInvoker method
		_ = sb.AppendLine(" /// <summary>");
		_ = sb.AppendLine(" /// Gets the invoker for the specified handler type.");
		_ = sb.AppendLine(" /// </summary>");
		_ = sb.AppendLine(
			" internal static Func<object, IDispatchMessage, CancellationToken, Task<object?>>? GetInvoker(Type handlerType)");
		_ = sb.AppendLine(" {");
		_ = sb.AppendLine(" return _invokers.TryGetValue(handlerType, out var invoker) ? invoker : null;");
		_ = sb.AppendLine(" }");
		_ = sb.AppendLine();

		// Generate individual invoker methods
		foreach (var handler in handlers)
		{
			foreach (var @interface in handler.Interfaces)
			{
				GenerateInvokerMethod(sb, handler, @interface);
			}
		}

		_ = sb.AppendLine("}");

		context.AddSource("HandlerInvokerRegistry.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
	}

	private static void GenerateInvokerMethod(StringBuilder sb, HandlerInfo handler, HandlerInterfaceInfo @interface)
	{
		var methodName = $"Invoke_{handler.SimpleName}_{@interface.MessageType.Name}";
		var messageTypeName = @interface.MessageType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

		_ = sb.AppendLine($" private static async Task<object?> {methodName}(");
		_ = sb.AppendLine(" object handler,");
		_ = sb.AppendLine(" IDispatchMessage message,");
		_ = sb.AppendLine(" CancellationToken cancellationToken)");
		_ = sb.AppendLine(" {");
		_ = sb.AppendLine($" var typedHandler = ({handler.FullName})handler;");
		_ = sb.AppendLine($" var typedMessage = ({messageTypeName})message;");

		if (@interface.HasResult)
		{
			_ = sb.AppendLine(
				" var result = await typedHandler.HandleAsync(typedMessage, cancellationToken).ConfigureAwait(false);");
			_ = sb.AppendLine(" return result;");
		}
		else
		{
			_ = sb.AppendLine(" await typedHandler.HandleAsync(typedMessage, cancellationToken).ConfigureAwait(false);");
			_ = sb.AppendLine(" return null;");
		}

		_ = sb.AppendLine(" }");
		_ = sb.AppendLine();
	}

	private sealed class HandlerInfo
	{
		public INamedTypeSymbol HandlerType { get; set; } = null!;
		public string FullName { get; set; } = string.Empty;
		public string SimpleName { get; set; } = string.Empty;
		public List<HandlerInterfaceInfo> Interfaces { get; set; } = [];
	}

	private sealed class HandlerInterfaceInfo
	{
		public string InterfaceName { get; set; } = string.Empty;
		public ITypeSymbol MessageType { get; set; } = null!;
		public ITypeSymbol? ResultType { get; set; }
		public bool HasResult { get; set; }
	}
}
