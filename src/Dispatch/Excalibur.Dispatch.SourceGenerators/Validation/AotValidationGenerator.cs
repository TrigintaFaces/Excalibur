// SPDX-FileCopyrightText: Copyright (c) 2026 The Excalibur Project
// SPDX-License-Identifier: LicenseRef-Excalibur-1.0 OR AGPL-3.0-or-later OR SSPL-1.0 OR Apache-2.0

using System.Collections.Immutable;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Excalibur.Dispatch.SourceGenerators.Validation;

/// <summary>
/// Roslyn incremental source generator that produces AOT-compatible
/// <c>IValidateOptions&lt;T&gt;</c> implementations for classes decorated
/// with <see cref="AotValidatableAttribute"/>.
/// </summary>
/// <remarks>
/// <para>
/// Replaces reflection-based <c>ValidateDataAnnotations()</c> with compile-time generated
/// validators that call DataAnnotations validation logic directly. This ensures full
/// compatibility with Native AOT trimming and eliminates startup reflection costs.
/// </para>
/// <para>
/// The generator scans for the <c>[AotValidatable]</c> attribute, inspects property-level
/// DataAnnotation attributes (<c>[Required]</c>, <c>[Range]</c>, <c>[StringLength]</c>, etc.),
/// and emits a strongly-typed <c>IValidateOptions&lt;T&gt;</c> implementation.
/// </para>
/// </remarks>
[Generator]
public sealed class AotValidationGenerator : IIncrementalGenerator
{
	private const string AotValidatableAttributeName = "Excalibur.Dispatch.SourceGenerators.Validation.AotValidatableAttribute";

	/// <summary>
	/// Initializes the generator by registering a syntax provider that finds classes
	/// annotated with <see cref="AotValidatableAttribute"/> and generates validator code.
	/// </summary>
	/// <param name="context">The generator initialization context.</param>
	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		var candidates = context.SyntaxProvider
			.CreateSyntaxProvider(
				predicate: static (s, _) => s is ClassDeclarationSyntax { AttributeLists.Count: > 0 },
				transform: static (ctx, _) => GetOptionsClassOrNull(ctx))
			.Where(static symbol => symbol is not null)
			.Collect();

		context.RegisterSourceOutput(candidates, GenerateValidators);
	}

	private static INamedTypeSymbol? GetOptionsClassOrNull(GeneratorSyntaxContext context)
	{
		var classDeclaration = (ClassDeclarationSyntax)context.Node;

		if (context.SemanticModel.GetDeclaredSymbol(classDeclaration) is not INamedTypeSymbol symbol)
		{
			return null;
		}

		foreach (var attribute in symbol.GetAttributes())
		{
			if (attribute.AttributeClass?.ToDisplayString() == AotValidatableAttributeName)
			{
				return symbol;
			}
		}

		return null;
	}

	private void GenerateValidators(SourceProductionContext context, ImmutableArray<INamedTypeSymbol?> symbols)
	{
		var seen = new HashSet<ISymbol?>(SymbolEqualityComparer.Default);

		foreach (var symbol in symbols)
		{
			if (symbol is INamedTypeSymbol optionsType && seen.Add(symbol))
			{
				GenerateValidator(context, optionsType);
			}
		}
	}

	private void GenerateValidator(SourceProductionContext context, INamedTypeSymbol optionsType)
	{
		var namespaceName = optionsType.ContainingNamespace.ToDisplayString();
		var className = optionsType.Name;
		var validatorName = $"{className}Validator";

		// Check attribute for custom validator name
		foreach (var attr in optionsType.GetAttributes())
		{
			if (attr.AttributeClass?.ToDisplayString() == AotValidatableAttributeName)
			{
				foreach (var namedArg in attr.NamedArguments)
				{
					if (namedArg.Key == "ValidatorClassName" && namedArg.Value.Value is string customName)
					{
						validatorName = customName;
					}
				}
			}
		}

		var sb = new StringBuilder();
		_ = sb.AppendLine("// <auto-generated/>");
		_ = sb.AppendLine("#nullable enable");
		_ = sb.AppendLine();
		_ = sb.AppendLine("using System.Collections.Generic;");
		_ = sb.AppendLine("using System.ComponentModel.DataAnnotations;");
		_ = sb.AppendLine("using Microsoft.Extensions.Options;");
		_ = sb.AppendLine();
		_ = sb.AppendLine($"namespace {namespaceName};");
		_ = sb.AppendLine();
		_ = sb.AppendLine("/// <summary>");
		_ = sb.AppendLine($"/// AOT-generated validator for <see cref=\"{className}\"/>.");
		_ = sb.AppendLine("/// </summary>");
		_ = sb.AppendLine($"public sealed class {validatorName} : IValidateOptions<{className}>");
		_ = sb.AppendLine("{");
		_ = sb.AppendLine($"\tpublic ValidateOptionsResult Validate(string? name, {className} options)");
		_ = sb.AppendLine("\t{");
		_ = sb.AppendLine("\t\tvar failures = new List<string>();");
		_ = sb.AppendLine();

		// Discover properties with DataAnnotation attributes
		foreach (var member in optionsType.GetMembers())
		{
			if (member is not IPropertySymbol property || property.IsStatic)
			{
				continue;
			}

			foreach (var attr in property.GetAttributes())
			{
				var attrName = attr.AttributeClass?.Name;

				if (attrName == "RequiredAttribute")
				{
					_ = sb.AppendLine($"\t\tif (options.{property.Name} is null)");
					_ = sb.AppendLine($"\t\t\tfailures.Add(\"The {property.Name} field is required.\");");
					_ = sb.AppendLine();
				}
				else if (attrName == "RangeAttribute" && attr.ConstructorArguments.Length >= 2)
				{
					var min = attr.ConstructorArguments[0].Value;
					var max = attr.ConstructorArguments[1].Value;
					_ = sb.AppendLine($"\t\tif (options.{property.Name} < {min} || options.{property.Name} > {max})");
					_ = sb.AppendLine($"\t\t\tfailures.Add(\"The field {property.Name} must be between {min} and {max}.\");");
					_ = sb.AppendLine();
				}
				else if (attrName == "StringLengthAttribute" && attr.ConstructorArguments.Length >= 1)
				{
					var maxLength = attr.ConstructorArguments[0].Value;
					_ = sb.AppendLine($"\t\tif (options.{property.Name}?.Length > {maxLength})");
					_ = sb.AppendLine($"\t\t\tfailures.Add(\"The field {property.Name} must have a maximum length of {maxLength}.\");");
					_ = sb.AppendLine();
				}
			}
		}

		_ = sb.AppendLine("\t\tif (failures.Count > 0)");
		_ = sb.AppendLine("\t\t\treturn ValidateOptionsResult.Fail(failures);");
		_ = sb.AppendLine();
		_ = sb.AppendLine("\t\treturn ValidateOptionsResult.Success;");
		_ = sb.AppendLine("\t}");
		_ = sb.AppendLine("}");

		context.AddSource($"{validatorName}.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
	}
}
