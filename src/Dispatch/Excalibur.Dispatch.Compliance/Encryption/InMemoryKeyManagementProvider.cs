// SPDX-FileCopyrightText: Copyright (c) 2026 The Excalibur Project
// SPDX-License-Identifier: LicenseRef-Excalibur-1.0 OR AGPL-3.0-or-later OR SSPL-1.0 OR Apache-2.0

using System.Collections.Concurrent;
using System.Security.Cryptography;

using Microsoft.Extensions.Logging;

namespace Excalibur.Dispatch.Compliance;

/// <summary>
/// In-memory implementation of key management for development and testing.
/// </summary>
/// <remarks>
/// <para>
/// <strong>WARNING:</strong> This implementation stores key material in memory and is NOT suitable
/// for production use. For production environments, use cloud KMS providers (AWS KMS, Azure Key Vault,
/// Google Cloud KMS) or HSM-backed implementations.
/// </para>
/// <para>
/// Features supported:
/// <list type="bullet">
/// <item>Key generation with AES-256</item>
/// <item>Key rotation (creates new version, marks old as decrypt-only)</item>
/// <item>Key deletion with retention period</item>
/// <item>Key suspension</item>
/// <item>GDPR cryptographic erasure via key destruction</item>
/// </list>
/// </para>
/// </remarks>
public sealed partial class InMemoryKeyManagementProvider : IKeyManagementProvider, IKeyMaterialProvider, IDisposable
{
	private const int KeySizeBytes = 32; // AES-256

	private readonly ConcurrentDictionary<string, KeyEntry> _keys = new();
	private readonly ILogger<InMemoryKeyManagementProvider> _logger;
	private readonly InMemoryKeyManagementOptions _options;
	private readonly Lazy<KeyMetadata?> _defaultKeyLazy;
	private volatile bool _disposed;

	/// <summary>
	/// Initializes a new instance of the <see cref="InMemoryKeyManagementProvider"/> class.
	/// </summary>
	/// <param name="logger">The logger for diagnostics.</param>
	/// <param name="options">Optional configuration options.</param>
	public InMemoryKeyManagementProvider(
		ILogger<InMemoryKeyManagementProvider> logger,
		InMemoryKeyManagementOptions? options = null)
	{
		_logger = logger ?? throw new ArgumentNullException(nameof(logger));
		_options = options ?? new InMemoryKeyManagementOptions();

		// Deferred key generation using lazy initialization (AD-220-5)
		// This avoids sync-over-async in constructor while ensuring default key is created on first access
		_defaultKeyLazy = new Lazy<KeyMetadata?>(() =>
			_options.AutoGenerateDefaultKey ? GenerateDefaultKeySync() : null);
	}

	/// <inheritdoc/>
	public Task<KeyMetadata?> GetKeyAsync(string keyId, CancellationToken cancellationToken)
	{
		ObjectDisposedException.ThrowIf(_disposed, this);
		ArgumentException.ThrowIfNullOrEmpty(keyId);

		// Trigger lazy initialization if requesting the default key
		if (keyId == _options.DefaultKeyId && _options.AutoGenerateDefaultKey)
		{
			_ = _defaultKeyLazy.Value;
		}

		if (!_keys.TryGetValue(keyId, out var keyEntry))
		{
			return Task.FromResult<KeyMetadata?>(null);
		}

		// Return the latest version metadata
		var latestVersion = keyEntry.Versions.Keys.Max();
		var versionEntry = keyEntry.Versions[latestVersion];

		return Task.FromResult<KeyMetadata?>(CreateMetadata(keyEntry, versionEntry));
	}

	/// <inheritdoc/>
	public Task<KeyMetadata?> GetKeyVersionAsync(string keyId, int version, CancellationToken cancellationToken)
	{
		ObjectDisposedException.ThrowIf(_disposed, this);
		ArgumentException.ThrowIfNullOrEmpty(keyId);

		if (!_keys.TryGetValue(keyId, out var keyEntry))
		{
			return Task.FromResult<KeyMetadata?>(null);
		}

		if (!keyEntry.Versions.TryGetValue(version, out var versionEntry))
		{
			return Task.FromResult<KeyMetadata?>(null);
		}

		return Task.FromResult<KeyMetadata?>(CreateMetadata(keyEntry, versionEntry));
	}

	/// <inheritdoc/>
	public Task<IReadOnlyList<KeyMetadata>> ListKeysAsync(
		KeyStatus? status,
		string? purpose,
		CancellationToken cancellationToken)
	{
		ObjectDisposedException.ThrowIf(_disposed, this);

		var results = new List<KeyMetadata>();

		foreach (var keyEntry in _keys.Values)
		{
			// Filter by purpose if specified
			if (purpose is not null && keyEntry.Purpose != purpose)
			{
				continue;
			}

			// Get latest version for each key
			var latestVersion = keyEntry.Versions.Keys.Max();
			var versionEntry = keyEntry.Versions[latestVersion];

			// Filter by status if specified
			if (status.HasValue && versionEntry.Status != status.Value)
			{
				continue;
			}

			results.Add(CreateMetadata(keyEntry, versionEntry));
		}

		return Task.FromResult<IReadOnlyList<KeyMetadata>>(results);
	}

	/// <inheritdoc/>
	public Task<KeyRotationResult> RotateKeyAsync(
		string keyId,
		EncryptionAlgorithm algorithm,
		string? purpose,
		DateTimeOffset? expiresAt,
		CancellationToken cancellationToken)
	{
		ObjectDisposedException.ThrowIf(_disposed, this);
		ArgumentException.ThrowIfNullOrEmpty(keyId);

		try
		{
			KeyMetadata? previousKeyMetadata = null;

			if (_keys.TryGetValue(keyId, out var existingEntry))
			{
				// Rotating existing key - mark current version as decrypt-only
				var currentVersion = existingEntry.Versions.Keys.Max();
				var currentVersionEntry = existingEntry.Versions[currentVersion];

				if (currentVersionEntry.Status == KeyStatus.Active)
				{
					previousKeyMetadata = CreateMetadata(existingEntry, currentVersionEntry);
					currentVersionEntry.Status = KeyStatus.DecryptOnly;
					currentVersionEntry.RotatedAt = DateTimeOffset.UtcNow;
				}

				// Create new version
				var newVersion = currentVersion + 1;
				var newVersionEntry = CreateVersionEntry(expiresAt);
				existingEntry.Versions[newVersion] = newVersionEntry;

				LogKeyRotated(keyId, currentVersion, newVersion);

				var newMetadata = CreateMetadata(existingEntry, newVersionEntry);
				return Task.FromResult(KeyRotationResult.Succeeded(newMetadata, previousKeyMetadata));
			}
			else
			{
				// Creating new key
				var keyEntry = new KeyEntry { KeyId = keyId, Purpose = purpose, Algorithm = algorithm };

				var versionEntry = CreateVersionEntry(expiresAt);
				keyEntry.Versions[1] = versionEntry;

				if (!_keys.TryAdd(keyId, keyEntry))
				{
					return Task.FromResult(KeyRotationResult.Failed("Key already exists (race condition)."));
				}

				LogKeyCreated(keyId);

				var newMetadata = CreateMetadata(keyEntry, versionEntry);
				return Task.FromResult(KeyRotationResult.Succeeded(newMetadata));
			}
		}
		catch (Exception ex)
		{
			LogKeyRotationFailed(ex, keyId);
			return Task.FromResult(KeyRotationResult.Failed(ex.Message));
		}
	}

	/// <inheritdoc/>
	public Task<bool> DeleteKeyAsync(string keyId, int retentionDays, CancellationToken cancellationToken)
	{
		ObjectDisposedException.ThrowIf(_disposed, this);
		ArgumentException.ThrowIfNullOrEmpty(keyId);

		if (!_keys.TryGetValue(keyId, out var keyEntry))
		{
			return Task.FromResult(false);
		}

		// Mark all versions as pending destruction
		foreach (var versionEntry in keyEntry.Versions.Values)
		{
			versionEntry.Status = KeyStatus.PendingDestruction;
			versionEntry.ScheduledDeletionAt = DateTimeOffset.UtcNow.AddDays(retentionDays);
		}

		LogKeyDeletionScheduled(keyId, retentionDays);

		return Task.FromResult(true);
	}

	/// <inheritdoc/>
	public Task<bool> SuspendKeyAsync(string keyId, string reason, CancellationToken cancellationToken)
	{
		ObjectDisposedException.ThrowIf(_disposed, this);
		ArgumentException.ThrowIfNullOrEmpty(keyId);
		ArgumentException.ThrowIfNullOrEmpty(reason);

		if (!_keys.TryGetValue(keyId, out var keyEntry))
		{
			return Task.FromResult(false);
		}

		// Suspend all versions
		foreach (var versionEntry in keyEntry.Versions.Values)
		{
			if (versionEntry.Status is not KeyStatus.Destroyed)
			{
				versionEntry.Status = KeyStatus.Suspended;
				versionEntry.SuspensionReason = reason;
			}
		}

		LogKeySuspended(keyId, reason);

		return Task.FromResult(true);
	}

	/// <inheritdoc/>
	public Task<KeyMetadata?> GetActiveKeyAsync(string? purpose, CancellationToken cancellationToken)
	{
		ObjectDisposedException.ThrowIf(_disposed, this);

		foreach (var keyEntry in _keys.Values)
		{
			// Filter by purpose if specified
			if (purpose is not null && keyEntry.Purpose != purpose)
			{
				continue;
			}

			// Find the active version
			foreach (var version in keyEntry.Versions.Keys.OrderByDescending(v => v))
			{
				var versionEntry = keyEntry.Versions[version];
				if (versionEntry.Status == KeyStatus.Active)
				{
					// Check expiration
					if (versionEntry.ExpiresAt.HasValue && versionEntry.ExpiresAt.Value <= DateTimeOffset.UtcNow)
					{
						continue;
					}

					return Task.FromResult<KeyMetadata?>(CreateMetadata(keyEntry, versionEntry));
				}
			}
		}

		// If no active key found and auto-generation is enabled, trigger lazy initialization
		if (purpose is null && _options.AutoGenerateDefaultKey)
		{
			// Force lazy initialization if not already done
			_ = _defaultKeyLazy.Value;

			// Try again to find the key
			if (_keys.TryGetValue(_options.DefaultKeyId, out var defaultEntry))
			{
				var latestVersion = defaultEntry.Versions.Keys.Max();
				var versionEntry = defaultEntry.Versions[latestVersion];
				if (versionEntry.Status == KeyStatus.Active)
				{
					return Task.FromResult<KeyMetadata?>(CreateMetadata(defaultEntry, versionEntry));
				}
			}
		}

		return Task.FromResult<KeyMetadata?>(null);
	}

	/// <inheritdoc/>
	Task<byte[]> IKeyMaterialProvider.GetKeyMaterialAsync(string keyId, int version, CancellationToken cancellationToken)
	{
		ObjectDisposedException.ThrowIf(_disposed, this);

		if (!_keys.TryGetValue(keyId, out var keyEntry))
		{
			throw new EncryptionException(Resources.InMemoryKeyManagementProvider_KeyNotFound)
			{
				ErrorCode = EncryptionErrorCode.KeyNotFound
			};
		}

		if (!keyEntry.Versions.TryGetValue(version, out var versionEntry))
		{
			throw new EncryptionException(Resources.InMemoryKeyManagementProvider_KeyVersionNotFound)
			{
				ErrorCode = EncryptionErrorCode.KeyNotFound
			};
		}

		if (versionEntry.KeyMaterial is null)
		{
			throw new EncryptionException(Resources.InMemoryKeyManagementProvider_KeyMaterialDestroyed)
			{
				ErrorCode = EncryptionErrorCode.KeyNotFound
			};
		}

		// Return a copy to prevent external modification
		var copy = new byte[versionEntry.KeyMaterial.Length];
		versionEntry.KeyMaterial.CopyTo(copy, 0);
		return Task.FromResult(copy);
	}

	/// <inheritdoc/>
	public void Dispose()
	{
		if (_disposed)
		{
			return;
		}

		// Securely clear all key material
		foreach (var keyEntry in _keys.Values)
		{
			foreach (var versionEntry in keyEntry.Versions.Values)
			{
				if (versionEntry.KeyMaterial is not null)
				{
					CryptographicOperations.ZeroMemory(versionEntry.KeyMaterial);
					versionEntry.KeyMaterial = null;
				}
			}
		}

		_keys.Clear();
		_disposed = true;

		LogProviderDisposed();
	}

	/// <summary>
	/// Immediately destroys a key and all its versions (crypto-shredding for GDPR erasure).
	/// </summary>
	/// <param name="keyId">The key identifier.</param>
	/// <returns>True if the key was destroyed; false if not found.</returns>
	public bool DestroyKeyImmediately(string keyId)
	{
		ObjectDisposedException.ThrowIf(_disposed, this);

		if (!_keys.TryRemove(keyId, out var keyEntry))
		{
			return false;
		}

		// Securely clear all key material
		foreach (var versionEntry in keyEntry.Versions.Values)
		{
			if (versionEntry.KeyMaterial is not null)
			{
				CryptographicOperations.ZeroMemory(versionEntry.KeyMaterial);
				versionEntry.KeyMaterial = null;
			}

			versionEntry.Status = KeyStatus.Destroyed;
		}

		LogKeyDestroyed(keyId);

		return true;
	}

	private static KeyVersionEntry CreateVersionEntry(DateTimeOffset? expiresAt)
	{
		var keyMaterial = new byte[KeySizeBytes];
		RandomNumberGenerator.Fill(keyMaterial);

		return new KeyVersionEntry
		{
			KeyMaterial = keyMaterial,
			Status = KeyStatus.Active,
			CreatedAt = DateTimeOffset.UtcNow,
			ExpiresAt = expiresAt,
			IsFipsCompliant = CryptoConfig.AllowOnlyFipsAlgorithms
		};
	}

	private static KeyMetadata CreateMetadata(KeyEntry keyEntry, KeyVersionEntry versionEntry)
	{
		var version = keyEntry.Versions.FirstOrDefault(kvp => kvp.Value == versionEntry).Key;

		return new KeyMetadata
		{
			KeyId = keyEntry.KeyId,
			Version = version,
			Status = versionEntry.Status,
			Algorithm = keyEntry.Algorithm,
			CreatedAt = versionEntry.CreatedAt,
			ExpiresAt = versionEntry.ExpiresAt,
			LastRotatedAt = versionEntry.RotatedAt,
			Purpose = keyEntry.Purpose,
			IsFipsCompliant = versionEntry.IsFipsCompliant
		};
	}

	[LoggerMessage(LogLevel.Information, "Rotated key {KeyId} from v{OldVersion} to v{NewVersion}")]
	private partial void LogKeyRotated(string keyId, int oldVersion, int newVersion);

	[LoggerMessage(LogLevel.Information, "Created new key {KeyId} v1")]
	private partial void LogKeyCreated(string keyId);

	[LoggerMessage(LogLevel.Error, "Failed to rotate key {KeyId}")]
	private partial void LogKeyRotationFailed(Exception exception, string keyId);

	[LoggerMessage(LogLevel.Warning, "Key {KeyId} scheduled for deletion in {RetentionDays} days (crypto-shredding)")]
	private partial void LogKeyDeletionScheduled(string keyId, int retentionDays);

	[LoggerMessage(LogLevel.Warning, "Key {KeyId} suspended: {Reason}")]
	private partial void LogKeySuspended(string keyId, string reason);

	[LoggerMessage(LogLevel.Debug, "InMemoryKeyManagementProvider disposed - all key material securely cleared")]
	private partial void LogProviderDisposed();

	[LoggerMessage(LogLevel.Warning, "Key {KeyId} immediately destroyed (crypto-shredding)")]
	private partial void LogKeyDestroyed(string keyId);

	/// <summary>
	/// Generates the default key synchronously for lazy initialization.
	/// </summary>
	/// <remarks>
	/// This method is safe because RotateKeyAsync is fully synchronous (uses Task.FromResult).
	/// </remarks>
	private KeyMetadata? GenerateDefaultKeySync()
	{
		var result = RotateKeyAsync(
			_options.DefaultKeyId,
			EncryptionAlgorithm.Aes256Gcm,
			null,
			null,
			CancellationToken.None).GetAwaiter().GetResult();

		return result.NewKey;
	}

	private sealed class KeyEntry
	{
		public required string KeyId { get; init; }
		public string? Purpose { get; init; }
		public EncryptionAlgorithm Algorithm { get; init; }
		public ConcurrentDictionary<int, KeyVersionEntry> Versions { get; } = new();
	}

	private sealed class KeyVersionEntry
	{
		public byte[]? KeyMaterial { get; set; }
		public KeyStatus Status { get; set; }
		public DateTimeOffset CreatedAt { get; init; }
		public DateTimeOffset? ExpiresAt { get; init; }
		public DateTimeOffset? RotatedAt { get; set; }
		public DateTimeOffset? ScheduledDeletionAt { get; set; }
		public string? SuspensionReason { get; set; }
		public bool IsFipsCompliant { get; init; }
	}
}

/// <summary>
/// Configuration options for the in-memory key management provider.
/// </summary>
public sealed class InMemoryKeyManagementOptions
{
	/// <summary>
	/// Gets or sets a value indicating whether to auto-generate a default key on initialization.
	/// Default is true.
	/// </summary>
	public bool AutoGenerateDefaultKey { get; set; } = true;

	/// <summary>
	/// Gets or sets the identifier for the auto-generated default key.
	/// Default is "default".
	/// </summary>
	public string DefaultKeyId { get; set; } = "default";
}
